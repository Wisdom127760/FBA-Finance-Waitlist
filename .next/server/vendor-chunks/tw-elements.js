"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tw-elements";
exports.ids = ["vendor-chunks/tw-elements"];
exports.modules = {

/***/ "(rsc)/./node_modules/tw-elements/js/tw-elements.es.min.js":
/*!***********************************************************!*\
  !*** ./node_modules/tw-elements/js/tw-elements.es.min.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ qs),\n/* harmony export */   Carousel: () => (/* binding */ Z),\n/* harmony export */   Collapse: () => (/* binding */ pe),\n/* harmony export */   Dropdown: () => (/* binding */ X),\n/* harmony export */   Input: () => (/* binding */ $),\n/* harmony export */   Modal: () => (/* binding */ ai),\n/* harmony export */   Offcanvas: () => (/* binding */ _e),\n/* harmony export */   Popover: () => (/* binding */ Nn),\n/* harmony export */   Ripple: () => (/* binding */ Hn),\n/* harmony export */   ScrollSpy: () => (/* binding */ In),\n/* harmony export */   Tab: () => (/* binding */ Rn),\n/* harmony export */   Tooltip: () => (/* binding */ Qt),\n/* harmony export */   initTWE: () => (/* binding */ lc)\n/* harmony export */ });\nvar Yn = Object.defineProperty;\nvar Kn = (i, t, e) => t in i ? Yn(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;\nvar Ne = (i, t, e) => (Kn(i, typeof t != \"symbol\" ? t + \"\" : t, e), e);\n/*!\n* TW Elements\n* Version: FREE 2.0.0\n* \n* Copyright: Material Design for Bootstrap\n* https://mdbootstrap.com/\n* \n* Read the license: https://tw-elements.com/license/\n*\n*\n* Documentation: https://tw-elements.com/\n*\n* Support: https://mdbootstrap.com/support/cat/twe\n*\n* Contact: tailwind@mdbootstrap.com\n* \n*/\nconst Se = (() => {\n  const i = {};\n  let t = 1;\n  return {\n    set(e, s, n) {\n      typeof e[s] > \"u\" && (e[s] = {\n        key: s,\n        id: t\n      }, t++), i[e[s].id] = n;\n    },\n    get(e, s) {\n      if (!e || typeof e[s] > \"u\")\n        return null;\n      const n = e[s];\n      return n.key === s ? i[n.id] : null;\n    },\n    delete(e, s) {\n      if (typeof e[s] > \"u\")\n        return;\n      const n = e[s];\n      n.key === s && (delete i[n.id], delete e[s]);\n    }\n  };\n})(), V = {\n  setData(i, t, e) {\n    Se.set(i, t, e);\n  },\n  getData(i, t) {\n    return Se.get(i, t);\n  },\n  removeData(i, t) {\n    Se.delete(i, t);\n  }\n}, zn = 1e6, qn = 1e3, Ze = \"transitionend\", Xn = (i) => i == null ? `${i}` : {}.toString.call(i).match(/\\s([a-z]+)/i)[1].toLowerCase(), Gn = (i) => {\n  do\n    i += Math.floor(Math.random() * zn);\n  while (document.getElementById(i));\n  return i;\n}, ks = (i) => {\n  let t = i.getAttribute(\"data-twe-target\");\n  if (!t || t === \"#\") {\n    let e = i.getAttribute(\"href\");\n    if (!e || !e.includes(\"#\") && !e.startsWith(\".\"))\n      return null;\n    e.includes(\"#\") && !e.startsWith(\"#\") && (e = `#${e.split(\"#\")[1]}`), t = e && e !== \"#\" ? e.trim() : null;\n  }\n  return t;\n}, ci = (i) => {\n  const t = ks(i);\n  return t && document.querySelector(t) ? t : null;\n}, nt = (i) => {\n  const t = ks(i);\n  return t ? document.querySelector(t) : null;\n}, Je = (i) => {\n  if (!i)\n    return 0;\n  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(i);\n  const s = Number.parseFloat(t), n = Number.parseFloat(e);\n  return !s && !n ? 0 : (t = t.split(\",\")[0], e = e.split(\",\")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * qn);\n}, Ps = (i) => {\n  i.dispatchEvent(new Event(Ze));\n}, St = (i) => !i || typeof i != \"object\" ? !1 : (typeof i.jquery < \"u\" && (i = i[0]), typeof i.nodeType < \"u\"), rt = (i) => St(i) ? i.jquery ? i[0] : i : typeof i == \"string\" && i.length > 0 ? document.querySelector(i) : null, R = (i, t, e) => {\n  Object.keys(e).forEach((s) => {\n    const n = e[s], r = t[s], o = r && St(r) ? \"element\" : Xn(r);\n    if (!new RegExp(n).test(o))\n      throw new Error(\n        `${i.toUpperCase()}: Option \"${s}\" provided type \"${o}\" but expected type \"${n}\".`\n      );\n  });\n}, kt = (i) => {\n  if (!i)\n    return !1;\n  if (i.style && i.parentNode && i.parentNode.style) {\n    const t = getComputedStyle(i), e = getComputedStyle(i.parentNode);\n    return t.display !== \"none\" && e.display !== \"none\" && t.visibility !== \"hidden\";\n  }\n  return !1;\n}, gt = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains(\"disabled\") ? !0 : typeof i.disabled < \"u\" ? i.disabled : i.hasAttribute(\"disabled\") && i.getAttribute(\"disabled\") !== \"false\", Ms = (i) => {\n  if (!document.documentElement.attachShadow)\n    return null;\n  if (typeof i.getRootNode == \"function\") {\n    const t = i.getRootNode();\n    return t instanceof ShadowRoot ? t : null;\n  }\n  return i instanceof ShadowRoot ? i : i.parentNode ? Ms(i.parentNode) : null;\n}, me = () => function() {\n}, Xt = (i) => {\n  i.offsetHeight;\n}, Hs = () => {\n  const { jQuery: i } = window;\n  return i && !document.body.hasAttribute(\"data-twe-no-jquery\") ? i : null;\n}, Le = [], Vs = (i) => {\n  document.readyState === \"loading\" ? (Le.length || document.addEventListener(\"DOMContentLoaded\", () => {\n    Le.forEach((t) => t());\n  }), Le.push(i)) : i();\n}, M = () => document.documentElement.dir === \"rtl\", Ft = (i) => document.createElement(i), _t = (i) => {\n  typeof i == \"function\" && i();\n}, Ws = (i, t, e = !0) => {\n  if (!e) {\n    _t(i);\n    return;\n  }\n  const s = 5, n = Je(t) + s;\n  let r = !1;\n  const o = ({ target: a }) => {\n    a === t && (r = !0, t.removeEventListener(Ze, o), _t(i));\n  };\n  t.addEventListener(Ze, o), setTimeout(() => {\n    r || Ps(t);\n  }, n);\n}, Bs = (i, t, e, s) => {\n  let n = i.indexOf(t);\n  if (n === -1)\n    return i[!e && s ? i.length - 1 : 0];\n  const r = i.length;\n  return n += e ? 1 : -1, s && (n = (n + r) % r), i[Math.max(0, Math.min(n, r - 1))];\n}, Qn = /[^.]*(?=\\..*)\\.|.*/, Zn = /\\..*/, Jn = /::\\d+$/, $e = {};\nlet ki = 1;\nconst tr = {\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n}, er = /^(mouseenter|mouseleave)/i, js = /* @__PURE__ */ new Set([\n  \"click\",\n  \"dblclick\",\n  \"mouseup\",\n  \"mousedown\",\n  \"contextmenu\",\n  \"mousewheel\",\n  \"DOMMouseScroll\",\n  \"mouseover\",\n  \"mouseout\",\n  \"mousemove\",\n  \"selectstart\",\n  \"selectend\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"orientationchange\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerup\",\n  \"pointerleave\",\n  \"pointercancel\",\n  \"gesturestart\",\n  \"gesturechange\",\n  \"gestureend\",\n  \"focus\",\n  \"blur\",\n  \"change\",\n  \"reset\",\n  \"select\",\n  \"submit\",\n  \"focusin\",\n  \"focusout\",\n  \"load\",\n  \"unload\",\n  \"beforeunload\",\n  \"resize\",\n  \"move\",\n  \"DOMContentLoaded\",\n  \"readystatechange\",\n  \"error\",\n  \"abort\",\n  \"scroll\"\n]);\nfunction Us(i, t) {\n  return t && `${t}::${ki++}` || i.uidEvent || ki++;\n}\nfunction Fs(i) {\n  const t = Us(i);\n  return i.uidEvent = t, $e[t] = $e[t] || {}, $e[t];\n}\nfunction ir(i, t) {\n  return function e(s) {\n    return s.delegateTarget = i, e.oneOff && d.off(i, s.type, t), t.apply(i, [s]);\n  };\n}\nfunction sr(i, t, e) {\n  return function s(n) {\n    const r = i.querySelectorAll(t);\n    for (let { target: o } = n; o && o !== this; o = o.parentNode)\n      for (let a = r.length; a--; \"\")\n        if (r[a] === o)\n          return n.delegateTarget = o, s.oneOff && d.off(i, n.type, e), e.apply(o, [n]);\n    return null;\n  };\n}\nfunction Ys(i, t, e = null) {\n  const s = Object.keys(i);\n  for (let n = 0, r = s.length; n < r; n++) {\n    const o = i[s[n]];\n    if (o.originalHandler === t && o.delegationSelector === e)\n      return o;\n  }\n  return null;\n}\nfunction Ks(i, t, e) {\n  const s = typeof t == \"string\", n = s ? e : t;\n  let r = zs(i);\n  return js.has(r) || (r = i), [s, n, r];\n}\nfunction Pi(i, t, e, s, n) {\n  if (typeof t != \"string\" || !i)\n    return;\n  if (e || (e = s, s = null), er.test(t)) {\n    const g = (O) => function(T) {\n      if (!T.relatedTarget || T.relatedTarget !== T.delegateTarget && !T.delegateTarget.contains(T.relatedTarget))\n        return O.call(this, T);\n    };\n    s ? s = g(s) : e = g(e);\n  }\n  const [r, o, a] = Ks(\n    t,\n    e,\n    s\n  ), l = Fs(i), u = l[a] || (l[a] = {}), c = Ys(\n    u,\n    o,\n    r ? e : null\n  );\n  if (c) {\n    c.oneOff = c.oneOff && n;\n    return;\n  }\n  const f = Us(\n    o,\n    t.replace(Qn, \"\")\n  ), v = r ? sr(i, e, s) : ir(i, e);\n  v.delegationSelector = r ? e : null, v.originalHandler = o, v.oneOff = n, v.uidEvent = f, u[f] = v, i.addEventListener(a, v, r);\n}\nfunction ti(i, t, e, s, n) {\n  const r = Ys(t[e], s, n);\n  r && (i.removeEventListener(e, r, !!n), delete t[e][r.uidEvent]);\n}\nfunction nr(i, t, e, s) {\n  const n = t[e] || {};\n  Object.keys(n).forEach((r) => {\n    if (r.includes(s)) {\n      const o = n[r];\n      ti(\n        i,\n        t,\n        e,\n        o.originalHandler,\n        o.delegationSelector\n      );\n    }\n  });\n}\nfunction zs(i) {\n  return i = i.replace(Zn, \"\"), tr[i] || i;\n}\nconst d = {\n  on(i, t, e, s) {\n    Pi(i, t, e, s, !1);\n  },\n  one(i, t, e, s) {\n    Pi(i, t, e, s, !0);\n  },\n  off(i, t, e, s) {\n    if (typeof t != \"string\" || !i)\n      return;\n    const [n, r, o] = Ks(\n      t,\n      e,\n      s\n    ), a = o !== t, l = Fs(i), u = t.startsWith(\".\");\n    if (typeof r < \"u\") {\n      if (!l || !l[o])\n        return;\n      ti(\n        i,\n        l,\n        o,\n        r,\n        n ? e : null\n      );\n      return;\n    }\n    u && Object.keys(l).forEach((f) => {\n      nr(\n        i,\n        l,\n        f,\n        t.slice(1)\n      );\n    });\n    const c = l[o] || {};\n    Object.keys(c).forEach((f) => {\n      const v = f.replace(Jn, \"\");\n      if (!a || t.includes(v)) {\n        const g = c[f];\n        ti(\n          i,\n          l,\n          o,\n          g.originalHandler,\n          g.delegationSelector\n        );\n      }\n    });\n  },\n  trigger(i, t, e) {\n    if (typeof t != \"string\" || !i)\n      return null;\n    const s = Hs(), n = zs(t), r = t !== n, o = js.has(n);\n    let a, l = !0, u = !0, c = !1, f = null;\n    return r && s && (a = s.Event(t, e), s(i).trigger(a), l = !a.isPropagationStopped(), u = !a.isImmediatePropagationStopped(), c = a.isDefaultPrevented()), o ? (f = document.createEvent(\"HTMLEvents\"), f.initEvent(n, l, !0)) : f = new CustomEvent(t, {\n      bubbles: l,\n      cancelable: !0\n    }), typeof e < \"u\" && Object.keys(e).forEach((v) => {\n      Object.defineProperty(f, v, {\n        get() {\n          return e[v];\n        }\n      });\n    }), c && f.preventDefault(), u && i.dispatchEvent(f), f.defaultPrevented && typeof a < \"u\" && a.preventDefault(), f;\n  }\n}, rr = \"5.1.3\";\nclass tt {\n  constructor(t) {\n    t = rt(t), t && (this._element = t, V.setData(this._element, this.constructor.DATA_KEY, this));\n  }\n  dispose() {\n    V.removeData(this._element, this.constructor.DATA_KEY), d.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {\n      this[t] = null;\n    });\n  }\n  _queueCallback(t, e, s = !0) {\n    Ws(t, e, s);\n  }\n  /** Static */\n  static getInstance(t) {\n    return V.getData(rt(t), this.DATA_KEY);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static get VERSION() {\n    return rr;\n  }\n  static get NAME() {\n    throw new Error(\n      'You have to implement the static method \"NAME\", for each component!'\n    );\n  }\n  static get DATA_KEY() {\n    return `twe.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n}\nconst or = \"button\", ar = \"active\";\nclass qs extends tt {\n  // Getters\n  static get NAME() {\n    return or;\n  }\n  // Public\n  toggle() {\n    this._element.setAttribute(\n      \"aria-pressed\",\n      this._element.classList.toggle(ar)\n    );\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = qs.getOrCreateInstance(this);\n      t === \"toggle\" && e[t]();\n    });\n  }\n}\nvar k = \"top\", W = \"bottom\", B = \"right\", P = \"left\", ve = \"auto\", Pt = [k, W, B, P], Et = \"start\", Lt = \"end\", Xs = \"clippingParents\", di = \"viewport\", Ct = \"popper\", Gs = \"reference\", ei = /* @__PURE__ */ Pt.reduce(function(i, t) {\n  return i.concat([t + \"-\" + Et, t + \"-\" + Lt]);\n}, []), ui = /* @__PURE__ */ [].concat(Pt, [ve]).reduce(function(i, t) {\n  return i.concat([t, t + \"-\" + Et, t + \"-\" + Lt]);\n}, []), Qs = \"beforeRead\", Zs = \"read\", Js = \"afterRead\", tn = \"beforeMain\", en = \"main\", sn = \"afterMain\", nn = \"beforeWrite\", rn = \"write\", on = \"afterWrite\", an = [Qs, Zs, Js, tn, en, sn, nn, rn, on];\nfunction Q(i) {\n  return i ? (i.nodeName || \"\").toLowerCase() : null;\n}\nfunction j(i) {\n  if (i == null)\n    return window;\n  if (i.toString() !== \"[object Window]\") {\n    var t = i.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return i;\n}\nfunction vt(i) {\n  var t = j(i).Element;\n  return i instanceof t || i instanceof Element;\n}\nfunction F(i) {\n  var t = j(i).HTMLElement;\n  return i instanceof t || i instanceof HTMLElement;\n}\nfunction hi(i) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = j(i).ShadowRoot;\n  return i instanceof t || i instanceof ShadowRoot;\n}\nfunction lr(i) {\n  var t = i.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var s = t.styles[e] || {}, n = t.attributes[e] || {}, r = t.elements[e];\n    !F(r) || !Q(r) || (Object.assign(r.style, s), Object.keys(n).forEach(function(o) {\n      var a = n[o];\n      a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? \"\" : a);\n    }));\n  });\n}\nfunction cr(i) {\n  var t = i.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(s) {\n      var n = t.elements[s], r = t.attributes[s] || {}, o = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), a = o.reduce(function(l, u) {\n        return l[u] = \"\", l;\n      }, {});\n      !F(n) || !Q(n) || (Object.assign(n.style, a), Object.keys(r).forEach(function(l) {\n        n.removeAttribute(l);\n      }));\n    });\n  };\n}\nconst fi = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: lr,\n  effect: cr,\n  requires: [\"computeStyles\"]\n};\nfunction G(i) {\n  return i.split(\"-\")[0];\n}\nvar mt = Math.max, Ee = Math.min, $t = Math.round;\nfunction ii() {\n  var i = navigator.userAgentData;\n  return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction ln() {\n  return !/^((?!chrome|android).)*safari/i.test(ii());\n}\nfunction It(i, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var s = i.getBoundingClientRect(), n = 1, r = 1;\n  t && F(i) && (n = i.offsetWidth > 0 && $t(s.width) / i.offsetWidth || 1, r = i.offsetHeight > 0 && $t(s.height) / i.offsetHeight || 1);\n  var o = vt(i) ? j(i) : window, a = o.visualViewport, l = !ln() && e, u = (s.left + (l && a ? a.offsetLeft : 0)) / n, c = (s.top + (l && a ? a.offsetTop : 0)) / r, f = s.width / n, v = s.height / r;\n  return {\n    width: f,\n    height: v,\n    top: c,\n    right: u + f,\n    bottom: c + v,\n    left: u,\n    x: u,\n    y: c\n  };\n}\nfunction pi(i) {\n  var t = It(i), e = i.offsetWidth, s = i.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {\n    x: i.offsetLeft,\n    y: i.offsetTop,\n    width: e,\n    height: s\n  };\n}\nfunction cn(i, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (i.contains(t))\n    return !0;\n  if (e && hi(e)) {\n    var s = t;\n    do {\n      if (s && i.isSameNode(s))\n        return !0;\n      s = s.parentNode || s.host;\n    } while (s);\n  }\n  return !1;\n}\nfunction J(i) {\n  return j(i).getComputedStyle(i);\n}\nfunction dr(i) {\n  return [\"table\", \"td\", \"th\"].indexOf(Q(i)) >= 0;\n}\nfunction ot(i) {\n  return ((vt(i) ? i.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    i.document\n  )) || window.document).documentElement;\n}\nfunction be(i) {\n  return Q(i) === \"html\" ? i : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    i.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    i.parentNode || // DOM Element detected\n    (hi(i) ? i.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    ot(i)\n  );\n}\nfunction Mi(i) {\n  return !F(i) || // https://github.com/popperjs/popper-core/issues/837\n  J(i).position === \"fixed\" ? null : i.offsetParent;\n}\nfunction ur(i) {\n  var t = /firefox/i.test(ii()), e = /Trident/i.test(ii());\n  if (e && F(i)) {\n    var s = J(i);\n    if (s.position === \"fixed\")\n      return null;\n  }\n  var n = be(i);\n  for (hi(n) && (n = n.host); F(n) && [\"html\", \"body\"].indexOf(Q(n)) < 0; ) {\n    var r = J(n);\n    if (r.transform !== \"none\" || r.perspective !== \"none\" || r.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(r.willChange) !== -1 || t && r.willChange === \"filter\" || t && r.filter && r.filter !== \"none\")\n      return n;\n    n = n.parentNode;\n  }\n  return null;\n}\nfunction Gt(i) {\n  for (var t = j(i), e = Mi(i); e && dr(e) && J(e).position === \"static\"; )\n    e = Mi(e);\n  return e && (Q(e) === \"html\" || Q(e) === \"body\" && J(e).position === \"static\") ? t : e || ur(i) || t;\n}\nfunction _i(i) {\n  return [\"top\", \"bottom\"].indexOf(i) >= 0 ? \"x\" : \"y\";\n}\nfunction zt(i, t, e) {\n  return mt(i, Ee(t, e));\n}\nfunction hr(i, t, e) {\n  var s = zt(i, t, e);\n  return s > e ? e : s;\n}\nfunction dn() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction un(i) {\n  return Object.assign({}, dn(), i);\n}\nfunction hn(i, t) {\n  return t.reduce(function(e, s) {\n    return e[s] = i, e;\n  }, {});\n}\nvar fr = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, un(typeof t != \"number\" ? t : hn(t, Pt));\n};\nfunction pr(i) {\n  var t, e = i.state, s = i.name, n = i.options, r = e.elements.arrow, o = e.modifiersData.popperOffsets, a = G(e.placement), l = _i(a), u = [P, B].indexOf(a) >= 0, c = u ? \"height\" : \"width\";\n  if (!(!r || !o)) {\n    var f = fr(n.padding, e), v = pi(r), g = l === \"y\" ? k : P, O = l === \"y\" ? W : B, T = e.rects.reference[c] + e.rects.reference[l] - o[l] - e.rects.popper[c], A = o[l] - e.rects.reference[l], D = Gt(r), L = D ? l === \"y\" ? D.clientHeight || 0 : D.clientWidth || 0 : 0, m = T / 2 - A / 2, p = f[g], _ = L - v[c] - f[O], b = L / 2 - v[c] / 2 + m, w = zt(p, b, _), C = l;\n    e.modifiersData[s] = (t = {}, t[C] = w, t.centerOffset = w - b, t);\n  }\n}\nfunction _r(i) {\n  var t = i.state, e = i.options, s = e.element, n = s === void 0 ? \"[data-popper-arrow]\" : s;\n  n != null && (typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n) || cn(t.elements.popper, n) && (t.elements.arrow = n));\n}\nconst fn = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: pr,\n  effect: _r,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction Rt(i) {\n  return i.split(\"-\")[1];\n}\nvar gr = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction mr(i, t) {\n  var e = i.x, s = i.y, n = t.devicePixelRatio || 1;\n  return {\n    x: $t(e * n) / n || 0,\n    y: $t(s * n) / n || 0\n  };\n}\nfunction Hi(i) {\n  var t, e = i.popper, s = i.popperRect, n = i.placement, r = i.variation, o = i.offsets, a = i.position, l = i.gpuAcceleration, u = i.adaptive, c = i.roundOffsets, f = i.isFixed, v = o.x, g = v === void 0 ? 0 : v, O = o.y, T = O === void 0 ? 0 : O, A = typeof c == \"function\" ? c({\n    x: g,\n    y: T\n  }) : {\n    x: g,\n    y: T\n  };\n  g = A.x, T = A.y;\n  var D = o.hasOwnProperty(\"x\"), L = o.hasOwnProperty(\"y\"), m = P, p = k, _ = window;\n  if (u) {\n    var b = Gt(e), w = \"clientHeight\", C = \"clientWidth\";\n    if (b === j(e) && (b = ot(e), J(b).position !== \"static\" && a === \"absolute\" && (w = \"scrollHeight\", C = \"scrollWidth\")), b = b, n === k || (n === P || n === B) && r === Lt) {\n      p = W;\n      var y = f && b === _ && _.visualViewport ? _.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        b[w]\n      );\n      T -= y - s.height, T *= l ? 1 : -1;\n    }\n    if (n === P || (n === k || n === W) && r === Lt) {\n      m = B;\n      var N = f && b === _ && _.visualViewport ? _.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        b[C]\n      );\n      g -= N - s.width, g *= l ? 1 : -1;\n    }\n  }\n  var S = Object.assign({\n    position: a\n  }, u && gr), x = c === !0 ? mr({\n    x: g,\n    y: T\n  }, j(e)) : {\n    x: g,\n    y: T\n  };\n  if (g = x.x, T = x.y, l) {\n    var I;\n    return Object.assign({}, S, (I = {}, I[p] = L ? \"0\" : \"\", I[m] = D ? \"0\" : \"\", I.transform = (_.devicePixelRatio || 1) <= 1 ? \"translate(\" + g + \"px, \" + T + \"px)\" : \"translate3d(\" + g + \"px, \" + T + \"px, 0)\", I));\n  }\n  return Object.assign({}, S, (t = {}, t[p] = L ? T + \"px\" : \"\", t[m] = D ? g + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction Er(i) {\n  var t = i.state, e = i.options, s = e.gpuAcceleration, n = s === void 0 ? !0 : s, r = e.adaptive, o = r === void 0 ? !0 : r, a = e.roundOffsets, l = a === void 0 ? !0 : a, u = {\n    placement: G(t.placement),\n    variation: Rt(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: n,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Hi(Object.assign({}, u, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: o,\n    roundOffsets: l\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Hi(Object.assign({}, u, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: l\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst gi = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: Er,\n  data: {}\n};\nvar se = {\n  passive: !0\n};\nfunction vr(i) {\n  var t = i.state, e = i.instance, s = i.options, n = s.scroll, r = n === void 0 ? !0 : n, o = s.resize, a = o === void 0 ? !0 : o, l = j(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return r && u.forEach(function(c) {\n    c.addEventListener(\"scroll\", e.update, se);\n  }), a && l.addEventListener(\"resize\", e.update, se), function() {\n    r && u.forEach(function(c) {\n      c.removeEventListener(\"scroll\", e.update, se);\n    }), a && l.removeEventListener(\"resize\", e.update, se);\n  };\n}\nconst mi = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: vr,\n  data: {}\n};\nvar br = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction ue(i) {\n  return i.replace(/left|right|bottom|top/g, function(t) {\n    return br[t];\n  });\n}\nvar wr = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Vi(i) {\n  return i.replace(/start|end/g, function(t) {\n    return wr[t];\n  });\n}\nfunction Ei(i) {\n  var t = j(i), e = t.pageXOffset, s = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: s\n  };\n}\nfunction vi(i) {\n  return It(ot(i)).left + Ei(i).scrollLeft;\n}\nfunction Tr(i, t) {\n  var e = j(i), s = ot(i), n = e.visualViewport, r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;\n  if (n) {\n    r = n.width, o = n.height;\n    var u = ln();\n    (u || !u && t === \"fixed\") && (a = n.offsetLeft, l = n.offsetTop);\n  }\n  return {\n    width: r,\n    height: o,\n    x: a + vi(i),\n    y: l\n  };\n}\nfunction yr(i) {\n  var t, e = ot(i), s = Ei(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, r = mt(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = mt(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + vi(i), l = -s.scrollTop;\n  return J(n || e).direction === \"rtl\" && (a += mt(e.clientWidth, n ? n.clientWidth : 0) - r), {\n    width: r,\n    height: o,\n    x: a,\n    y: l\n  };\n}\nfunction bi(i) {\n  var t = J(i), e = t.overflow, s = t.overflowX, n = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + n + s);\n}\nfunction pn(i) {\n  return [\"html\", \"body\", \"#document\"].indexOf(Q(i)) >= 0 ? i.ownerDocument.body : F(i) && bi(i) ? i : pn(be(i));\n}\nfunction qt(i, t) {\n  var e;\n  t === void 0 && (t = []);\n  var s = pn(i), n = s === ((e = i.ownerDocument) == null ? void 0 : e.body), r = j(s), o = n ? [r].concat(r.visualViewport || [], bi(s) ? s : []) : s, a = t.concat(o);\n  return n ? a : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    a.concat(qt(be(o)))\n  );\n}\nfunction si(i) {\n  return Object.assign({}, i, {\n    left: i.x,\n    top: i.y,\n    right: i.x + i.width,\n    bottom: i.y + i.height\n  });\n}\nfunction Ar(i, t) {\n  var e = It(i, !1, t === \"fixed\");\n  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction Wi(i, t, e) {\n  return t === di ? si(Tr(i, e)) : vt(t) ? Ar(t, e) : si(yr(ot(i)));\n}\nfunction Cr(i) {\n  var t = qt(be(i)), e = [\"absolute\", \"fixed\"].indexOf(J(i).position) >= 0, s = e && F(i) ? Gt(i) : i;\n  return vt(s) ? t.filter(function(n) {\n    return vt(n) && cn(n, s) && Q(n) !== \"body\";\n  }) : [];\n}\nfunction Or(i, t, e, s) {\n  var n = t === \"clippingParents\" ? Cr(i) : [].concat(t), r = [].concat(n, [e]), o = r[0], a = r.reduce(function(l, u) {\n    var c = Wi(i, u, s);\n    return l.top = mt(c.top, l.top), l.right = Ee(c.right, l.right), l.bottom = Ee(c.bottom, l.bottom), l.left = mt(c.left, l.left), l;\n  }, Wi(i, o, s));\n  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;\n}\nfunction _n(i) {\n  var t = i.reference, e = i.element, s = i.placement, n = s ? G(s) : null, r = s ? Rt(s) : null, o = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;\n  switch (n) {\n    case k:\n      l = {\n        x: o,\n        y: t.y - e.height\n      };\n      break;\n    case W:\n      l = {\n        x: o,\n        y: t.y + t.height\n      };\n      break;\n    case B:\n      l = {\n        x: t.x + t.width,\n        y: a\n      };\n      break;\n    case P:\n      l = {\n        x: t.x - e.width,\n        y: a\n      };\n      break;\n    default:\n      l = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var u = n ? _i(n) : null;\n  if (u != null) {\n    var c = u === \"y\" ? \"height\" : \"width\";\n    switch (r) {\n      case Et:\n        l[u] = l[u] - (t[c] / 2 - e[c] / 2);\n        break;\n      case Lt:\n        l[u] = l[u] + (t[c] / 2 - e[c] / 2);\n        break;\n    }\n  }\n  return l;\n}\nfunction xt(i, t) {\n  t === void 0 && (t = {});\n  var e = t, s = e.placement, n = s === void 0 ? i.placement : s, r = e.strategy, o = r === void 0 ? i.strategy : r, a = e.boundary, l = a === void 0 ? Xs : a, u = e.rootBoundary, c = u === void 0 ? di : u, f = e.elementContext, v = f === void 0 ? Ct : f, g = e.altBoundary, O = g === void 0 ? !1 : g, T = e.padding, A = T === void 0 ? 0 : T, D = un(typeof A != \"number\" ? A : hn(A, Pt)), L = v === Ct ? Gs : Ct, m = i.rects.popper, p = i.elements[O ? L : v], _ = Or(vt(p) ? p : p.contextElement || ot(i.elements.popper), l, c, o), b = It(i.elements.reference), w = _n({\n    reference: b,\n    element: m,\n    strategy: \"absolute\",\n    placement: n\n  }), C = si(Object.assign({}, m, w)), y = v === Ct ? C : b, N = {\n    top: _.top - y.top + D.top,\n    bottom: y.bottom - _.bottom + D.bottom,\n    left: _.left - y.left + D.left,\n    right: y.right - _.right + D.right\n  }, S = i.modifiersData.offset;\n  if (v === Ct && S) {\n    var x = S[n];\n    Object.keys(N).forEach(function(I) {\n      var at = [B, W].indexOf(I) >= 0 ? 1 : -1, lt = [k, W].indexOf(I) >= 0 ? \"y\" : \"x\";\n      N[I] += x[lt] * at;\n    });\n  }\n  return N;\n}\nfunction Dr(i, t) {\n  t === void 0 && (t = {});\n  var e = t, s = e.placement, n = e.boundary, r = e.rootBoundary, o = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, u = l === void 0 ? ui : l, c = Rt(s), f = c ? a ? ei : ei.filter(function(O) {\n    return Rt(O) === c;\n  }) : Pt, v = f.filter(function(O) {\n    return u.indexOf(O) >= 0;\n  });\n  v.length === 0 && (v = f);\n  var g = v.reduce(function(O, T) {\n    return O[T] = xt(i, {\n      placement: T,\n      boundary: n,\n      rootBoundary: r,\n      padding: o\n    })[G(T)], O;\n  }, {});\n  return Object.keys(g).sort(function(O, T) {\n    return g[O] - g[T];\n  });\n}\nfunction Nr(i) {\n  if (G(i) === ve)\n    return [];\n  var t = ue(i);\n  return [Vi(i), t, Vi(t)];\n}\nfunction Sr(i) {\n  var t = i.state, e = i.options, s = i.name;\n  if (!t.modifiersData[s]._skip) {\n    for (var n = e.mainAxis, r = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !0 : o, l = e.fallbackPlacements, u = e.padding, c = e.boundary, f = e.rootBoundary, v = e.altBoundary, g = e.flipVariations, O = g === void 0 ? !0 : g, T = e.allowedAutoPlacements, A = t.options.placement, D = G(A), L = D === A, m = l || (L || !O ? [ue(A)] : Nr(A)), p = [A].concat(m).reduce(function(wt, et) {\n      return wt.concat(G(et) === ve ? Dr(t, {\n        placement: et,\n        boundary: c,\n        rootBoundary: f,\n        padding: u,\n        flipVariations: O,\n        allowedAutoPlacements: T\n      }) : et);\n    }, []), _ = t.rects.reference, b = t.rects.popper, w = /* @__PURE__ */ new Map(), C = !0, y = p[0], N = 0; N < p.length; N++) {\n      var S = p[N], x = G(S), I = Rt(S) === Et, at = [k, W].indexOf(x) >= 0, lt = at ? \"width\" : \"height\", H = xt(t, {\n        placement: S,\n        boundary: c,\n        rootBoundary: f,\n        altBoundary: v,\n        padding: u\n      }), Y = at ? I ? B : P : I ? W : k;\n      _[lt] > b[lt] && (Y = ue(Y));\n      var Zt = ue(Y), ct = [];\n      if (r && ct.push(H[x] <= 0), a && ct.push(H[Y] <= 0, H[Zt] <= 0), ct.every(function(wt) {\n        return wt;\n      })) {\n        y = S, C = !1;\n        break;\n      }\n      w.set(S, ct);\n    }\n    if (C)\n      for (var Jt = O ? 3 : 1, Ae = function(et) {\n        var Vt = p.find(function(ee) {\n          var dt = w.get(ee);\n          if (dt)\n            return dt.slice(0, et).every(function(Ce) {\n              return Ce;\n            });\n        });\n        if (Vt)\n          return y = Vt, \"break\";\n      }, Ht = Jt; Ht > 0; Ht--) {\n        var te = Ae(Ht);\n        if (te === \"break\")\n          break;\n      }\n    t.placement !== y && (t.modifiersData[s]._skip = !0, t.placement = y, t.reset = !0);\n  }\n}\nconst gn = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: Sr,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction Bi(i, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: i.top - t.height - e.y,\n    right: i.right - t.width + e.x,\n    bottom: i.bottom - t.height + e.y,\n    left: i.left - t.width - e.x\n  };\n}\nfunction ji(i) {\n  return [k, B, W, P].some(function(t) {\n    return i[t] >= 0;\n  });\n}\nfunction Lr(i) {\n  var t = i.state, e = i.name, s = t.rects.reference, n = t.rects.popper, r = t.modifiersData.preventOverflow, o = xt(t, {\n    elementContext: \"reference\"\n  }), a = xt(t, {\n    altBoundary: !0\n  }), l = Bi(o, s), u = Bi(a, n, r), c = ji(l), f = ji(u);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: l,\n    popperEscapeOffsets: u,\n    isReferenceHidden: c,\n    hasPopperEscaped: f\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": c,\n    \"data-popper-escaped\": f\n  });\n}\nconst mn = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: Lr\n};\nfunction $r(i, t, e) {\n  var s = G(i), n = [P, k].indexOf(s) >= 0 ? -1 : 1, r = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: i\n  })) : e, o = r[0], a = r[1];\n  return o = o || 0, a = (a || 0) * n, [P, B].indexOf(s) >= 0 ? {\n    x: a,\n    y: o\n  } : {\n    x: o,\n    y: a\n  };\n}\nfunction Ir(i) {\n  var t = i.state, e = i.options, s = i.name, n = e.offset, r = n === void 0 ? [0, 0] : n, o = ui.reduce(function(c, f) {\n    return c[f] = $r(f, t.rects, r), c;\n  }, {}), a = o[t.placement], l = a.x, u = a.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[s] = o;\n}\nconst En = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: Ir\n};\nfunction Rr(i) {\n  var t = i.state, e = i.name;\n  t.modifiersData[e] = _n({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst wi = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: Rr,\n  data: {}\n};\nfunction xr(i) {\n  return i === \"x\" ? \"y\" : \"x\";\n}\nfunction kr(i) {\n  var t = i.state, e = i.options, s = i.name, n = e.mainAxis, r = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !1 : o, l = e.boundary, u = e.rootBoundary, c = e.altBoundary, f = e.padding, v = e.tether, g = v === void 0 ? !0 : v, O = e.tetherOffset, T = O === void 0 ? 0 : O, A = xt(t, {\n    boundary: l,\n    rootBoundary: u,\n    padding: f,\n    altBoundary: c\n  }), D = G(t.placement), L = Rt(t.placement), m = !L, p = _i(D), _ = xr(p), b = t.modifiersData.popperOffsets, w = t.rects.reference, C = t.rects.popper, y = typeof T == \"function\" ? T(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : T, N = typeof y == \"number\" ? {\n    mainAxis: y,\n    altAxis: y\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, y), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, x = {\n    x: 0,\n    y: 0\n  };\n  if (b) {\n    if (r) {\n      var I, at = p === \"y\" ? k : P, lt = p === \"y\" ? W : B, H = p === \"y\" ? \"height\" : \"width\", Y = b[p], Zt = Y + A[at], ct = Y - A[lt], Jt = g ? -C[H] / 2 : 0, Ae = L === Et ? w[H] : C[H], Ht = L === Et ? -C[H] : -w[H], te = t.elements.arrow, wt = g && te ? pi(te) : {\n        width: 0,\n        height: 0\n      }, et = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : dn(), Vt = et[at], ee = et[lt], dt = zt(0, w[H], wt[H]), Ce = m ? w[H] / 2 - Jt - dt - Vt - N.mainAxis : Ae - dt - Vt - N.mainAxis, Vn = m ? -w[H] / 2 + Jt + dt + ee + N.mainAxis : Ht + dt + ee + N.mainAxis, Oe = t.elements.arrow && Gt(t.elements.arrow), Wn = Oe ? p === \"y\" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Oi = (I = S == null ? void 0 : S[p]) != null ? I : 0, Bn = Y + Ce - Oi - Wn, jn = Y + Vn - Oi, Di = zt(g ? Ee(Zt, Bn) : Zt, Y, g ? mt(ct, jn) : ct);\n      b[p] = Di, x[p] = Di - Y;\n    }\n    if (a) {\n      var Ni, Un = p === \"x\" ? k : P, Fn = p === \"x\" ? W : B, ut = b[_], ie = _ === \"y\" ? \"height\" : \"width\", Si = ut + A[Un], Li = ut - A[Fn], De = [k, P].indexOf(D) !== -1, $i = (Ni = S == null ? void 0 : S[_]) != null ? Ni : 0, Ii = De ? Si : ut - w[ie] - C[ie] - $i + N.altAxis, Ri = De ? ut + w[ie] + C[ie] - $i - N.altAxis : Li, xi = g && De ? hr(Ii, ut, Ri) : zt(g ? Ii : Si, ut, g ? Ri : Li);\n      b[_] = xi, x[_] = xi - ut;\n    }\n    t.modifiersData[s] = x;\n  }\n}\nconst vn = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: kr,\n  requiresIfExists: [\"offset\"]\n};\nfunction Pr(i) {\n  return {\n    scrollLeft: i.scrollLeft,\n    scrollTop: i.scrollTop\n  };\n}\nfunction Mr(i) {\n  return i === j(i) || !F(i) ? Ei(i) : Pr(i);\n}\nfunction Hr(i) {\n  var t = i.getBoundingClientRect(), e = $t(t.width) / i.offsetWidth || 1, s = $t(t.height) / i.offsetHeight || 1;\n  return e !== 1 || s !== 1;\n}\nfunction Vr(i, t, e) {\n  e === void 0 && (e = !1);\n  var s = F(t), n = F(t) && Hr(t), r = ot(t), o = It(i, n, e), a = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, l = {\n    x: 0,\n    y: 0\n  };\n  return (s || !s && !e) && ((Q(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  bi(r)) && (a = Mr(t)), F(t) ? (l = It(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : r && (l.x = vi(r))), {\n    x: o.left + a.scrollLeft - l.x,\n    y: o.top + a.scrollTop - l.y,\n    width: o.width,\n    height: o.height\n  };\n}\nfunction Wr(i) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), s = [];\n  i.forEach(function(r) {\n    t.set(r.name, r);\n  });\n  function n(r) {\n    e.add(r.name);\n    var o = [].concat(r.requires || [], r.requiresIfExists || []);\n    o.forEach(function(a) {\n      if (!e.has(a)) {\n        var l = t.get(a);\n        l && n(l);\n      }\n    }), s.push(r);\n  }\n  return i.forEach(function(r) {\n    e.has(r.name) || n(r);\n  }), s;\n}\nfunction Br(i) {\n  var t = Wr(i);\n  return an.reduce(function(e, s) {\n    return e.concat(t.filter(function(n) {\n      return n.phase === s;\n    }));\n  }, []);\n}\nfunction jr(i) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(i());\n      });\n    })), t;\n  };\n}\nfunction Ur(i) {\n  var t = i.reduce(function(e, s) {\n    var n = e[s.name];\n    return e[s.name] = n ? Object.assign({}, n, s, {\n      options: Object.assign({}, n.options, s.options),\n      data: Object.assign({}, n.data, s.data)\n    }) : s, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar Ui = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction Fi() {\n  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)\n    t[e] = arguments[e];\n  return !t.some(function(s) {\n    return !(s && typeof s.getBoundingClientRect == \"function\");\n  });\n}\nfunction we(i) {\n  i === void 0 && (i = {});\n  var t = i, e = t.defaultModifiers, s = e === void 0 ? [] : e, n = t.defaultOptions, r = n === void 0 ? Ui : n;\n  return function(a, l, u) {\n    u === void 0 && (u = r);\n    var c = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, Ui, r),\n      modifiersData: {},\n      elements: {\n        reference: a,\n        popper: l\n      },\n      attributes: {},\n      styles: {}\n    }, f = [], v = !1, g = {\n      state: c,\n      setOptions: function(D) {\n        var L = typeof D == \"function\" ? D(c.options) : D;\n        T(), c.options = Object.assign({}, r, c.options, L), c.scrollParents = {\n          reference: vt(a) ? qt(a) : a.contextElement ? qt(a.contextElement) : [],\n          popper: qt(l)\n        };\n        var m = Br(Ur([].concat(s, c.options.modifiers)));\n        return c.orderedModifiers = m.filter(function(p) {\n          return p.enabled;\n        }), O(), g.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!v) {\n          var D = c.elements, L = D.reference, m = D.popper;\n          if (Fi(L, m)) {\n            c.rects = {\n              reference: Vr(L, Gt(m), c.options.strategy === \"fixed\"),\n              popper: pi(m)\n            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(N) {\n              return c.modifiersData[N.name] = Object.assign({}, N.data);\n            });\n            for (var p = 0; p < c.orderedModifiers.length; p++) {\n              if (c.reset === !0) {\n                c.reset = !1, p = -1;\n                continue;\n              }\n              var _ = c.orderedModifiers[p], b = _.fn, w = _.options, C = w === void 0 ? {} : w, y = _.name;\n              typeof b == \"function\" && (c = b({\n                state: c,\n                options: C,\n                name: y,\n                instance: g\n              }) || c);\n            }\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: jr(function() {\n        return new Promise(function(A) {\n          g.forceUpdate(), A(c);\n        });\n      }),\n      destroy: function() {\n        T(), v = !0;\n      }\n    };\n    if (!Fi(a, l))\n      return g;\n    g.setOptions(u).then(function(A) {\n      !v && u.onFirstUpdate && u.onFirstUpdate(A);\n    });\n    function O() {\n      c.orderedModifiers.forEach(function(A) {\n        var D = A.name, L = A.options, m = L === void 0 ? {} : L, p = A.effect;\n        if (typeof p == \"function\") {\n          var _ = p({\n            state: c,\n            name: D,\n            instance: g,\n            options: m\n          }), b = function() {\n          };\n          f.push(_ || b);\n        }\n      });\n    }\n    function T() {\n      f.forEach(function(A) {\n        return A();\n      }), f = [];\n    }\n    return g;\n  };\n}\nvar Fr = /* @__PURE__ */ we(), Yr = [mi, wi, gi, fi], Kr = /* @__PURE__ */ we({\n  defaultModifiers: Yr\n}), zr = [mi, wi, gi, fi, En, gn, vn, fn, mn], Ti = /* @__PURE__ */ we({\n  defaultModifiers: zr\n});\nconst bn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  afterMain: sn,\n  afterRead: Js,\n  afterWrite: on,\n  applyStyles: fi,\n  arrow: fn,\n  auto: ve,\n  basePlacements: Pt,\n  beforeMain: tn,\n  beforeRead: Qs,\n  beforeWrite: nn,\n  bottom: W,\n  clippingParents: Xs,\n  computeStyles: gi,\n  createPopper: Ti,\n  createPopperBase: Fr,\n  createPopperLite: Kr,\n  detectOverflow: xt,\n  end: Lt,\n  eventListeners: mi,\n  flip: gn,\n  hide: mn,\n  left: P,\n  main: en,\n  modifierPhases: an,\n  offset: En,\n  placements: ui,\n  popper: Ct,\n  popperGenerator: we,\n  popperOffsets: wi,\n  preventOverflow: vn,\n  read: Zs,\n  reference: Gs,\n  right: B,\n  start: Et,\n  top: k,\n  variationPlacements: ei,\n  viewport: di,\n  write: rn\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Ie(i) {\n  return i === \"true\" ? !0 : i === \"false\" ? !1 : i === Number(i).toString() ? Number(i) : i === \"\" || i === \"null\" ? null : i;\n}\nfunction Re(i) {\n  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);\n}\nconst E = {\n  setDataAttribute(i, t, e) {\n    i.setAttribute(`data-twe-${Re(t)}`, e);\n  },\n  removeDataAttribute(i, t) {\n    i.removeAttribute(`data-twe-${Re(t)}`);\n  },\n  getDataAttributes(i) {\n    if (!i)\n      return {};\n    const t = {};\n    return Object.keys(i.dataset).filter((e) => e.startsWith(\"twe\")).forEach((e) => {\n      if (e.startsWith(\"tweClass\"))\n        return;\n      let s = e.replace(/^twe/, \"\");\n      s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Ie(i.dataset[e]);\n    }), t;\n  },\n  getDataClassAttributes(i) {\n    if (!i)\n      return {};\n    const t = {\n      ...i.dataset\n    };\n    return Object.keys(t).filter((e) => e.startsWith(\"tweClass\")).forEach((e) => {\n      let s = e.replace(/^tweClass/, \"\");\n      s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Ie(t[e]);\n    }), t;\n  },\n  getDataAttribute(i, t) {\n    return Ie(\n      i.getAttribute(`data-twe-${Re(t)}`)\n    );\n  },\n  offset(i) {\n    const t = i.getBoundingClientRect();\n    return {\n      top: t.top + document.body.scrollTop,\n      left: t.left + document.body.scrollLeft\n    };\n  },\n  position(i) {\n    return {\n      top: i.offsetTop,\n      left: i.offsetLeft\n    };\n  },\n  style(i, t) {\n    Object.assign(i.style, t);\n  },\n  toggleClass(i, t) {\n    i && xe(t).forEach((e) => {\n      i.classList.contains(e) ? i.classList.remove(e) : i.classList.add(e);\n    });\n  },\n  addClass(i, t) {\n    xe(t).forEach(\n      (e) => !i.classList.contains(e) && i.classList.add(e)\n    );\n  },\n  addStyle(i, t) {\n    Object.keys(t).forEach((e) => {\n      i.style[e] = t[e];\n    });\n  },\n  removeClass(i, t) {\n    xe(t).forEach(\n      (e) => i.classList.contains(e) && i.classList.remove(e)\n    );\n  },\n  hasClass(i, t) {\n    return i.classList.contains(t);\n  },\n  maxOffset(i) {\n    const t = i.getBoundingClientRect();\n    return {\n      top: t.top + Math.max(\n        document.body.scrollTop,\n        document.documentElement.scrollTop,\n        window.scrollY\n      ),\n      left: t.left + Math.max(\n        document.body.scrollLeft,\n        document.documentElement.scrollLeft,\n        window.scrollX\n      )\n    };\n  }\n};\nfunction xe(i) {\n  return typeof i == \"string\" ? i.split(\" \") : Array.isArray(i) ? i : !1;\n}\nconst qr = 3, h = {\n  closest(i, t) {\n    return i.closest(t);\n  },\n  matches(i, t) {\n    return i.matches(t);\n  },\n  find(i, t = document.documentElement) {\n    return [].concat(\n      ...Element.prototype.querySelectorAll.call(t, i)\n    );\n  },\n  findOne(i, t = document.documentElement) {\n    return Element.prototype.querySelector.call(t, i);\n  },\n  children(i, t) {\n    return [].concat(...i.children).filter((s) => s.matches(t));\n  },\n  parents(i, t) {\n    const e = [];\n    let s = i.parentNode;\n    for (; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== qr; )\n      this.matches(s, t) && e.push(s), s = s.parentNode;\n    return e;\n  },\n  prev(i, t) {\n    let e = i.previousElementSibling;\n    for (; e; ) {\n      if (e.matches(t))\n        return [e];\n      e = e.previousElementSibling;\n    }\n    return [];\n  },\n  next(i, t) {\n    let e = i.nextElementSibling;\n    for (; e; ) {\n      if (this.matches(e, t))\n        return [e];\n      e = e.nextElementSibling;\n    }\n    return [];\n  },\n  focusableChildren(i) {\n    const t = [\n      \"a\",\n      \"button\",\n      \"input\",\n      \"textarea\",\n      \"select\",\n      \"details\",\n      \"[tabindex]\",\n      '[contenteditable=\"true\"]'\n    ].map((e) => `${e}:not([tabindex^=\"-\"])`).join(\", \");\n    return this.find(t, i).filter(\n      (e) => !gt(e) && kt(e)\n    );\n  }\n}, ke = \"dropdown\", Xr = \"twe.dropdown\", bt = `.${Xr}`, yi = \".data-api\", he = \"Escape\", Yi = \"Space\", Ki = \"Tab\", ni = \"ArrowUp\", fe = \"ArrowDown\", Gr = 2, Qr = new RegExp(\n  `${ni}|${fe}|${he}`\n), Zr = `hide${bt}`, Jr = `hidden${bt}`, to = `show${bt}`, eo = `shown${bt}`, io = `click${bt}${yi}`, zi = `keydown${bt}${yi}`, so = `keyup${bt}${yi}`, it = \"show\", no = \"dropup\", ro = \"dropend\", oo = \"dropstart\", ao = \"[data-twe-navbar-ref]\", ne = \"[data-twe-dropdown-toggle-ref]\", Pe = \"[data-twe-dropdown-menu-ref]\", lo = \"[data-twe-navbar-nav-ref]\", co = \"[data-twe-dropdown-menu-ref] [data-twe-dropdown-item-ref]:not(.disabled):not(:disabled)\", uo = M() ? \"top-end\" : \"top-start\", ho = M() ? \"top-start\" : \"top-end\", fo = M() ? \"bottom-end\" : \"bottom-start\", po = M() ? \"bottom-start\" : \"bottom-end\", _o = M() ? \"left-start\" : \"right-start\", go = M() ? \"right-start\" : \"left-start\", mo = [{ opacity: \"0\" }, { opacity: \"1\" }], Eo = [{ opacity: \"1\" }, { opacity: \"0\" }], qi = {\n  iterations: 1,\n  easing: \"ease\",\n  fill: \"both\"\n}, vo = {\n  offset: [0, 2],\n  boundary: \"clippingParents\",\n  reference: \"toggle\",\n  display: \"dynamic\",\n  popperConfig: null,\n  autoClose: !0,\n  dropdownAnimation: \"on\",\n  animationDuration: 550\n}, bo = {\n  offset: \"(array|string|function)\",\n  boundary: \"(string|element)\",\n  reference: \"(string|element|object)\",\n  display: \"string\",\n  popperConfig: \"(null|object|function)\",\n  autoClose: \"(boolean|string)\",\n  dropdownAnimation: \"string\",\n  animationDuration: \"number\"\n};\nclass X extends tt {\n  constructor(t, e) {\n    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;\n    const s = window.matchMedia(\n      \"(prefers-reduced-motion: reduce)\"\n    ).matches;\n    this._animationCanPlay = this._config.dropdownAnimation === \"on\" && !s, this._didInit = !1, this._init();\n  }\n  // Getters\n  static get Default() {\n    return vo;\n  }\n  static get DefaultType() {\n    return bo;\n  }\n  static get NAME() {\n    return ke;\n  }\n  // Public\n  toggle() {\n    return this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (gt(this._element) || this._isShown(this._menu))\n      return;\n    const t = {\n      relatedTarget: this._element\n    };\n    if (d.trigger(\n      this._element,\n      to,\n      t\n    ).defaultPrevented)\n      return;\n    const s = X.getParentFromElement(this._element);\n    this._inNavbar ? E.setDataAttribute(this._menu, \"popper\", \"none\") : this._createPopper(s), \"ontouchstart\" in document.documentElement && !s.closest(lo) && [].concat(...document.body.children).forEach((n) => d.on(n, \"mouseover\", me)), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.setAttribute(`data-twe-dropdown-${it}`, \"\"), this._animationCanPlay && this._menu.animate(mo, {\n      ...qi,\n      duration: this._config.animationDuration\n    }), this._element.setAttribute(`data-twe-dropdown-${it}`, \"\"), setTimeout(\n      () => {\n        d.trigger(this._element, eo, t);\n      },\n      this._animationCanPlay ? this._config.animationDuration : 0\n    );\n  }\n  hide() {\n    if (gt(this._element) || !this._isShown(this._menu))\n      return;\n    const t = {\n      relatedTarget: this._element\n    };\n    this._completeHide(t);\n  }\n  dispose() {\n    this._popper && this._popper.destroy(), super.dispose();\n  }\n  update() {\n    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n  }\n  // Private\n  _init() {\n    this._didInit || (d.on(\n      document,\n      zi,\n      ne,\n      X.dataApiKeydownHandler\n    ), d.on(\n      document,\n      zi,\n      Pe,\n      X.dataApiKeydownHandler\n    ), d.on(document, io, X.clearMenus), d.on(document, so, X.clearMenus), this._didInit = !0);\n  }\n  _completeHide(t) {\n    this._fadeOutAnimate && this._fadeOutAnimate.playState === \"running\" || d.trigger(\n      this._element,\n      Zr,\n      t\n    ).defaultPrevented || (\"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((s) => d.off(s, \"mouseover\", me)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(Eo, {\n      ...qi,\n      duration: this._config.animationDuration\n    })), setTimeout(\n      () => {\n        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-twe-dropdown-${it}`), this._element.removeAttribute(`data-twe-dropdown-${it}`), this._element.setAttribute(\"aria-expanded\", \"false\"), E.removeDataAttribute(this._menu, \"popper\"), d.trigger(this._element, Jr, t);\n      },\n      this._animationCanPlay ? this._config.animationDuration : 0\n    ));\n  }\n  _getConfig(t) {\n    if (t = {\n      ...this.constructor.Default,\n      ...E.getDataAttributes(this._element),\n      ...t\n    }, R(ke, t, this.constructor.DefaultType), typeof t.reference == \"object\" && !St(t.reference) && typeof t.reference.getBoundingClientRect != \"function\")\n      throw new TypeError(\n        `${ke.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`\n      );\n    return t;\n  }\n  _createPopper(t) {\n    if (typeof bn > \"u\")\n      throw new TypeError(\n        \"Bootstrap's dropdowns require Popper (https://popper.js.org)\"\n      );\n    let e = this._element;\n    this._config.reference === \"parent\" ? e = t : St(this._config.reference) ? e = rt(this._config.reference) : typeof this._config.reference == \"object\" && (e = this._config.reference);\n    const s = this._getPopperConfig(), n = s.modifiers.find(\n      (r) => r.name === \"applyStyles\" && r.enabled === !1\n    );\n    this._popper = Ti(\n      e,\n      this._menu,\n      s\n    ), n && E.setDataAttribute(this._menu, \"popper\", \"static\");\n  }\n  _isShown(t = this._element) {\n    return t.dataset[`tweDropdown${it.charAt(0).toUpperCase() + it.slice(1)}`] === \"\";\n  }\n  _getMenuElement() {\n    return h.next(this._element, Pe)[0];\n  }\n  _getPlacement() {\n    const t = this._element.parentNode;\n    if (t.dataset.tweDropdownPosition === ro)\n      return _o;\n    if (t.dataset.tweDropdownPosition === oo)\n      return go;\n    const e = t.dataset.tweDropdownAlignment === \"end\";\n    return t.dataset.tweDropdownPosition === no ? e ? ho : uo : e ? po : fo;\n  }\n  _detectNavbar() {\n    return this._element.closest(ao) !== null;\n  }\n  _getOffset() {\n    const { offset: t } = this._config;\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\n  }\n  _getPopperConfig() {\n    const t = {\n      placement: this._getPlacement(),\n      modifiers: [\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }\n      ]\n    };\n    return this._config.display === \"static\" && (t.modifiers = [\n      {\n        name: \"applyStyles\",\n        enabled: !1\n      }\n    ]), {\n      ...t,\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(t) : this._config.popperConfig\n    };\n  }\n  _selectMenuItem({ key: t, target: e }) {\n    const s = h.find(\n      co,\n      this._menu\n    ).filter(kt);\n    s.length && Bs(\n      s,\n      e,\n      t === fe,\n      !s.includes(e)\n    ).focus();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = X.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n  static clearMenus(t) {\n    if (t && (t.button === Gr || t.type === \"keyup\" && t.key !== Ki))\n      return;\n    const e = h.find(ne);\n    for (let s = 0, n = e.length; s < n; s++) {\n      const r = X.getInstance(e[s]);\n      if (!r || r._config.autoClose === !1 || !r._isShown())\n        continue;\n      const o = {\n        relatedTarget: r._element\n      };\n      if (t) {\n        const a = t.composedPath(), l = a.includes(r._menu);\n        if (a.includes(r._element) || r._config.autoClose === \"inside\" && !l || r._config.autoClose === \"outside\" && l || r._menu.contains(t.target) && (t.type === \"keyup\" && t.key === Ki || /input|select|option|textarea|form/i.test(t.target.tagName)))\n          continue;\n        t.type === \"click\" && (o.clickEvent = t);\n      }\n      r._completeHide(o);\n    }\n  }\n  static getParentFromElement(t) {\n    return nt(t) || t.parentNode;\n  }\n  static dataApiKeydownHandler(t) {\n    if (/input|textarea/i.test(t.target.tagName) ? t.key === Yi || t.key !== he && (t.key !== fe && t.key !== ni || t.target.closest(Pe)) : !Qr.test(t.key))\n      return;\n    const e = this.dataset[`tweDropdown${it.charAt(0).toUpperCase() + it.slice(1)}`] === \"\";\n    if (!e && t.key === he || (t.preventDefault(), t.stopPropagation(), gt(this)))\n      return;\n    const s = this.matches(ne) ? this : h.prev(this, ne)[0], n = X.getOrCreateInstance(s);\n    if (t.key === he) {\n      n.hide();\n      return;\n    }\n    if (t.key === ni || t.key === fe) {\n      e || n.show(), n._selectMenuItem(t);\n      return;\n    }\n    (!e || t.key === Yi) && X.clearMenus();\n  }\n}\nconst Me = \"collapse\", wn = \"twe.collapse\", Te = `.${wn}`, Xi = {\n  toggle: !0,\n  parent: null\n}, wo = {\n  toggle: \"boolean\",\n  parent: \"(null|element)\"\n}, To = `show${Te}`, yo = `shown${Te}`, Ao = `hide${Te}`, Co = `hidden${Te}`, He = \"data-twe-collapse-show\", Gi = \"data-twe-collapse-collapsed\", re = \"data-twe-collapse-collapsing\", Oo = \"data-twe-collapse-horizontal\", Nt = \"data-twe-collapse-item\", Qi = `:scope [${Nt}] [${Nt}]`, Do = \"width\", No = \"height\", So = \"[data-twe-collapse-item][data-twe-collapse-show], [data-twe-collapse-item][data-twe-collapse-collapsing]\", Zi = \"[data-twe-collapse-init]\", Lo = {\n  visible: \"!visible\",\n  hidden: \"hidden\",\n  baseTransition: \"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n  collapsing: \"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n  collapsingHorizontal: \"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\"\n}, $o = {\n  visible: \"string\",\n  hidden: \"string\",\n  baseTransition: \"string\",\n  collapsing: \"string\",\n  collapsingHorizontal: \"string\"\n};\nclass pe extends tt {\n  constructor(t, e, s) {\n    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._triggerArray = [];\n    const n = h.find(Zi);\n    for (let r = 0, o = n.length; r < o; r++) {\n      const a = n[r], l = ci(a), u = h.find(l).filter(\n        (c) => c === this._element\n      );\n      l !== null && u.length && (this._selector = l, this._triggerArray.push(a));\n    }\n    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\n  }\n  // Getters\n  static get Default() {\n    return Xi;\n  }\n  static get NAME() {\n    return Me;\n  }\n  // Public\n  toggle() {\n    this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (this._isTransitioning || this._isShown())\n      return;\n    let t = [], e;\n    if (this._config.parent) {\n      const c = h.find(\n        Qi,\n        this._config.parent\n      );\n      t = h.find(\n        So,\n        this._config.parent\n      ).filter((f) => !c.includes(f));\n    }\n    const s = h.findOne(this._selector);\n    if (t.length) {\n      const c = t.find((f) => s !== f);\n      if (e = c ? pe.getInstance(c) : null, e && e._isTransitioning)\n        return;\n    }\n    if (d.trigger(this._element, To).defaultPrevented)\n      return;\n    t.forEach((c) => {\n      s !== c && pe.getOrCreateInstance(c, { toggle: !1 }).hide(), e || V.setData(c, wn, null);\n    });\n    const r = this._getDimension(), o = r === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n    E.removeClass(this._element, this._classes.visible), E.removeClass(this._element, this._classes.hidden), E.addClass(this._element, o), this._element.removeAttribute(Nt), this._element.setAttribute(re, \"\"), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\n    const a = () => {\n      this._isTransitioning = !1, E.removeClass(this._element, this._classes.hidden), E.removeClass(this._element, o), E.addClass(this._element, this._classes.visible), this._element.removeAttribute(re), this._element.setAttribute(Nt, \"\"), this._element.setAttribute(He, \"\"), this._element.style[r] = \"\", d.trigger(this._element, yo);\n    }, u = `scroll${r[0].toUpperCase() + r.slice(1)}`;\n    this._queueCallback(a, this._element, !0), this._element.style[r] = `${this._element[u]}px`;\n  }\n  hide() {\n    if (this._isTransitioning || !this._isShown() || d.trigger(this._element, Ao).defaultPrevented)\n      return;\n    const e = this._getDimension(), s = e === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Xt(this._element), E.addClass(this._element, s), E.removeClass(this._element, this._classes.visible), E.removeClass(this._element, this._classes.hidden), this._element.setAttribute(re, \"\"), this._element.removeAttribute(Nt), this._element.removeAttribute(He);\n    const n = this._triggerArray.length;\n    for (let o = 0; o < n; o++) {\n      const a = this._triggerArray[o], l = nt(a);\n      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);\n    }\n    this._isTransitioning = !0;\n    const r = () => {\n      this._isTransitioning = !1, E.removeClass(this._element, s), E.addClass(this._element, this._classes.visible), E.addClass(this._element, this._classes.hidden), this._element.removeAttribute(re), this._element.setAttribute(Nt, \"\"), d.trigger(this._element, Co);\n    };\n    this._element.style[e] = \"\", this._queueCallback(r, this._element, !0);\n  }\n  _isShown(t = this._element) {\n    return t.hasAttribute(He);\n  }\n  // Private\n  _getConfig(t) {\n    return t = {\n      ...Xi,\n      ...E.getDataAttributes(this._element),\n      ...t\n    }, t.toggle = !!t.toggle, t.parent = rt(t.parent), R(Me, t, wo), t;\n  }\n  _getClasses(t) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...Lo,\n      ...e,\n      ...t\n    }, R(Me, t, $o), t;\n  }\n  _getDimension() {\n    return this._element.hasAttribute(Oo) ? Do : No;\n  }\n  _initializeChildren() {\n    if (!this._config.parent)\n      return;\n    const t = h.find(\n      Qi,\n      this._config.parent\n    );\n    h.find(Zi, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {\n      const s = nt(e);\n      s && this._addAriaAndCollapsedClass([e], this._isShown(s));\n    });\n  }\n  _addAriaAndCollapsedClass(t, e) {\n    t.length && t.forEach((s) => {\n      e ? s.removeAttribute(Gi) : s.setAttribute(`${Gi}`, \"\"), s.setAttribute(\"aria-expanded\", e);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = {};\n      typeof t == \"string\" && /show|hide/.test(t) && (e.toggle = !1);\n      const s = pe.getOrCreateInstance(this, e);\n      if (typeof t == \"string\") {\n        if (typeof s[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        s[t]();\n      }\n    });\n  }\n}\nconst Ji = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", ts = \".sticky-top\";\nclass ri {\n  constructor() {\n    this._element = document.body;\n  }\n  getWidth() {\n    const t = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - t);\n  }\n  hide() {\n    const t = this.getWidth();\n    this._disableOverFlow(), this._setElementAttributes(\n      this._element,\n      \"paddingRight\",\n      (e) => e + t\n    ), this._setElementAttributes(\n      Ji,\n      \"paddingRight\",\n      (e) => e + t\n    ), this._setElementAttributes(\n      ts,\n      \"marginRight\",\n      (e) => e - t\n    );\n  }\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, \"overflow\"), this._element.style.overflow = \"hidden\";\n  }\n  _setElementAttributes(t, e, s) {\n    const n = this.getWidth(), r = (o) => {\n      if (o !== this._element && window.innerWidth > o.clientWidth + n)\n        return;\n      this._saveInitialAttribute(o, e);\n      const a = window.getComputedStyle(o)[e];\n      o.style[e] = `${s(\n        Number.parseFloat(a)\n      )}px`;\n    };\n    this._applyManipulationCallback(t, r);\n  }\n  reset() {\n    this._resetElementAttributes(this._element, \"overflow\"), this._resetElementAttributes(this._element, \"paddingRight\"), this._resetElementAttributes(Ji, \"paddingRight\"), this._resetElementAttributes(ts, \"marginRight\");\n  }\n  _saveInitialAttribute(t, e) {\n    const s = t.style[e];\n    s && E.setDataAttribute(t, e, s);\n  }\n  _resetElementAttributes(t, e) {\n    const s = (n) => {\n      const r = E.getDataAttribute(n, e);\n      typeof r > \"u\" ? n.style.removeProperty(e) : (E.removeDataAttribute(n, e), n.style[e] = r);\n    };\n    this._applyManipulationCallback(t, s);\n  }\n  _applyManipulationCallback(t, e) {\n    St(t) ? e(t) : h.find(t, this._element).forEach(e);\n  }\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n}\nconst Io = {\n  isVisible: !0,\n  // if false, we use the backdrop helper without adding any element to the dom\n  isAnimated: !1,\n  rootElement: \"body\",\n  // give the choice to place backdrop under different elements\n  clickCallback: null,\n  backdropClasses: null\n}, Ro = {\n  isVisible: \"boolean\",\n  isAnimated: \"boolean\",\n  rootElement: \"(element|string)\",\n  clickCallback: \"(function|null)\",\n  backdropClasses: \"(array|string|null)\"\n}, Tn = \"backdrop\", es = `mousedown.twe.${Tn}`;\nclass yn {\n  constructor(t) {\n    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\n  }\n  show(t) {\n    if (!this._config.isVisible) {\n      _t(t);\n      return;\n    }\n    this._append(), this._config.isAnimated && Xt(this._getElement());\n    const e = this._config.backdropClasses || [\n      \"opacity-50\",\n      \"transition-all\",\n      \"duration-300\",\n      \"ease-in-out\",\n      \"fixed\",\n      \"top-0\",\n      \"left-0\",\n      \"z-[1040]\",\n      \"bg-black\",\n      \"w-screen\",\n      \"h-screen\"\n    ];\n    E.removeClass(this._getElement(), \"opacity-0\"), E.addClass(this._getElement(), e), this._element.setAttribute(\"data-twe-backdrop-show\", \"\"), this._emulateAnimation(() => {\n      _t(t);\n    });\n  }\n  hide(t) {\n    if (!this._config.isVisible) {\n      _t(t);\n      return;\n    }\n    this._element.removeAttribute(\"data-twe-backdrop-show\"), this._getElement().classList.add(\"opacity-0\"), this._getElement().classList.remove(\"opacity-50\"), this._emulateAnimation(() => {\n      this.dispose(), _t(t);\n    });\n  }\n  update(t = {}) {\n    this._config = this._getConfig({ ...this._config, ...t });\n  }\n  // Private\n  _getElement() {\n    if (!this._element) {\n      const t = document.createElement(\"div\");\n      this._element = t;\n    }\n    return this._element;\n  }\n  _getConfig(t) {\n    return t = {\n      ...Io,\n      ...typeof t == \"object\" ? t : {}\n    }, t.rootElement = rt(t.rootElement), R(Tn, t, Ro), t;\n  }\n  _append() {\n    this._isAppended || (this._config.rootElement.append(this._getElement()), d.on(this._getElement(), es, () => {\n      _t(this._config.clickCallback);\n    }), this._isAppended = !0);\n  }\n  dispose() {\n    this._isAppended && (d.off(this._element, es), this._element.remove(), this._isAppended = !1);\n  }\n  _emulateAnimation(t) {\n    Ws(\n      t,\n      this._getElement(),\n      this._config.isAnimated\n    );\n  }\n}\nclass An {\n  constructor(t, e = {}, s) {\n    this._element = t, this._toggler = s, this._event = e.event || \"blur\", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {\n      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());\n    };\n  }\n  trap() {\n    this._setElements(), this._init(), this._setFocusTrap();\n  }\n  disable() {\n    this._focusableElements.forEach((t) => {\n      t.removeEventListener(this._event, this.handler);\n    }), this._toggler && this._toggler.focus();\n  }\n  update() {\n    this._setElements(), this._setFocusTrap();\n  }\n  _init() {\n    const t = (e) => {\n      !this._firstElement || e.key !== \"Tab\" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener(\"keydown\", t));\n    };\n    window.addEventListener(\"keydown\", t);\n  }\n  _filterVisible(t) {\n    return t.filter((e) => {\n      if (!kt(e))\n        return !1;\n      const s = h.parents(e, \"*\");\n      for (let n = 0; n < s.length; n++) {\n        const r = window.getComputedStyle(s[n]);\n        if (r && (r.display === \"none\" || r.visibility === \"hidden\"))\n          return !1;\n      }\n      return !0;\n    });\n  }\n  _setElements() {\n    const t = h.find(this._selector, this._element);\n    this._focusableElements = t.filter((e) => {\n      const s = e.getAttribute(\"data-twe-disabled\") === \"true\" || e.hasAttribute(\"disabled\");\n      return e.disabled || s ? null : e;\n    }), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];\n  }\n  _setFocusTrap() {\n    this._focusableElements.forEach((t, e) => {\n      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);\n    });\n  }\n}\nlet is = [];\nconst Cn = (i, t = \"hide\") => {\n  const e = `click.dismiss${i.EVENT_KEY}`, s = i.NAME;\n  is.includes(s) || (is.push(s), d.on(\n    document,\n    e,\n    `[data-twe-${s}-dismiss]`,\n    function(n) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && n.preventDefault(), gt(this))\n        return;\n      const r = nt(this) || this.closest(`.${s}`) || this.closest(`[data-twe-${s}-init]`);\n      if (!r)\n        return;\n      i.getOrCreateInstance(r)[t]();\n    }\n  ));\n}, xo = 9, ss = \"offcanvas\", ko = \"twe.offcanvas\", Mt = `.${ko}`, Po = \".data-api\", Mo = `load${Mt}${Po}`, Ho = \"Escape\", ns = {\n  backdrop: !0,\n  keyboard: !0,\n  scroll: !1\n}, Vo = {\n  backdrop: \"boolean\",\n  keyboard: \"boolean\",\n  scroll: \"boolean\"\n}, rs = \"show\", Wo = \"[data-twe-offcanvas-init][data-twe-offcanvas-show]\", Bo = `show${Mt}`, jo = `shown${Mt}`, Uo = `hide${Mt}`, Fo = `hidden${Mt}`, Yo = `keydown.dismiss${Mt}`;\nclass _e extends tt {\n  constructor(t, e) {\n    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return ss;\n  }\n  static get Default() {\n    return ns;\n  }\n  // Public\n  toggle(t) {\n    return this._isShown ? this.hide() : this.show(t);\n  }\n  show(t) {\n    if (this._isShown || d.trigger(this._element, Bo, {\n      relatedTarget: t\n    }).defaultPrevented)\n      return;\n    this._isShown = !0, this._element.style.visibility = \"visible\", this._backdrop.show(), this._config.scroll || new ri().hide(), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`data-twe-offcanvas-${rs}`, \"\");\n    const s = () => {\n      this._config.scroll || this._focustrap.trap(), d.trigger(this._element, jo, { relatedTarget: t });\n    };\n    this._queueCallback(s, this._element, !0);\n  }\n  hide() {\n    if (!this._isShown || d.trigger(this._element, Uo).defaultPrevented)\n      return;\n    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-twe-offcanvas-${rs}`), this._backdrop.hide();\n    const e = () => {\n      this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._element.style.visibility = \"hidden\", this._config.scroll || new ri().reset(), d.trigger(this._element, Fo);\n    };\n    this._queueCallback(e, this._element, !0);\n  }\n  dispose() {\n    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n  }\n  // Private\n  _init() {\n    this._didInit || (d.on(\n      window,\n      Mo,\n      () => h.find(Wo).forEach(\n        (t) => _e.getOrCreateInstance(t).show()\n      )\n    ), this._didInit = !0, Cn(_e));\n  }\n  _getConfig(t) {\n    return t = {\n      ...ns,\n      ...E.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, R(ss, t, Vo), t;\n  }\n  _initializeBackDrop() {\n    return new yn({\n      isVisible: this._config.backdrop,\n      isAnimated: !0,\n      rootElement: this._element.parentNode,\n      clickCallback: () => this.hide()\n    });\n  }\n  _initializeFocusTrap() {\n    return new An(this._element, {\n      event: \"keydown\",\n      condition: (t) => t.keyCode === xo,\n      onlyVisible: !0\n    });\n  }\n  _addEventListeners() {\n    d.on(this._element, Yo, (t) => {\n      this._config.keyboard && t.key === Ho && this.hide();\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = _e.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Ve = \"carousel\", Ko = \"twe.carousel\", U = `.${Ko}`, On = \".data-api\", zo = \"ArrowLeft\", qo = \"ArrowRight\", Xo = 500, Go = 40, os = {\n  interval: 5e3,\n  keyboard: !0,\n  ride: !1,\n  pause: \"hover\",\n  wrap: !0,\n  touch: !0\n}, Qo = {\n  interval: \"(number|boolean)\",\n  keyboard: \"boolean\",\n  ride: \"(boolean|string)\",\n  pause: \"(string|boolean)\",\n  wrap: \"boolean\",\n  touch: \"boolean\"\n}, Zo = {\n  pointer: \"touch-pan-y\",\n  block: \"!block\",\n  visible: \"data-[twe-carousel-fade]:opacity-100 data-[twe-carousel-fade]:z-[1]\",\n  invisible: \"data-[twe-carousel-fade]:z-0 data-[twe-carousel-fade]:opacity-0 data-[twe-carousel-fade]:duration-[600ms] data-[twe-carousel-fade]:delay-600\",\n  slideRight: \"translate-x-full\",\n  slideLeft: \"-translate-x-full\"\n}, Jo = {\n  pointer: \"string\",\n  block: \"string\",\n  visible: \"string\",\n  invisible: \"string\",\n  slideRight: \"string\",\n  slideLeft: \"string\"\n}, ht = \"next\", ft = \"prev\", pt = \"left\", Yt = \"right\", ta = {\n  [zo]: Yt,\n  [qo]: pt\n}, ea = `slide${U}`, We = `slid${U}`, ia = `keydown${U}`, sa = `mouseenter${U}`, na = `mouseleave${U}`, ra = `touchstart${U}`, oa = `touchmove${U}`, aa = `touchend${U}`, la = `pointerdown${U}`, ca = `pointerup${U}`, da = `dragstart${U}`, as = `load${U}${On}`, ls = `click${U}${On}`, Wt = \"data-twe-carousel-active\", ua = \"data-twe-carousel-item-end\", Be = \"data-twe-carousel-item-start\", ha = \"data-twe-carousel-item-next\", fa = \"data-twe-carousel-item-prev\", pa = \"data-twe-carousel-pointer-event\", _a = \"[data-twe-carousel-init]\", Dn = \"[data-twe-carousel-active]\", Ai = \"[data-twe-carousel-item]\", Tt = `${Dn}${Ai}`, ga = `${Ai} img`, ma = \"[data-twe-carousel-item-next], [data-twe-carousel-item-prev]\", Ea = \"[data-twe-carousel-indicators]\", va = \"[data-twe-target]\", cs = \"[data-twe-slide], [data-twe-slide-to]\", ba = \"touch\", wa = \"pen\";\nclass Z extends tt {\n  constructor(t, e, s) {\n    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._indicatorsElement = h.findOne(\n      Ea,\n      this._element\n    ), this._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === \"carousel\" && this.cycle();\n  }\n  // Getters\n  static get Default() {\n    return os;\n  }\n  static get NAME() {\n    return Ve;\n  }\n  // Public\n  next() {\n    this._slide(ht);\n  }\n  nextWhenVisible() {\n    !document.hidden && kt(this._element) && this.next();\n  }\n  prev() {\n    this._slide(ft);\n  }\n  pause(t) {\n    t || (this._isPaused = !0), h.findOne(ma, this._element) && (Ps(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n  }\n  cycle(t) {\n    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(\n      (document.visibilityState ? this.nextWhenVisible : this.next).bind(\n        this\n      ),\n      this._config.interval\n    ));\n  }\n  to(t) {\n    this._activeElement = h.findOne(\n      Tt,\n      this._element\n    );\n    const e = this._getItemIndex(this._activeElement);\n    if (t > this._items.length - 1 || t < 0)\n      return;\n    if (this._isSliding) {\n      d.one(this._element, We, () => this.to(t));\n      return;\n    }\n    if (e === t) {\n      this.pause(), this.cycle();\n      return;\n    }\n    const s = t > e ? ht : ft;\n    this._slide(s, this._items[t]);\n  }\n  dispose() {\n    d.off(\n      document,\n      ls,\n      cs,\n      Z.dataApiClickHandler\n    ), d.off(window, as), super.dispose();\n  }\n  // Private\n  _init() {\n    this._didInit || (d.on(\n      document,\n      ls,\n      cs,\n      Z.dataApiClickHandler\n    ), d.on(window, as, () => {\n      const t = h.find(_a);\n      for (let e = 0, s = t.length; e < s; e++)\n        Z.carouselInterface(\n          t[e],\n          Z.getInstance(t[e])\n        );\n    }), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...os,\n      ...E.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, R(Ve, t, Qo), t;\n  }\n  _getClasses(t) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...Zo,\n      ...e,\n      ...t\n    }, R(Ve, t, Jo), t;\n  }\n  _enableCycle() {\n    if (this._config.ride) {\n      if (this._isSliding) {\n        d.one(this._element, We, () => this.cycle());\n        return;\n      }\n      this.cycle();\n    }\n  }\n  _applyInitialClasses() {\n    const t = h.findOne(\n      Tt,\n      this._element\n    );\n    t.classList.add(\n      this._classes.block,\n      ...this._classes.visible.split(\" \")\n    ), this._setActiveIndicatorElement(t);\n  }\n  _handleSwipe() {\n    const t = Math.abs(this.touchDeltaX);\n    if (t <= Go)\n      return;\n    const e = t / this.touchDeltaX;\n    this.touchDeltaX = 0, e && this._slide(e > 0 ? Yt : pt);\n  }\n  _setActiveElementClass() {\n    this._activeElement = h.findOne(\n      Tt,\n      this._element\n    ), E.addClass(this._activeElement, \"hidden\");\n  }\n  _addEventListeners() {\n    this._config.keyboard && d.on(\n      this._element,\n      ia,\n      (t) => this._keydown(t)\n    ), this._config.pause === \"hover\" && (d.on(\n      this._element,\n      sa,\n      (t) => this.pause(t)\n    ), d.on(\n      this._element,\n      na,\n      (t) => this._enableCycle(t)\n    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();\n  }\n  _addTouchEventListeners() {\n    const t = (r) => this._pointerEvent && (r.pointerType === wa || r.pointerType === ba), e = (r) => {\n      t(r) ? this.touchStartX = r.clientX : this._pointerEvent || (this.touchStartX = r.touches[0].clientX);\n    }, s = (r) => {\n      this.touchDeltaX = r.touches && r.touches.length > 1 ? 0 : r.touches[0].clientX - this.touchStartX;\n    }, n = (r) => {\n      t(r) && (this.touchDeltaX = r.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === \"hover\" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(\n        (o) => this._enableCycle(o),\n        Xo + this._config.interval\n      ));\n    };\n    h.find(ga, this._element).forEach(\n      (r) => {\n        d.on(\n          r,\n          da,\n          (o) => o.preventDefault()\n        );\n      }\n    ), this._pointerEvent ? (d.on(\n      this._element,\n      la,\n      (r) => e(r)\n    ), d.on(this._element, ca, (r) => n(r)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${pa}`, \"\")) : (d.on(this._element, ra, (r) => e(r)), d.on(this._element, oa, (r) => s(r)), d.on(this._element, aa, (r) => n(r)));\n  }\n  _keydown(t) {\n    if (/input|textarea/i.test(t.target.tagName))\n      return;\n    const e = ta[t.key];\n    e && (t.preventDefault(), this._slide(e));\n  }\n  _getItemIndex(t) {\n    return this._items = t && t.parentNode ? h.find(Ai, t.parentNode) : [], this._items.indexOf(t);\n  }\n  _getItemByOrder(t, e) {\n    const s = t === ht;\n    return Bs(\n      this._items,\n      e,\n      s,\n      this._config.wrap\n    );\n  }\n  _triggerSlideEvent(t, e) {\n    const s = this._getItemIndex(t), n = this._getItemIndex(\n      h.findOne(Tt, this._element)\n    );\n    return d.trigger(this._element, ea, {\n      relatedTarget: t,\n      direction: e,\n      from: n,\n      to: s\n    });\n  }\n  _setActiveIndicatorElement(t) {\n    if (this._indicatorsElement) {\n      const e = h.findOne(\n        Dn,\n        this._indicatorsElement\n      );\n      e.removeAttribute(Wt), e.removeAttribute(\"aria-current\"), e.classList.remove(\"!opacity-100\");\n      const s = h.find(\n        va,\n        this._indicatorsElement\n      );\n      for (let n = 0; n < s.length; n++)\n        if (Number.parseInt(\n          s[n].getAttribute(\"data-twe-slide-to\"),\n          10\n        ) === this._getItemIndex(t)) {\n          s[n].setAttribute(`${Wt}`, \"\"), s[n].setAttribute(\"aria-current\", \"true\"), s[n].classList.add(\"!opacity-100\");\n          break;\n        }\n    }\n  }\n  _updateInterval() {\n    const t = this._activeElement || h.findOne(Tt, this._element);\n    if (!t)\n      return;\n    const e = Number.parseInt(\n      t.getAttribute(\"data-twe-interval\"),\n      10\n    );\n    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n  }\n  _slide(t, e) {\n    const s = this._directionToOrder(t), n = h.findOne(\n      Tt,\n      this._element\n    ), r = this._getItemIndex(n), o = e || this._getItemByOrder(s, n), a = this._getItemIndex(o), l = !!this._interval, u = s === ht, c = u ? Be : ua, f = u ? ha : fa, v = this._orderToDirection(s), g = c === Be ? this._classes.slideLeft : this._classes.slideRight, O = c !== Be ? this._classes.slideLeft : this._classes.slideRight;\n    if (o && o.hasAttribute(Wt)) {\n      this._isSliding = !1;\n      return;\n    }\n    if (this._isSliding || this._triggerSlideEvent(o, v).defaultPrevented || !n || !o)\n      return;\n    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o;\n    const A = () => {\n      d.trigger(this._element, We, {\n        relatedTarget: o,\n        direction: v,\n        from: r,\n        to: a\n      });\n    };\n    o.setAttribute(`${f}`, \"\"), o.classList.add(this._classes.block, O), Xt(o), n.setAttribute(`${c}`, \"\"), n.classList.add(\n      g,\n      ...this._classes.invisible.split(\" \")\n    ), n.classList.remove(...this._classes.visible.split(\" \")), o.setAttribute(`${c}`, \"\"), o.classList.add(...this._classes.visible.split(\" \")), o.classList.remove(\n      this._classes.slideRight,\n      this._classes.slideLeft\n    );\n    const D = () => {\n      o.removeAttribute(c), o.removeAttribute(f), o.setAttribute(`${Wt}`, \"\"), n.removeAttribute(Wt), n.classList.remove(\n        g,\n        ...this._classes.invisible.split(\" \"),\n        this._classes.block\n      ), n.removeAttribute(f), n.removeAttribute(c), this._isSliding = !1, setTimeout(A, 0);\n    };\n    this._queueCallback(D, n, !0), (l || this._config.ride === !0) && this.cycle();\n  }\n  _directionToOrder(t) {\n    return [Yt, pt].includes(t) ? M() ? t === pt ? ft : ht : t === pt ? ht : ft : t;\n  }\n  _orderToDirection(t) {\n    return [ht, ft].includes(t) ? M() ? t === ft ? pt : Yt : t === ft ? Yt : pt : t;\n  }\n  // Static\n  static carouselInterface(t, e) {\n    const s = Z.getOrCreateInstance(t, e);\n    let { _config: n } = s;\n    typeof e == \"object\" && (n = {\n      ...n,\n      ...e\n    });\n    const r = typeof e == \"string\" ? e : e.slide;\n    if (typeof e == \"number\") {\n      s.to(e);\n      return;\n    }\n    if (typeof r == \"string\") {\n      if (typeof s[r] > \"u\")\n        throw new TypeError(`No method named \"${r}\"`);\n      s[r]();\n    } else\n      n.interval && n.ride === !0 && s.pause();\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = Z.getOrCreateInstance(this);\n      if (typeof t == \"number\") {\n        e.to(t);\n        return;\n      }\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n  static dataApiClickHandler(t) {\n    const e = nt(this);\n    if (!e)\n      return;\n    const s = {\n      ...E.getDataAttributes(e),\n      ...E.getDataAttributes(this)\n    }, n = this.getAttribute(\"data-twe-slide-to\");\n    n && (s.interval = !1), Z.carouselInterface(e, s), n && Z.getInstance(e).to(n), t.preventDefault();\n  }\n}\nconst Ta = /* @__PURE__ */ new Set([\n  \"background\",\n  \"cite\",\n  \"href\",\n  \"itemtype\",\n  \"longdesc\",\n  \"poster\",\n  \"src\",\n  \"xlink:href\"\n]), ya = /^aria-[\\w-]*$/i, Aa = /^data-twe-[\\w-]*$/i, Ca = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Oa = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i, Da = (i, t) => {\n  const e = i.nodeName.toLowerCase();\n  if (t.includes(e))\n    return Ta.has(e) ? !!(Ca.test(i.nodeValue) || Oa.test(i.nodeValue)) : !0;\n  const s = t.filter(\n    (n) => n instanceof RegExp\n  );\n  for (let n = 0, r = s.length; n < r; n++)\n    if (s[n].test(e))\n      return !0;\n  return !1;\n}, Na = {\n  // Global attributes allowed on any supplied element below.\n  \"*\": [\n    \"class\",\n    \"dir\",\n    \"id\",\n    \"lang\",\n    \"role\",\n    ya,\n    Aa\n  ],\n  a: [\"target\", \"href\", \"title\", \"rel\"],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\nfunction ds(i, t, e) {\n  if (!i.length)\n    return i;\n  if (e && typeof e == \"function\")\n    return e(i);\n  const n = new window.DOMParser().parseFromString(i, \"text/html\"), r = [].concat(...n.body.querySelectorAll(\"*\"));\n  for (let o = 0, a = r.length; o < a; o++) {\n    const l = r[o], u = l.nodeName.toLowerCase();\n    if (!Object.keys(t).includes(u)) {\n      l.remove();\n      continue;\n    }\n    const c = [].concat(...l.attributes), f = [].concat(\n      t[\"*\"] || [],\n      t[u] || []\n    );\n    c.forEach((v) => {\n      Da(v, f) || l.removeAttribute(v.nodeName);\n    });\n  }\n  return n.body.innerHTML;\n}\nconst us = \"tooltip\", Sa = \"twe.tooltip\", z = `.${Sa}`, La = \"te-tooltip\", $a = /* @__PURE__ */ new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]), Ia = {\n  animation: \"boolean\",\n  template: \"string\",\n  title: \"(string|element|function)\",\n  trigger: \"string\",\n  delay: \"(number|object)\",\n  html: \"boolean\",\n  selector: \"(string|boolean)\",\n  placement: \"(string|function)\",\n  offset: \"(array|string|function)\",\n  container: \"(string|element|boolean)\",\n  fallbackPlacements: \"array\",\n  boundary: \"(string|element)\",\n  customClass: \"(string|function)\",\n  sanitize: \"boolean\",\n  sanitizeFn: \"(null|function)\",\n  allowList: \"object\",\n  popperConfig: \"(null|object|function)\"\n}, Ra = {\n  AUTO: \"auto\",\n  TOP: \"top\",\n  RIGHT: M() ? \"left\" : \"right\",\n  BOTTOM: \"bottom\",\n  LEFT: M() ? \"right\" : \"left\"\n}, xa = {\n  animation: !0,\n  template: `\n    <div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\">\n      <div data-twe-tooltip-inner-ref class=\"max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div>\n    </div>\n    `,\n  trigger: \"hover focus\",\n  title: \"\",\n  delay: 0,\n  html: !1,\n  selector: !1,\n  placement: \"top\",\n  offset: [0, 0],\n  container: !1,\n  fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\n  boundary: \"clippingParents\",\n  customClass: \"\",\n  sanitize: !0,\n  sanitizeFn: null,\n  allowList: Na,\n  popperConfig: { hide: !0 }\n}, ka = {\n  HIDE: `hide${z}`,\n  HIDDEN: `hidden${z}`,\n  SHOW: `show${z}`,\n  SHOWN: `shown${z}`,\n  INSERTED: `inserted${z}`,\n  CLICK: `click${z}`,\n  FOCUSIN: `focusin${z}`,\n  FOCUSOUT: `focusout${z}`,\n  MOUSEENTER: `mouseenter${z}`,\n  MOUSELEAVE: `mouseleave${z}`\n}, Pa = \"fade\", Ma = \"modal\", je = \"show\", Bt = \"show\", Ue = \"out\", hs = \"[data-twe-tooltip-inner-ref]\", fs = `.${Ma}`, ps = \"hide.twe.modal\", jt = \"hover\", Fe = \"focus\", Ha = \"click\", Va = \"manual\";\nclass Qt extends tt {\n  constructor(t, e) {\n    if (typeof bn > \"u\")\n      throw new TypeError(\n        \"Bootstrap's tooltips require Popper (https://popper.js.org)\"\n      );\n    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\n  }\n  // Getters\n  static get Default() {\n    return xa;\n  }\n  static get NAME() {\n    return us;\n  }\n  static get Event() {\n    return ka;\n  }\n  static get DefaultType() {\n    return Ia;\n  }\n  // Public\n  enable() {\n    this._isEnabled = !0;\n  }\n  disable() {\n    this._isEnabled = !1;\n  }\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n  toggle(t) {\n    if (this._isEnabled)\n      if (t) {\n        const e = this._initializeOnDelegatedTarget(t);\n        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\n      } else {\n        if (this.getTipElement().classList.contains(je)) {\n          this._leave(null, this);\n          return;\n        }\n        this._enter(null, this);\n      }\n  }\n  dispose() {\n    clearTimeout(this._timeout), d.off(\n      this._element.closest(fs),\n      ps,\n      this._hideModalHandler\n    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();\n  }\n  show() {\n    if (this._element.style.display === \"none\")\n      throw new Error(\"Please use show on visible elements\");\n    if (!(this.isWithContent() && this._isEnabled))\n      return;\n    const t = d.trigger(\n      this._element,\n      this.constructor.Event.SHOW\n    ), e = Ms(this._element), s = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\n    if (t.defaultPrevented || !s)\n      return;\n    this.constructor.NAME === \"tooltip\" && this.tip && this.getTitle() !== this.tip.querySelector(hs).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);\n    const n = this.getTipElement(), r = Gn(this.constructor.NAME);\n    n.setAttribute(\"id\", r), this._element.setAttribute(\"aria-describedby\", r), this._config.animation && setTimeout(() => {\n      this.tip.classList.add(\"opacity-100\"), this.tip.classList.remove(\"opacity-0\");\n    }, 100);\n    const o = typeof this._config.placement == \"function\" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(o);\n    this._addAttachmentClass(a);\n    const { container: l } = this._config;\n    if (V.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), d.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ti(\n      this._element,\n      n,\n      this._getPopperConfig(a)\n    ), n.getAttribute(\"id\").includes(\"tooltip\"))\n      switch (o) {\n        case \"bottom\":\n          n.classList.add(\"py-[0.4rem]\");\n          break;\n        case \"left\":\n          n.classList.add(\"px-[0.4rem]\");\n          break;\n        case \"right\":\n          n.classList.add(\"px-[0.4rem]\");\n          break;\n        default:\n          n.classList.add(\"py-[0.4rem]\");\n          break;\n      }\n    const c = this._resolvePossibleFunction(this._config.customClass);\n    c && n.classList.add(...c.split(\" \")), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((g) => {\n      d.on(g, \"mouseover\", me);\n    });\n    const f = () => {\n      const g = this._hoverState;\n      this._hoverState = null, d.trigger(this._element, this.constructor.Event.SHOWN), g === Ue && this._leave(null, this);\n    }, v = this.tip.classList.contains(\"transition-opacity\");\n    this._queueCallback(f, this.tip, v);\n  }\n  hide() {\n    if (!this._popper)\n      return;\n    const t = this.getTipElement(), e = () => {\n      this._isWithActiveTrigger() || (this._hoverState !== Bt && t.remove(), this._cleanTipClass(), this._element.removeAttribute(\"aria-describedby\"), d.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());\n    };\n    if (d.trigger(\n      this._element,\n      this.constructor.Event.HIDE\n    ).defaultPrevented)\n      return;\n    t.classList.add(\"opacity-0\"), t.classList.remove(\"opacity-100\"), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((r) => d.off(r, \"mouseover\", me)), this._activeTrigger[Ha] = !1, this._activeTrigger[Fe] = !1, this._activeTrigger[jt] = !1;\n    const n = this.tip.classList.contains(\"opacity-0\");\n    this._queueCallback(e, this.tip, n), this._hoverState = \"\";\n  }\n  update() {\n    this._popper !== null && this._popper.update();\n  }\n  // Protected\n  isWithContent() {\n    return !!this.getTitle();\n  }\n  getTipElement() {\n    if (this.tip)\n      return this.tip;\n    const t = document.createElement(\"div\");\n    t.innerHTML = this._config.template;\n    const e = t.children[0];\n    return this.setContent(e), e.classList.remove(Pa, je), this.tip = e, this.tip;\n  }\n  setContent(t) {\n    this._sanitizeAndSetContent(t, this.getTitle(), hs);\n  }\n  _sanitizeAndSetContent(t, e, s) {\n    const n = h.findOne(s, t);\n    if (!e && n) {\n      n.remove();\n      return;\n    }\n    this.setElementContent(n, e);\n  }\n  setElementContent(t, e) {\n    if (t !== null) {\n      if (St(e)) {\n        e = rt(e), this._config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.append(e)) : t.textContent = e.textContent;\n        return;\n      }\n      this._config.html ? (this._config.sanitize && (e = ds(\n        e,\n        this._config.allowList,\n        this._config.sanitizeFn\n      )), t.innerHTML = e) : t.textContent = e;\n    }\n  }\n  getTitle() {\n    const t = this._element.getAttribute(\"data-twe-original-title\") || this._config.title;\n    return this._resolvePossibleFunction(t);\n  }\n  updateAttachment(t) {\n    return t === \"right\" ? \"end\" : t === \"left\" ? \"start\" : t;\n  }\n  // Private\n  _initializeOnDelegatedTarget(t, e) {\n    return e || this.constructor.getOrCreateInstance(\n      t.delegateTarget,\n      this._getDelegateConfig()\n    );\n  }\n  _getOffset() {\n    const { offset: t } = this._config;\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\n  }\n  _resolvePossibleFunction(t) {\n    return typeof t == \"function\" ? t.call(this._element) : t;\n  }\n  _getPopperConfig(t) {\n    const e = {\n      placement: t,\n      modifiers: [\n        {\n          name: \"flip\",\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        },\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"arrow\",\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        },\n        {\n          name: \"onChange\",\n          enabled: !0,\n          phase: \"afterWrite\",\n          fn: (s) => this._handlePopperPlacementChange(s)\n        }\n      ],\n      onFirstUpdate: (s) => {\n        s.options.placement !== s.placement && this._handlePopperPlacementChange(s);\n      }\n    };\n    return {\n      ...e,\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(e) : this._config.popperConfig\n    };\n  }\n  _addAttachmentClass(t) {\n    this.getTipElement().classList.add(\n      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`\n    );\n  }\n  _getAttachment(t) {\n    return Ra[t.toUpperCase()];\n  }\n  _setListeners() {\n    this._config.trigger.split(\" \").forEach((e) => {\n      if (e === \"click\")\n        d.on(\n          this._element,\n          this.constructor.Event.CLICK,\n          this._config.selector,\n          (s) => this.toggle(s)\n        );\n      else if (e !== Va) {\n        const s = e === jt ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === jt ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n        d.on(\n          this._element,\n          s,\n          this._config.selector,\n          (r) => this._enter(r)\n        ), d.on(\n          this._element,\n          n,\n          this._config.selector,\n          (r) => this._leave(r)\n        );\n      }\n    }), this._hideModalHandler = () => {\n      this._element && this.hide();\n    }, d.on(\n      this._element.closest(fs),\n      ps,\n      this._hideModalHandler\n    ), this._config.selector ? this._config = {\n      ...this._config,\n      trigger: \"manual\",\n      selector: \"\"\n    } : this._fixTitle();\n  }\n  _fixTitle() {\n    const t = this._element.getAttribute(\"title\"), e = typeof this._element.getAttribute(\n      \"data-twe-original-title\"\n    );\n    (t || e !== \"string\") && (this._element.setAttribute(\"data-twe-original-title\", t || \"\"), t && !this._element.getAttribute(\"aria-label\") && !this._element.textContent && this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\n  }\n  _enter(t, e) {\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusin\" ? Fe : jt] = !0), e.getTipElement().classList.contains(je) || e._hoverState === Bt) {\n      e._hoverState = Bt;\n      return;\n    }\n    if (clearTimeout(e._timeout), e._hoverState = Bt, !e._config.delay || !e._config.delay.show) {\n      e.show();\n      return;\n    }\n    e._timeout = setTimeout(() => {\n      e._hoverState === Bt && e.show();\n    }, e._config.delay.show);\n  }\n  _leave(t, e) {\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusout\" ? Fe : jt] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {\n      if (clearTimeout(e._timeout), e._hoverState = Ue, !e._config.delay || !e._config.delay.hide) {\n        e.hide();\n        return;\n      }\n      e._timeout = setTimeout(() => {\n        e._hoverState === Ue && e.hide();\n      }, e._config.delay.hide);\n    }\n  }\n  _isWithActiveTrigger() {\n    for (const t in this._activeTrigger)\n      if (this._activeTrigger[t])\n        return !0;\n    return !1;\n  }\n  _getConfig(t) {\n    const e = E.getDataAttributes(this._element);\n    return Object.keys(e).forEach((s) => {\n      $a.has(s) && delete e[s];\n    }), t = {\n      ...this.constructor.Default,\n      ...e,\n      ...typeof t == \"object\" && t ? t : {}\n    }, t.container = t.container === !1 ? document.body : rt(t.container), typeof t.delay == \"number\" && (t.delay = {\n      show: t.delay,\n      hide: t.delay\n    }), typeof t.title == \"number\" && (t.title = t.title.toString()), typeof t.content == \"number\" && (t.content = t.content.toString()), R(us, t, this.constructor.DefaultType), t.sanitize && (t.template = ds(\n      t.template,\n      t.allowList,\n      t.sanitizeFn\n    )), t;\n  }\n  _getDelegateConfig() {\n    const t = {};\n    for (const e in this._config)\n      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\n    return t;\n  }\n  _cleanTipClass() {\n    const t = this.getTipElement(), e = new RegExp(\n      `(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`,\n      \"g\"\n    ), s = t.getAttribute(\"class\").match(e);\n    s !== null && s.length > 0 && s.map((n) => n.trim()).forEach((n) => t.classList.remove(n));\n  }\n  _getBasicClassPrefix() {\n    return La;\n  }\n  _handlePopperPlacementChange(t) {\n    const { state: e } = t;\n    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n  }\n  _disposePopper() {\n    this._popper && (this._popper.destroy(), this._popper = null);\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Qt.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Wa = \"popover\", Ba = \"twe.popover\", q = `.${Ba}`, ja = \"te-popover\", Ua = {\n  ...Qt.Default,\n  placement: \"right\",\n  offset: [0, 8],\n  trigger: \"click\",\n  content: \"\",\n  template: `\n    <div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-2 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:border-white/10 dark:bg-surface-dark dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\">\n      <h3 data-twe-popover-header-ref class=\"py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-white/10\"></h3>\n      <div data-twe-popover-body-ref class=\"p-4 text-surface dark:text-white\"></div>\n    </div>\n    `\n}, Fa = {\n  ...Qt.DefaultType,\n  content: \"(string|element|function)\"\n}, Ya = {\n  HIDE: `hide${q}`,\n  HIDDEN: `hidden${q}`,\n  SHOW: `show${q}`,\n  SHOWN: `shown${q}`,\n  INSERTED: `inserted${q}`,\n  CLICK: `click${q}`,\n  FOCUSIN: `focusin${q}`,\n  FOCUSOUT: `focusout${q}`,\n  MOUSEENTER: `mouseenter${q}`,\n  MOUSELEAVE: `mouseleave${q}`\n}, Ka = \"[data-twe-popover-header-ref]\", za = \"[data-twe-popover-body-ref]\";\nclass Nn extends Qt {\n  // Getters\n  static get Default() {\n    return Ua;\n  }\n  static get NAME() {\n    return Wa;\n  }\n  static get Event() {\n    return Ya;\n  }\n  static get DefaultType() {\n    return Fa;\n  }\n  // Overrides\n  isWithContent() {\n    return this.getTitle() || this._getContent();\n  }\n  setContent(t) {\n    this._sanitizeAndSetContent(t, this.getTitle(), Ka), this._sanitizeAndSetContent(t, this._getContent(), za);\n  }\n  // Private\n  _getContent() {\n    return this._resolvePossibleFunction(this._config.content);\n  }\n  _getBasicClassPrefix() {\n    return ja;\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Nn.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Ye = \"scrollspy\", qa = \"twe.scrollspy\", Ci = `.${qa}`, _s = {\n  offset: 10,\n  method: \"auto\",\n  target: \"\"\n}, Xa = {\n  offset: \"number\",\n  method: \"string\",\n  target: \"(string|element)\"\n}, Ga = {\n  active: \"!text-primary font-semibold border-s-[0.125rem] border-solid border-primary\"\n}, Qa = {\n  active: \"string\"\n}, Ke = `activate${Ci}`, Za = `scroll${Ci}`, Kt = \"data-twe-nav-link-active\", Sn = \"data-twe-collapsible-scrollspy-ref\", Ln = \"[data-twe-dropdown-item-ref]\", Ja = \"[data-twe-nav-list-ref]\", oi = \"[data-twe-nav-link-ref]\", tl = \"[data-twe-nav-item-ref]\", $n = \"[data-twe-list-group-item-ref]\", ze = `${oi}, ${$n}, ${Ln}`, el = \"[data-twe-dropdown-ref]\", il = \"[data-twe-dropdown-toggle-ref]\", gs = `[${Sn}]`, sl = `[${Kt}]`, qe = \"ul\", nl = \"maxOffset\", ms = \"position\";\nclass In extends tt {\n  constructor(t, e, s) {\n    super(t), this._scrollElement = this._element.tagName === \"BODY\" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._offsets = [], this._targets = [], this._collapsibles = [], this._activeTarget = null, this._scrollHeight = 0, d.on(this._scrollElement, Za, () => this._process()), this.refresh(), this._process(), this._bindActivateEvent(), this._getCollapsibles(), this._collapsibles.length !== 0 && (this._showSubsection(), this._hideSubsection());\n  }\n  // Getters\n  static get Default() {\n    return _s;\n  }\n  static get NAME() {\n    return Ye;\n  }\n  // Public\n  refresh() {\n    const t = this._scrollElement === this._scrollElement.window ? nl : ms, e = this._config.method === \"auto\" ? t : this._config.method, s = e === ms ? this._getScrollTop() : 0;\n    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), h.find(\n      ze,\n      this._config.target\n    ).map((r) => {\n      const o = ci(r), a = o ? h.findOne(o) : null;\n      if (a) {\n        const l = a.getBoundingClientRect();\n        if (l.width || l.height)\n          return [\n            E[e](a).top + s,\n            o\n          ];\n      }\n      return null;\n    }).filter((r) => r).sort((r, o) => r[0] - o[0]).forEach((r) => {\n      this._offsets.push(r[0]), this._targets.push(r[1]);\n    });\n  }\n  dispose() {\n    d.off(this._scrollElement, Ci), d.off(this._scrollElement, Ke), super.dispose();\n  }\n  // Private\n  _getConfig(t) {\n    return t = {\n      ..._s,\n      ...E.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, t.target = rt(t.target) || document.documentElement, R(Ye, t, Xa), t;\n  }\n  _getClasses(t) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...Ga,\n      ...e,\n      ...t\n    }, R(Ye, t, Qa), t;\n  }\n  _getScrollTop() {\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n  }\n  _getScrollHeight() {\n    return this._scrollElement.scrollHeight || Math.max(\n      document.body.scrollHeight,\n      document.documentElement.scrollHeight\n    );\n  }\n  _getOffsetHeight() {\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n  }\n  _process() {\n    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), s = this._config.offset + e - this._getOffsetHeight();\n    if (this._scrollHeight !== e && this.refresh(), t >= s) {\n      const n = this._targets[this._targets.length - 1];\n      this._activeTarget !== n && this._activate(n);\n      return;\n    }\n    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {\n      this._activeTarget = null, this._clear();\n      return;\n    }\n    for (let n = this._offsets.length; n--; )\n      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > \"u\" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);\n  }\n  _activate(t) {\n    this._activeTarget = t, this._clear();\n    const e = ze.split(\",\").map(\n      (n) => `${n}[data-twe-target=\"${t}\"],${n}[href=\"${t}\"]`\n    ), s = h.findOne(e.join(\",\"), this._config.target);\n    s.classList.add(...this._classes.active.split(\" \")), s.setAttribute(Kt, \"\"), s.getAttribute(Ln) ? h.findOne(\n      il,\n      s.closest(el)\n    ).classList.add(...this._classes.active.split(\" \")) : h.parents(s, Ja).forEach(\n      (n) => {\n        h.prev(\n          n,\n          `${oi}, ${$n}`\n        ).forEach((r) => {\n          r.classList.add(...this._classes.active.split(\" \")), r.setAttribute(Kt, \"\");\n        }), h.prev(n, tl).forEach(\n          (r) => {\n            h.children(r, oi).forEach(\n              (o) => o.classList.add(...this._classes.active.split(\" \"))\n            );\n          }\n        );\n      }\n    ), d.trigger(this._scrollElement, Ke, {\n      relatedTarget: t\n    });\n  }\n  _clear() {\n    h.find(ze, this._config.target).filter(\n      (t) => t.classList.contains(...this._classes.active.split(\" \"))\n    ).forEach((t) => {\n      t.classList.remove(...this._classes.active.split(\" \")), t.removeAttribute(Kt);\n    });\n  }\n  _hide(t) {\n    const e = h.findOne(\n      qe,\n      t.parentNode\n    );\n    e.style.overflow = \"hidden\", e.style.height = \"0px\";\n  }\n  _show(t, e) {\n    t.style.height = e;\n  }\n  _getCollapsibles() {\n    const t = h.find(\n      gs\n    );\n    t && t.forEach((e) => {\n      const s = e.parentNode, n = h.findOne(qe, s), r = n.offsetHeight || n.scrollHeight;\n      this._collapsibles.push({\n        element: n,\n        relatedTarget: e.getAttribute(\"href\"),\n        height: `${r}px`\n      });\n    });\n  }\n  _showSubsection() {\n    h.find(sl).filter((s) => s.hasAttribute(Sn)).forEach((s) => {\n      const n = h.findOne(qe, s.parentNode), r = this._collapsibles.find((o) => o.relatedTarget = s.getAttribute(\"href\")).height;\n      this._show(n, r);\n    });\n  }\n  _hideSubsection() {\n    h.find(\n      gs\n    ).filter((e) => e.hasAttribute(Kt) === !1).forEach((e) => {\n      this._hide(e);\n    });\n  }\n  _bindActivateEvent() {\n    d.on(this._element, Ke, () => {\n      this._showSubsection(), this._hideSubsection();\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = In.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Es = \"tab\", rl = \"twe.tab\", ye = `.${rl}`, ol = `hide${ye}`, al = `hidden${ye}`, ll = `show${ye}`, cl = `shown${ye}`, dl = \"data-twe-dropdown-menu-ref\", Ot = \"data-twe-tab-active\", ge = \"data-twe-nav-active\", ul = \"[data-twe-dropdown-ref]\", hl = \"[data-twe-nav-ref]\", vs = `[${Ot}]`, fl = `[${ge}]`, bs = \":scope > li > .active\", pl = \"[data-twe-dropdown-toggle-ref]\", _l = \":scope > [data-twe-dropdown-menu-ref] [data-twe-dropdown-show]\", gl = {\n  show: \"opacity-100\",\n  hide: \"opacity-0\"\n}, ml = {\n  show: \"string\",\n  hide: \"string\"\n};\nclass Rn extends tt {\n  constructor(t, e) {\n    super(t), this._classes = this._getClasses(e);\n  }\n  // Getters\n  static get NAME() {\n    return Es;\n  }\n  // Public\n  show() {\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(ge) === \"\")\n      return;\n    let t;\n    const e = nt(this._element), s = this._element.closest(hl), n = h.findOne(\n      fl,\n      s\n    );\n    if (s) {\n      const l = s.nodeName === \"UL\" || s.nodeName === \"OL\" ? bs : vs;\n      t = h.find(l, s), t = t[t.length - 1];\n    }\n    const r = t ? d.trigger(t, ol, {\n      relatedTarget: this._element\n    }) : null;\n    if (d.trigger(this._element, ll, {\n      relatedTarget: t\n    }).defaultPrevented || r !== null && r.defaultPrevented)\n      return;\n    this._activate(\n      this._element,\n      s,\n      null,\n      n,\n      this._element\n    );\n    const a = () => {\n      d.trigger(t, al, {\n        relatedTarget: this._element\n      }), d.trigger(this._element, cl, {\n        relatedTarget: t\n      });\n    };\n    e ? this._activate(\n      e,\n      e.parentNode,\n      a,\n      n,\n      this._element\n    ) : a();\n  }\n  // Private\n  _getClasses(t) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...gl,\n      ...e,\n      ...t\n    }, R(Es, t, ml), t;\n  }\n  _activate(t, e, s, n, r) {\n    const a = (e && (e.nodeName === \"UL\" || e.nodeName === \"OL\") ? h.find(bs, e) : h.children(e, vs))[0], l = s && a && a.hasAttribute(Ot), u = () => this._transitionComplete(\n      t,\n      a,\n      s,\n      n,\n      r\n    );\n    a && l ? (E.removeClass(a, this._classes.show), E.addClass(a, this._classes.hide), this._queueCallback(u, t, !0)) : u();\n  }\n  _transitionComplete(t, e, s, n, r) {\n    if (e && n) {\n      e.removeAttribute(Ot), n.removeAttribute(ge);\n      const a = h.findOne(\n        _l,\n        e.parentNode\n      );\n      a && a.removeAttribute(Ot), e.getAttribute(\"role\") === \"tab\" && e.setAttribute(\"aria-selected\", !1);\n    }\n    t.setAttribute(Ot, \"\"), r.setAttribute(ge, \"\"), t.getAttribute(\"role\") === \"tab\" && t.setAttribute(\"aria-selected\", !0), Xt(t), t.classList.contains(this._classes.hide) && (E.removeClass(t, this._classes.hide), E.addClass(t, this._classes.show));\n    let o = t.parentNode;\n    if (o && o.nodeName === \"LI\" && (o = o.parentNode), o && o.hasAttribute(dl)) {\n      const a = t.closest(ul);\n      a && h.find(pl, a).forEach(\n        (l) => l.setAttribute(Ot, \"\")\n      ), t.setAttribute(\"aria-expanded\", !0);\n    }\n    s && s();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Rn.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\n(() => {\n  var i = { 454: (s, n, r) => {\n    r.d(n, { Z: () => l });\n    var o = r(645), a = r.n(o)()(function(u) {\n      return u[1];\n    });\n    a.push([s.id, \"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\", \"\"]);\n    const l = a;\n  }, 645: (s) => {\n    s.exports = function(n) {\n      var r = [];\n      return r.toString = function() {\n        return this.map(function(o) {\n          var a = n(o);\n          return o[2] ? \"@media \".concat(o[2], \" {\").concat(a, \"}\") : a;\n        }).join(\"\");\n      }, r.i = function(o, a, l) {\n        typeof o == \"string\" && (o = [[null, o, \"\"]]);\n        var u = {};\n        if (l)\n          for (var c = 0; c < this.length; c++) {\n            var f = this[c][0];\n            f != null && (u[f] = !0);\n          }\n        for (var v = 0; v < o.length; v++) {\n          var g = [].concat(o[v]);\n          l && u[g[0]] || (a && (g[2] ? g[2] = \"\".concat(a, \" and \").concat(g[2]) : g[2] = a), r.push(g));\n        }\n      }, r;\n    };\n  }, 810: () => {\n    (function() {\n      if (typeof window < \"u\")\n        try {\n          var s = new window.CustomEvent(\"test\", { cancelable: !0 });\n          if (s.preventDefault(), s.defaultPrevented !== !0)\n            throw new Error(\"Could not prevent default\");\n        } catch {\n          var n = function(o, a) {\n            var l, u;\n            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent(\"CustomEvent\")).initCustomEvent(o, a.bubbles, a.cancelable, a.detail), u = l.preventDefault, l.preventDefault = function() {\n              u.call(this);\n              try {\n                Object.defineProperty(this, \"defaultPrevented\", { get: function() {\n                  return !0;\n                } });\n              } catch {\n                this.defaultPrevented = !0;\n              }\n            }, l;\n          };\n          n.prototype = window.Event.prototype, window.CustomEvent = n;\n        }\n    })();\n  }, 379: (s, n, r) => {\n    var o, a = function() {\n      var m = {};\n      return function(p) {\n        if (m[p] === void 0) {\n          var _ = document.querySelector(p);\n          if (window.HTMLIFrameElement && _ instanceof window.HTMLIFrameElement)\n            try {\n              _ = _.contentDocument.head;\n            } catch {\n              _ = null;\n            }\n          m[p] = _;\n        }\n        return m[p];\n      };\n    }(), l = [];\n    function u(m) {\n      for (var p = -1, _ = 0; _ < l.length; _++)\n        if (l[_].identifier === m) {\n          p = _;\n          break;\n        }\n      return p;\n    }\n    function c(m, p) {\n      for (var _ = {}, b = [], w = 0; w < m.length; w++) {\n        var C = m[w], y = p.base ? C[0] + p.base : C[0], N = _[y] || 0, S = \"\".concat(y, \" \").concat(N);\n        _[y] = N + 1;\n        var x = u(S), I = { css: C[1], media: C[2], sourceMap: C[3] };\n        x !== -1 ? (l[x].references++, l[x].updater(I)) : l.push({ identifier: S, updater: L(I, p), references: 1 }), b.push(S);\n      }\n      return b;\n    }\n    function f(m) {\n      var p = document.createElement(\"style\"), _ = m.attributes || {};\n      if (_.nonce === void 0) {\n        var b = r.nc;\n        b && (_.nonce = b);\n      }\n      if (Object.keys(_).forEach(function(C) {\n        p.setAttribute(C, _[C]);\n      }), typeof m.insert == \"function\")\n        m.insert(p);\n      else {\n        var w = a(m.insert || \"head\");\n        if (!w)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        w.appendChild(p);\n      }\n      return p;\n    }\n    var v, g = (v = [], function(m, p) {\n      return v[m] = p, v.filter(Boolean).join(`\n`);\n    });\n    function O(m, p, _, b) {\n      var w = _ ? \"\" : b.media ? \"@media \".concat(b.media, \" {\").concat(b.css, \"}\") : b.css;\n      if (m.styleSheet)\n        m.styleSheet.cssText = g(p, w);\n      else {\n        var C = document.createTextNode(w), y = m.childNodes;\n        y[p] && m.removeChild(y[p]), y.length ? m.insertBefore(C, y[p]) : m.appendChild(C);\n      }\n    }\n    function T(m, p, _) {\n      var b = _.css, w = _.media, C = _.sourceMap;\n      if (w ? m.setAttribute(\"media\", w) : m.removeAttribute(\"media\"), C && typeof btoa < \"u\" && (b += `\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(C)))), \" */\")), m.styleSheet)\n        m.styleSheet.cssText = b;\n      else {\n        for (; m.firstChild; )\n          m.removeChild(m.firstChild);\n        m.appendChild(document.createTextNode(b));\n      }\n    }\n    var A = null, D = 0;\n    function L(m, p) {\n      var _, b, w;\n      if (p.singleton) {\n        var C = D++;\n        _ = A || (A = f(p)), b = O.bind(null, _, C, !1), w = O.bind(null, _, C, !0);\n      } else\n        _ = f(p), b = T.bind(null, _, p), w = function() {\n          (function(y) {\n            if (y.parentNode === null)\n              return !1;\n            y.parentNode.removeChild(y);\n          })(_);\n        };\n      return b(m), function(y) {\n        if (y) {\n          if (y.css === m.css && y.media === m.media && y.sourceMap === m.sourceMap)\n            return;\n          b(m = y);\n        } else\n          w();\n      };\n    }\n    s.exports = function(m, p) {\n      (p = p || {}).singleton || typeof p.singleton == \"boolean\" || (p.singleton = (o === void 0 && (o = !!(window && document && document.all && !window.atob)), o));\n      var _ = c(m = m || [], p);\n      return function(b) {\n        if (b = b || [], Object.prototype.toString.call(b) === \"[object Array]\") {\n          for (var w = 0; w < _.length; w++) {\n            var C = u(_[w]);\n            l[C].references--;\n          }\n          for (var y = c(b, p), N = 0; N < _.length; N++) {\n            var S = u(_[N]);\n            l[S].references === 0 && (l[S].updater(), l.splice(S, 1));\n          }\n          _ = y;\n        }\n      };\n    };\n  } }, t = {};\n  function e(s) {\n    var n = t[s];\n    if (n !== void 0)\n      return n.exports;\n    var r = t[s] = { id: s, exports: {} };\n    return i[s](r, r.exports, e), r.exports;\n  }\n  e.n = (s) => {\n    var n = s && s.__esModule ? () => s.default : () => s;\n    return e.d(n, { a: n }), n;\n  }, e.d = (s, n) => {\n    for (var r in n)\n      e.o(n, r) && !e.o(s, r) && Object.defineProperty(s, r, { enumerable: !0, get: n[r] });\n  }, e.o = (s, n) => Object.prototype.hasOwnProperty.call(s, n), (() => {\n    var s = e(379), n = e.n(s), r = e(454);\n    function o(l) {\n      if (!l.hasAttribute(\"autocompleted\")) {\n        l.setAttribute(\"autocompleted\", \"\");\n        var u = new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !0, detail: null });\n        l.dispatchEvent(u) || (l.value = \"\");\n      }\n    }\n    function a(l) {\n      l.hasAttribute(\"autocompleted\") && (l.removeAttribute(\"autocompleted\"), l.dispatchEvent(new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !1, detail: null })));\n    }\n    n()(r.Z, { insert: \"head\", singleton: !1 }), r.Z.locals, e(810), document.addEventListener(\"animationstart\", function(l) {\n      l.animationName === \"onautofillstart\" ? o(l.target) : a(l.target);\n    }, !0), document.addEventListener(\"input\", function(l) {\n      l.inputType !== \"insertReplacementText\" && \"data\" in l ? a(l.target) : o(l.target);\n    }, !0);\n  })();\n})();\nconst Xe = \"input\", oe = \"twe.input\", xn = \"data-twe-input-wrapper-init\", kn = \"data-twe-input-notch-ref\", Pn = \"data-twe-input-notch-leading-ref\", Mn = \"data-twe-input-notch-middle-ref\", El = \"data-twe-input-notch-trailing-ref\", vl = \"data-twe-input-helper-ref\", bl = \"data-twe-input-placeholder-active\", st = \"data-twe-input-state-active\", ws = \"data-twe-input-focused\", Ts = \"data-twe-input-form-counter\", ae = `[${xn}] input`, le = `[${xn}] textarea`, yt = `[${kn}]`, ys = `[${Pn}]`, As = `[${Mn}]`, wl = `[${vl}]`, Tl = {\n  inputFormWhite: !1\n}, yl = {\n  inputFormWhite: \"(boolean)\"\n}, Al = {\n  notch: \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\n  notchLeading: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-e-0 rounded-s-[0.25rem] group-data-[twe-input-focused]:border-e-0 group-data-[twe-input-state-active]:border-e-0\",\n  notchLeadingNormal: \"border-secondary-500 dark:border-neutral-400 group-data-[twe-input-focused]:shadow-notch-1 group-data-[twe-input-focused]:border-primary\",\n  notchLeadingWhite: \"border-neutral-200 group-data-[twe-input-focused]:shadow-notch-1 group-data-[twe-input-focused]:shadow-white group-data-[twe-input-focused]:border-white\",\n  notchMiddle: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-e-0 border-s-0 group-data-[twe-input-focused]:border-x-0 group-data-[twe-input-state-active]:border-x-0 group-data-[twe-input-focused]:border-t group-data-[twe-input-state-active]:border-t group-data-[twe-input-focused]:border-solid group-data-[twe-input-state-active]:border-solid group-data-[twe-input-focused]:border-t-transparent group-data-[twe-input-state-active]:border-t-transparent\",\n  notchMiddleNormal: \"border-secondary-500 dark:border-neutral-400 group-data-[twe-input-focused]:shadow-notch-2 group-data-[twe-input-focused]:border-primary\",\n  notchMiddleWhite: \"border-neutral-200 group-data-[twe-input-focused]:shadow-notch-2 group-data-[twe-input-focused]:shadow-white group-data-[twe-input-focused]:border-white\",\n  notchTrailing: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-s-0 rounded-e-[0.25rem] group-data-[twe-input-focused]:border-s-0 group-data-[twe-input-state-active]:border-s-0\",\n  notchTrailingNormal: \"border-secondary-500 dark:border-neutral-400 group-data-[twe-input-focused]:shadow-notch-3 group-data-[twe-input-focused]:border-primary\",\n  notchTrailingWhite: \"border-neutral-200 group-data-[twe-input-focused]:shadow-notch-3 group-data-[twe-input-focused]:shadow-white group-data-[twe-input-focused]:border-white\",\n  counter: \"text-right leading-[1.6]\"\n}, Cl = {\n  notch: \"string\",\n  notchLeading: \"string\",\n  notchLeadingNormal: \"string\",\n  notchLeadingWhite: \"string\",\n  notchMiddle: \"string\",\n  notchMiddleNormal: \"string\",\n  notchMiddleWhite: \"string\",\n  notchTrailing: \"string\",\n  notchTrailingNormal: \"string\",\n  notchTrailingWhite: \"string\",\n  counter: \"string\"\n};\nclass $ {\n  constructor(t, e, s) {\n    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(s), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (V.setData(t, oe, this), this.init());\n  }\n  // Getters\n  static get NAME() {\n    return Xe;\n  }\n  get input() {\n    return h.findOne(\"input\", this._element) || h.findOne(\"textarea\", this._element);\n  }\n  // Public\n  init() {\n    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);\n  }\n  update() {\n    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();\n  }\n  forceActive() {\n    this.input.setAttribute(st, \"\"), h.findOne(yt, this.input.parentNode).setAttribute(\n      st,\n      \"\"\n    );\n  }\n  forceInactive() {\n    this.input.removeAttribute(st), h.findOne(\n      yt,\n      this.input.parentNode\n    ).removeAttribute(st);\n  }\n  dispose() {\n    this._removeBorder(), V.removeData(this._element, oe), this._element = null;\n  }\n  // Private\n  _getConfig(t, e) {\n    return t = {\n      ...Tl,\n      ...E.getDataAttributes(e),\n      ...typeof t == \"object\" ? t : {}\n    }, R(Xe, t, yl), t;\n  }\n  _getClasses(t) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...Al,\n      ...e,\n      ...t\n    }, R(Xe, t, Cl), t;\n  }\n  _getLabelData() {\n    this._label = h.findOne(\"label\", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());\n  }\n  _getHelper() {\n    this._helper = h.findOne(wl, this._element);\n  }\n  _getCounter() {\n    this._counter = E.getDataAttribute(\n      this.input,\n      \"inputShowcounter\"\n    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());\n  }\n  _getEvents() {\n    d.on(\n      this._element,\n      \"focus\",\n      \"input\",\n      $.activate(new $())\n    ), d.on(\n      this._element,\n      \"input\",\n      \"input\",\n      $.activate(new $())\n    ), d.on(\n      this._element,\n      \"blur\",\n      \"input\",\n      $.deactivate(new $())\n    ), d.on(\n      this._element,\n      \"focus\",\n      \"textarea\",\n      $.activate(new $())\n    ), d.on(\n      this._element,\n      \"input\",\n      \"textarea\",\n      $.activate(new $())\n    ), d.on(\n      this._element,\n      \"blur\",\n      \"textarea\",\n      $.deactivate(new $())\n    ), d.on(window, \"shown.twe.modal\", (t) => {\n      h.find(ae, t.target).forEach(\n        (e) => {\n          const s = $.getInstance(e.parentNode);\n          s && s.update();\n        }\n      ), h.find(le, t.target).forEach(\n        (e) => {\n          const s = $.getInstance(e.parentNode);\n          s && s.update();\n        }\n      );\n    }), d.on(window, \"shown.twe.dropdown\", (t) => {\n      const e = t.target.parentNode.querySelector(\n        \"[data-twe-dropdown-menu-ref]\"\n      );\n      e && (h.find(ae, e).forEach(\n        (s) => {\n          const n = $.getInstance(s.parentNode);\n          n && n.update();\n        }\n      ), h.find(le, e).forEach(\n        (s) => {\n          const n = $.getInstance(s.parentNode);\n          n && n.update();\n        }\n      ));\n    }), d.on(window, \"shown.twe.tab\", (t) => {\n      let e;\n      t.target.href ? e = t.target.href.split(\"#\")[1] : e = E.getDataAttribute(t.target, \"target\").split(\n        \"#\"\n      )[1];\n      const s = h.findOne(`#${e}`);\n      h.find(ae, s).forEach((n) => {\n        const r = $.getInstance(n.parentNode);\n        r && r.update();\n      }), h.find(le, s).forEach(\n        (n) => {\n          const r = $.getInstance(n.parentNode);\n          r && r.update();\n        }\n      );\n    }), d.on(window, \"reset\", (t) => {\n      h.find(ae, t.target).forEach(\n        (e) => {\n          const s = $.getInstance(e.parentNode);\n          s && s.forceInactive();\n        }\n      ), h.find(le, t.target).forEach(\n        (e) => {\n          const s = $.getInstance(e.parentNode);\n          s && s.forceInactive();\n        }\n      );\n    }), d.on(window, \"onautocomplete\", (t) => {\n      const e = $.getInstance(t.target.parentNode);\n      !e || !t.cancelable || e.forceActive();\n    });\n  }\n  _showCounter() {\n    if (h.find(\n      `[${Ts}]`,\n      this._element\n    ).length > 0)\n      return;\n    this._counterElement = document.createElement(\"div\"), E.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Ts, \"\");\n    const e = this.input.value.length;\n    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();\n  }\n  _bindCounter() {\n    d.on(this.input, \"input\", () => {\n      const t = this.input.value.length;\n      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;\n    });\n  }\n  _toggleDefaultDatePlaceholder(t = this.input) {\n    if (!(t.getAttribute(\"type\") === \"date\"))\n      return;\n    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;\n  }\n  _showPlaceholder() {\n    this.input.setAttribute(bl, \"\");\n  }\n  _getNotchData() {\n    this._notchMiddle = h.findOne(\n      As,\n      this._element\n    ), this._notchLeading = h.findOne(\n      ys,\n      this._element\n    );\n  }\n  _getLabelWidth() {\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\n  }\n  _getLabelPositionInInputGroup() {\n    if (this._labelMarginLeft = 0, !this._element.hasAttribute(\"data-twe-input-group-ref\"))\n      return;\n    const t = this.input, e = h.prev(\n      t,\n      \"[data-twe-input-group-text-ref]\"\n    )[0];\n    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;\n  }\n  _applyDivs() {\n    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, s = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = h.find(yt, this._element), r = Ft(\"div\");\n    E.addClass(r, this._classes.notch), r.setAttribute(kn, \"\"), this._notchLeading = Ft(\"div\"), E.addClass(\n      this._notchLeading,\n      `${this._classes.notchLeading} ${t}`\n    ), this._notchLeading.setAttribute(Pn, \"\"), this._notchMiddle = Ft(\"div\"), E.addClass(\n      this._notchMiddle,\n      `${this._classes.notchMiddle} ${e}`\n    ), this._notchMiddle.setAttribute(Mn, \"\"), this._notchTrailing = Ft(\"div\"), E.addClass(\n      this._notchTrailing,\n      `${this._classes.notchTrailing} ${s}`\n    ), this._notchTrailing.setAttribute(El, \"\"), !(n.length >= 1) && (r.append(this._notchLeading), r.append(this._notchMiddle), r.append(this._notchTrailing), this._element.append(r), r.dir = \"ltr\");\n  }\n  _applyNotch() {\n    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);\n  }\n  _removeBorder() {\n    const t = h.findOne(yt, this._element);\n    t && t.remove();\n  }\n  _activate(t) {\n    Vs(() => {\n      this._getElements(t);\n      const e = t ? t.target : this.input, s = h.findOne(\n        yt,\n        this._element\n      );\n      t && t.type === \"focus\" && s && s.setAttribute(ws, \"\"), e.value !== \"\" && (e.setAttribute(st, \"\"), s && s.setAttribute(st, \"\")), this._toggleDefaultDatePlaceholder(e);\n    });\n  }\n  _getElements(t) {\n    if (t && (this._element = t.target.parentNode, this._label = h.findOne(\"label\", this._element)), t && this._label) {\n      const e = this._labelWidth;\n      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = h.findOne(\n        As,\n        t.target.parentNode\n      ), this._notchLeading = h.findOne(\n        ys,\n        t.target.parentNode\n      ), this._applyNotch());\n    }\n  }\n  _deactivate(t) {\n    const e = t ? t.target : this.input;\n    if (e.getAttribute(\"aria-expanded\") === \"true\")\n      return;\n    const s = h.findOne(\n      yt,\n      e.parentNode\n    );\n    s.removeAttribute(ws), e.value === \"\" && (e.removeAttribute(st), s.removeAttribute(st)), this._toggleDefaultDatePlaceholder(e);\n  }\n  static activate(t) {\n    return function(e) {\n      t._activate(e);\n    };\n  }\n  static deactivate(t) {\n    return function(e) {\n      t._deactivate(e);\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let s = V.getData(this, oe);\n      const n = typeof t == \"object\" && t;\n      if (!(!s && /dispose/.test(t)) && (s || (s = new $(this, n)), typeof t == \"string\")) {\n        if (typeof s[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        s[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return V.getData(t, oe);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Ol = {\n  property: \"color\",\n  defaultValue: null,\n  inherit: !0\n}, At = (i, t) => {\n  const { property: e, defaultValue: s, inherit: n } = { ...Ol, ...t }, r = document.createElement(\"div\");\n  r.classList.add(i), document.body.appendChild(r);\n  const a = window.getComputedStyle(r)[e] || s, u = window.getComputedStyle(r.parentElement)[e];\n  return document.body.removeChild(r), !n && u && a === u ? s : a || s;\n}, Ge = \"ripple\", ce = \"twe.ripple\", Dl = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\", Nl = [\"[data-twe-ripple-init]\"], de = [0, 0, 0], Sl = [\n  {\n    name: \"primary\",\n    gradientColor: At(\"text-primary\", { defaultValue: \"#3B71CA\", inherit: !1 })\n  },\n  {\n    name: \"secondary\",\n    gradientColor: At(\"text-primary-100\", { defaultValue: \"#9FA6B2\", inherit: !1 })\n  },\n  {\n    name: \"success\",\n    gradientColor: At(\"text-success\", { defaultValue: \"#14A44D\", inherit: !1 })\n  },\n  {\n    name: \"danger\",\n    gradientColor: At(\"text-danger\", { defaultValue: \"#DC4C64\", inherit: !1 })\n  },\n  {\n    name: \"warning\",\n    gradientColor: At(\"text-warning\", { defaultValue: \"#E4A11B\", inherit: !1 })\n  },\n  {\n    name: \"info\",\n    gradientColor: At(\"text-info\", { defaultValue: \"#54B4D3\", inherit: !1 })\n  },\n  {\n    name: \"light\",\n    gradientColor: \"#fbfbfb\"\n  },\n  {\n    name: \"dark\",\n    gradientColor: \"#262626\"\n  }\n], Cs = 0.5, Ll = {\n  rippleCentered: !1,\n  rippleColor: \"\",\n  rippleColorDark: \"\",\n  rippleDuration: \"500ms\",\n  rippleRadius: 0,\n  rippleUnbound: !1\n}, $l = {\n  rippleCentered: \"boolean\",\n  rippleColor: \"string\",\n  rippleColorDark: \"string\",\n  rippleDuration: \"string\",\n  rippleRadius: \"number\",\n  rippleUnbound: \"boolean\"\n}, Il = {\n  ripple: \"relative overflow-hidden inline-block align-bottom\",\n  rippleWave: \"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",\n  unbound: \"overflow-visible\"\n}, Rl = {\n  ripple: \"string\",\n  rippleWave: \"string\",\n  unbound: \"string\"\n};\nclass Hn {\n  constructor(t, e, s) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(s), this._currentColor = this._options.rippleColor, this._element && (V.setData(t, ce, this), E.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Ge;\n  }\n  // Public\n  init() {\n    this._addClickEvent(this._element);\n  }\n  dispose() {\n    V.removeData(this._element, ce), d.off(this._element, \"mousedown\", this._clickHandler), this._element = null, this._options = null;\n  }\n  // Private\n  _autoInit(t) {\n    Nl.forEach((e) => {\n      h.closest(t.target, e) && (this._element = h.closest(t.target, e));\n    }), this._element.style.minWidth || (E.style(this._element, {\n      \"min-width\": getComputedStyle(this._element).width\n    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], E.addClass(this._element, this._classes.ripple), this._createRipple(t);\n  }\n  _addClickEvent(t) {\n    d.on(t, \"mousedown\", this._clickHandler);\n  }\n  _createRipple(t) {\n    this._element.className.indexOf(this._classes.ripple) < 0 && E.addClass(this._element, this._classes.ripple);\n    const { layerX: e, layerY: s } = t, n = t.offsetX || e, r = t.offsetY || s, o = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), u = {\n      offsetX: this._options.rippleCentered ? o / 2 : n,\n      offsetY: this._options.rippleCentered ? a / 2 : r,\n      height: o,\n      width: a\n    }, c = this._getDiameter(u), f = this._options.rippleRadius || c / 2, v = {\n      delay: l * Cs,\n      duration: l - l * Cs\n    }, g = {\n      left: this._options.rippleCentered ? `${a / 2 - f}px` : `${n - f}px`,\n      top: this._options.rippleCentered ? `${o / 2 - f}px` : `${r - f}px`,\n      height: `${this._options.rippleRadius * 2 || c}px`,\n      width: `${this._options.rippleRadius * 2 || c}px`,\n      transitionDelay: `0s, ${v.delay}ms`,\n      transitionDuration: `${l}ms, ${v.duration}ms`\n    }, O = Ft(\"div\");\n    this._createHTMLRipple({\n      wrapper: this._element,\n      ripple: O,\n      styles: g\n    }), this._removeHTMLRipple({ ripple: O, duration: l });\n  }\n  _createHTMLRipple({ wrapper: t, ripple: e, styles: s }) {\n    Object.keys(s).forEach(\n      (n) => e.style[n] = s[n]\n    ), E.addClass(e, this._classes.rippleWave), e.setAttribute(\"data-twe-ripple-ref\", \"\"), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);\n  }\n  _removeHTMLRipple({ ripple: t, duration: e }) {\n    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {\n      t.classList.add(\"!opacity-0\");\n    }, 10), this._rippleTimer = setTimeout(() => {\n      if (t && (t.remove(), this._element)) {\n        h.find(\"[data-twe-ripple-ref]\", this._element).forEach(\n          (n) => {\n            n.remove();\n          }\n        ), this._isMinWidthSet && (E.style(this._element, { \"min-width\": \"\" }), this._isMinWidthSet = !1);\n        const s = this._initialClasses ? this._addedNewRippleClasses(\n          this._classes.ripple,\n          this._initialClasses\n        ) : this._classes.ripple.split(\" \");\n        E.removeClass(this._element, s);\n      }\n    }, e);\n  }\n  _addedNewRippleClasses(t, e) {\n    return t.split(\" \").filter(\n      (s) => e.findIndex((n) => s === n) === -1\n    );\n  }\n  _durationToMsNumber(t) {\n    return Number(t.replace(\"ms\", \"\").replace(\"s\", \"000\"));\n  }\n  _getConfig(t = {}) {\n    const e = E.getDataAttributes(this._element);\n    return t = {\n      ...Ll,\n      ...e,\n      ...t\n    }, R(Ge, t, $l), t;\n  }\n  _getClasses(t = {}) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...Il,\n      ...e,\n      ...t\n    }, R(Ge, t, Rl), t;\n  }\n  _getDiameter({ offsetX: t, offsetY: e, height: s, width: n }) {\n    const r = e <= s / 2, o = t <= n / 2, a = (v, g) => Math.sqrt(v ** 2 + g ** 2), l = e === s / 2 && t === n / 2, u = {\n      first: r === !0 && o === !1,\n      second: r === !0 && o === !0,\n      third: r === !1 && o === !0,\n      fourth: r === !1 && o === !1\n    }, c = {\n      topLeft: a(t, e),\n      topRight: a(n - t, e),\n      bottomLeft: a(t, s - e),\n      bottomRight: a(n - t, s - e)\n    };\n    let f = 0;\n    return l || u.fourth ? f = c.topLeft : u.third ? f = c.topRight : u.second ? f = c.bottomRight : u.first && (f = c.bottomLeft), f * 2;\n  }\n  _appendRipple(t, e) {\n    e.appendChild(t), setTimeout(() => {\n      E.addClass(t, \"opacity-0 scale-100\");\n    }, 50);\n  }\n  _toggleUnbound(t) {\n    this._options.rippleUnbound === !0 ? E.addClass(t, this._classes.unbound) : E.removeClass(t, this._classes.unbound);\n  }\n  _addColor(t) {\n    let e = this._options.rippleColor || \"rgb(0,0,0)\";\n    (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);\n    const s = Sl.find(\n      (o) => o.name === e.toLowerCase()\n    ), n = s ? this._colorToRGB(s.gradientColor).join(\",\") : this._colorToRGB(e).join(\",\"), r = Dl.split(\"{{color}}\").join(`${n}`);\n    t.style.backgroundImage = `radial-gradient(circle, ${r})`;\n  }\n  _colorToRGB(t) {\n    function e(r) {\n      return r.length < 7 && (r = `#${r[1]}${r[1]}${r[2]}${r[2]}${r[3]}${r[3]}`), [\n        parseInt(r.substr(1, 2), 16),\n        parseInt(r.substr(3, 2), 16),\n        parseInt(r.substr(5, 2), 16)\n      ];\n    }\n    function s(r) {\n      const o = document.body.appendChild(\n        document.createElement(\"fictum\")\n      ), a = \"rgb(1, 2, 3)\";\n      return o.style.color = a, o.style.color !== a || (o.style.color = r, o.style.color === a || o.style.color === \"\") ? de : (r = getComputedStyle(o).color, document.body.removeChild(o), r);\n    }\n    function n(r) {\n      return r = r.match(/[.\\d]+/g).map((o) => +Number(o)), r.length = 3, r;\n    }\n    return t.toLowerCase() === \"transparent\" ? de : t[0] === \"#\" ? e(t) : (t.indexOf(\"rgb\") === -1 && (t = s(t)), t.indexOf(\"rgb\") === 0 ? n(t) : de);\n  }\n  // Static\n  static autoInitial(t) {\n    return function(e) {\n      t._autoInit(e);\n    };\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      return V.getData(this, ce) ? null : new Hn(this, t);\n    });\n  }\n  static getInstance(t) {\n    return V.getData(t, ce);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Qe = \"modal\", xl = \"twe.modal\", K = `.${xl}`, Os = \"Escape\", Ds = {\n  backdrop: !0,\n  keyboard: !0,\n  focus: !0\n}, Ns = {\n  backdrop: \"(boolean|string)\",\n  keyboard: \"boolean\",\n  focus: \"boolean\"\n}, kl = {\n  show: \"transform-none\",\n  static: \"scale-[1.02]\",\n  staticProperties: \"transition-scale duration-300 ease-in-out\",\n  backdrop: \"opacity-50 transition-all duration-300 ease-in-out fixed top-0 left-0 z-[1040] bg-black w-screen h-screen\"\n}, Pl = {\n  show: \"string\",\n  static: \"string\",\n  staticProperties: \"string\",\n  backdrop: \"string\"\n}, Ml = `hide${K}`, Hl = `hidePrevented${K}`, Vl = `hidden${K}`, Wl = `show${K}`, Bl = `shown${K}`, Ss = `resize${K}`, Ls = `click.dismiss${K}`, $s = `keydown.dismiss${K}`, jl = `mouseup.dismiss${K}`, Is = `mousedown.dismiss${K}`, Rs = \"data-twe-modal-open\", xs = \"data-twe-open\", Ut = \"[data-twe-modal-dialog-ref]\", Ul = \"[data-twe-modal-body-ref]\";\nclass ai extends tt {\n  constructor(t, e, s) {\n    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(s), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._scrollBar = new ri(), this._dialog = h.findOne(Ut, this._element), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._didInit = !1, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Qe;\n  }\n  static get Default() {\n    return Ds;\n  }\n  static get getDefaultType() {\n    return Ns;\n  }\n  // Public\n  toggle(t) {\n    return this._isShown ? this.hide() : this.show(t);\n  }\n  show(t) {\n    this._isShown || this._isTransitioning || d.trigger(this._element, Wl, {\n      relatedTarget: t\n    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(Rs, \"true\"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), d.on(this._dialog, Is, () => {\n      d.one(this._element, jl, (s) => {\n        s.target === this._element && (this._ignoreBackdropClick = !0);\n      });\n    }), this._showElement(t), this._showBackdrop());\n  }\n  hide() {\n    if (!this._isShown || this._isTransitioning || d.trigger(this._element, Ml).defaultPrevented)\n      return;\n    this._isShown = !1;\n    const e = this._isAnimated();\n    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), h.findOne(Ut, this._element).classList.remove(this._classes.show), d.off(this._element, Ls), d.off(this._dialog, Is), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(xs);\n  }\n  dispose() {\n    [window, document, this._dialog].forEach(\n      (t) => d.off(t, K)\n    ), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n  }\n  handleUpdate() {\n    this._adjustDialog();\n  }\n  // Private\n  _init() {\n    this._didInit || (Cn(ai), this._didInit = !0);\n  }\n  _initializeBackDrop() {\n    return new yn({\n      isVisible: !!this._config.backdrop,\n      // 'static' option will be translated to true, and booleans will keep their value\n      isAnimated: this._isAnimated(),\n      backdropClasses: this._classes.backdrop\n    });\n  }\n  _initializeFocusTrap() {\n    return new An(this._element, {\n      event: \"keydown\",\n      condition: (t) => t.key === \"Tab\"\n    });\n  }\n  _showElement(t) {\n    const e = this._isAnimated(), s = h.findOne(Ul, this._dialog);\n    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = \"block\", this._element.classList.remove(\"hidden\"), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`${xs}`, \"true\"), this._element.scrollTop = 0;\n    const n = h.findOne(Ut, this._element);\n    n.classList.add(this._classes.show), n.classList.remove(\"opacity-0\"), n.classList.add(\"opacity-100\"), s && (s.scrollTop = 0), e && Xt(this._element);\n    const r = () => {\n      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, d.trigger(this._element, Bl, {\n        relatedTarget: t\n      });\n    };\n    this._queueCallback(r, this._dialog, e);\n  }\n  _setEscapeEvent() {\n    this._isShown ? d.on(document, $s, (t) => {\n      this._config.keyboard && t.key === Os ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === Os && this._triggerBackdropTransition();\n    }) : d.off(this._element, $s);\n  }\n  _setResizeEvent() {\n    this._isShown ? d.on(window, Ss, () => this._adjustDialog()) : d.off(window, Ss);\n  }\n  _hideModal() {\n    const t = h.findOne(Ut, this._element);\n    t.classList.remove(this._classes.show), t.classList.remove(\"opacity-100\"), t.classList.add(\"opacity-0\");\n    const e = Je(t);\n    setTimeout(() => {\n      this._element.style.display = \"none\";\n    }, e), this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._backdrop.hide(() => {\n      document.body.removeAttribute(Rs), this._resetAdjustments(), this._scrollBar.reset(), d.trigger(this._element, Vl);\n    });\n  }\n  _showBackdrop(t) {\n    d.on(this._element, Ls, (e) => {\n      if (this._ignoreBackdropClick) {\n        this._ignoreBackdropClick = !1;\n        return;\n      }\n      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === \"static\" && this._triggerBackdropTransition());\n    }), this._backdrop.show(t);\n  }\n  _isAnimated() {\n    return !!h.findOne(Ut, this._element);\n  }\n  _triggerBackdropTransition() {\n    if (d.trigger(this._element, Hl).defaultPrevented)\n      return;\n    const { classList: e, scrollHeight: s, style: n } = this._element, r = s > document.documentElement.clientHeight;\n    if (!r && n.overflowY === \"hidden\" || e.contains(this._classes.static))\n      return;\n    r || (n.overflowY = \"hidden\"), e.add(...this._classes.static.split(\" \")), e.add(...this._classes.staticProperties.split(\" \"));\n    const o = Je(this._element);\n    this._queueCallback(() => {\n      e.remove(this._classes.static), setTimeout(() => {\n        e.remove(...this._classes.staticProperties.split(\" \"));\n      }, o), r || this._queueCallback(() => {\n        n.overflowY = \"\";\n      }, this._dialog);\n    }, this._dialog), this._element.focus();\n  }\n  _getConfig(t) {\n    return t = {\n      ...Ds,\n      ...E.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, R(Qe, t, Ns), t;\n  }\n  _getClasses(t) {\n    const e = E.getDataClassAttributes(this._element);\n    return t = {\n      ...kl,\n      ...e,\n      ...t\n    }, R(Qe, t, Pl), t;\n  }\n  // ----------------------------------------------------------------------\n  // the following methods are used to handle overflowing modals\n  // ----------------------------------------------------------------------\n  _adjustDialog() {\n    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0;\n    (!s && t && !M() || s && !t && M()) && (this._element.style.paddingLeft = `${e}px`), (s && !t && !M() || !s && t && M()) && (this._element.style.paddingRight = `${e}px`);\n  }\n  _resetAdjustments() {\n    this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n  }\n  // Static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      const s = ai.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof s[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        s[t](e);\n      }\n    });\n  }\n}\nconst Fl = (i, t) => {\n  d.on(\n    document,\n    `click.twe.${i.NAME}`,\n    t,\n    function(e) {\n      e.preventDefault(), i.getOrCreateInstance(this).toggle();\n    }\n  );\n}, Yl = (i, t) => {\n  d.on(\n    document,\n    `click.twe.${i.NAME}.data-api`,\n    t,\n    function(e) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), gt(this))\n        return;\n      i.getOrCreateInstance(this).show();\n    }\n  );\n}, Kl = (i, t) => {\n  d.on(\n    document,\n    `click.twe.${i.NAME}.data-api`,\n    t,\n    function(e) {\n      const s = nt(this);\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), gt(this))\n        return;\n      d.one(s, i.EVENT_HIDDEN, () => {\n        kt(this) && this.focus();\n      });\n      const n = h.findOne(i.OPEN_SELECTOR);\n      n && n !== s && i.getInstance(n).hide(), i.getOrCreateInstance(s).toggle(this);\n    }\n  );\n}, zl = (i, t) => {\n  d.on(\n    document,\n    `click.twe.${i.NAME}`,\n    t,\n    (e) => {\n      e.preventDefault();\n      const s = e.target.closest(t);\n      i.getOrCreateInstance(s).toggle();\n    }\n  );\n}, ql = (i, t) => {\n  d.one(\n    document,\n    \"mousedown\",\n    t,\n    i.autoInitial(new i())\n  );\n}, Xl = (i, t) => {\n  d.on(\n    document,\n    `click.twe.${i.NAME}.data-api`,\n    t,\n    function(e) {\n      (e.target.tagName === \"A\" || e.delegateTarget && e.delegateTarget.tagName === \"A\") && e.preventDefault();\n      const s = ci(this);\n      h.find(s).forEach((r) => {\n        i.getOrCreateInstance(r, { toggle: !1 }).toggle();\n      });\n    }\n  );\n}, Gl = (i, t) => {\n  [].slice.call(\n    document.querySelectorAll(t)\n  ).map(function(s) {\n    return new i(s);\n  });\n}, Ql = (i, t) => {\n  [].slice.call(\n    document.querySelectorAll(t)\n  ).map(function(s) {\n    return new i(s);\n  });\n}, Zl = (i, t) => {\n  d.on(\n    document,\n    `click.twe.${i.NAME}`,\n    t,\n    function(e) {\n      const s = nt(this);\n      [\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), d.one(s, i.EVENT_SHOW, (o) => {\n        o.defaultPrevented || d.one(s, i.EVENT_HIDDEN, () => {\n          kt(this) && this.focus();\n        });\n      });\n      const n = h.findOne(\n        `[${i.OPEN_SELECTOR}=\"true\"]`\n      );\n      n && i.getInstance(n).hide(), i.getOrCreateInstance(s).toggle(this);\n    }\n  );\n}, Jl = {\n  carousel: {\n    name: \"Carousel\",\n    selector: \"[data-twe-carousel-init]\",\n    isToggler: !1\n  },\n  input: {\n    name: \"Input\",\n    selector: \"[data-twe-input-wrapper-init]\",\n    isToggler: !1\n  },\n  scrollspy: {\n    name: \"ScrollSpy\",\n    selector: \"[data-twe-spy='scroll']\",\n    isToggler: !1\n  },\n  // togglers\n  button: {\n    name: \"Button\",\n    selector: \"[data-twe-toggle='button']\",\n    isToggler: !0,\n    callback: zl\n  },\n  collapse: {\n    name: \"Collapse\",\n    selector: \"[data-twe-collapse-init]\",\n    isToggler: !0,\n    callback: Xl\n  },\n  dropdown: {\n    name: \"Dropdown\",\n    selector: \"[data-twe-dropdown-toggle-ref]\",\n    isToggler: !0,\n    callback: Fl\n  },\n  ripple: {\n    name: \"Ripple\",\n    selector: \"[data-twe-ripple-init]\",\n    isToggler: !0,\n    callback: ql\n  },\n  offcanvas: {\n    name: \"Offcanvas\",\n    selector: \"[data-twe-offcanvas-toggle]\",\n    isToggler: !0,\n    callback: Kl\n  },\n  tab: {\n    name: \"Tab\",\n    selector: \"[data-twe-toggle='tab'], [data-twe-toggle='pill'], [data-twe-toggle='list']\",\n    isToggler: !0,\n    callback: Yl\n  },\n  tooltip: {\n    name: \"Tooltip\",\n    selector: \"[data-twe-toggle='tooltip']\",\n    isToggler: !1,\n    callback: Gl\n  },\n  popover: {\n    name: \"Popover\",\n    selector: \"[data-twe-toggle='popover']\",\n    isToggler: !0,\n    callback: Ql\n  },\n  modal: {\n    name: \"Modal\",\n    selector: \"[data-twe-toggle='modal']\",\n    isToggler: !0,\n    callback: Zl\n  }\n}, tc = (i) => {\n  Vs(() => {\n    const t = Hs();\n    if (t) {\n      const e = i.NAME, s = t.fn[e];\n      t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = () => (t.fn[e] = s, i.jQueryInterface);\n    }\n  });\n};\nclass ec {\n  constructor() {\n    this.inits = [];\n  }\n  get initialized() {\n    return this.inits;\n  }\n  isInited(t) {\n    return this.inits.includes(t);\n  }\n  add(t) {\n    this.isInited(t) || this.inits.push(t);\n  }\n}\nconst li = new ec();\nlet Dt;\nconst ic = (i) => Dt[i.NAME] || null, sc = (i, t) => {\n  if (!i || !t.allowReinits && li.isInited(i.NAME))\n    return;\n  li.add(i.NAME);\n  const e = ic(i), s = (e == null ? void 0 : e.isToggler) || !1;\n  if (tc(i), e != null && e.advanced) {\n    e == null || e.advanced(i, e == null ? void 0 : e.selector);\n    return;\n  }\n  if (s) {\n    e == null || e.callback(i, e == null ? void 0 : e.selector);\n    return;\n  }\n  h.find(e == null ? void 0 : e.selector).forEach((n) => {\n    let r = i.getInstance(n);\n    r || (r = new i(n), e != null && e.onInit && r[e.onInit]());\n  });\n}, nc = {\n  allowReinits: !1,\n  checkOtherImports: !1\n};\nclass rc {\n  constructor(t) {\n    Ne(this, \"init\", (t, e) => {\n      t.forEach((s) => sc(s, e));\n    });\n    Ne(this, \"initTWE\", (t, e) => {\n      const s = { ...nc, ...e }, n = Object.keys(Dt).map((r) => {\n        if (!!document.querySelector(Dt[r].selector)) {\n          const a = t[Dt[r].name];\n          return !a && !li.isInited(r) && s.checkOtherImports && console.warn(\n            `Please import ${Dt[r].name} from \"tw-elements\" package and add it to a object parameter inside \"initTWE\" function`\n          ), a;\n        }\n      });\n      this.init(n, s);\n    });\n    Dt = t;\n  }\n}\nconst oc = new rc(Jl), lc = oc.initTWE;\n\n//# sourceMappingURL=tw-elements.es.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvanMvdHctZWxlbWVudHMuZXMubWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1RUFBdUUsRUFBRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxRQUFRLDRDQUE0QztBQUNwRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0IsWUFBWSxFQUFFLG1CQUFtQixFQUFFLHVCQUF1QixFQUFFO0FBQ3ZGO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0QsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxJQUFJLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxLQUFLLGlCQUFpQjtBQUNqRCw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0Q0FBNEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlDQUF5QyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2YscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCxHQUFHO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YSxHQUFHLGFBQWEsR0FBRztBQUNwZ0I7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFlRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3R3LWVsZW1lbnRzL2pzL3R3LWVsZW1lbnRzLmVzLm1pbi5qcz9kZTA4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBZbiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBLbiA9IChpLCB0LCBlKSA9PiB0IGluIGkgPyBZbihpLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogaVt0XSA9IGU7XG52YXIgTmUgPSAoaSwgdCwgZSkgPT4gKEtuKGksIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpLCBlKTtcbi8qIVxuKiBUVyBFbGVtZW50c1xuKiBWZXJzaW9uOiBGUkVFIDIuMC4wXG4qIFxuKiBDb3B5cmlnaHQ6IE1hdGVyaWFsIERlc2lnbiBmb3IgQm9vdHN0cmFwXG4qIGh0dHBzOi8vbWRib290c3RyYXAuY29tL1xuKiBcbiogUmVhZCB0aGUgbGljZW5zZTogaHR0cHM6Ly90dy1lbGVtZW50cy5jb20vbGljZW5zZS9cbipcbipcbiogRG9jdW1lbnRhdGlvbjogaHR0cHM6Ly90dy1lbGVtZW50cy5jb20vXG4qXG4qIFN1cHBvcnQ6IGh0dHBzOi8vbWRib290c3RyYXAuY29tL3N1cHBvcnQvY2F0L3R3ZVxuKlxuKiBDb250YWN0OiB0YWlsd2luZEBtZGJvb3RzdHJhcC5jb21cbiogXG4qL1xuY29uc3QgU2UgPSAoKCkgPT4ge1xuICBjb25zdCBpID0ge307XG4gIGxldCB0ID0gMTtcbiAgcmV0dXJuIHtcbiAgICBzZXQoZSwgcywgbikge1xuICAgICAgdHlwZW9mIGVbc10gPiBcInVcIiAmJiAoZVtzXSA9IHtcbiAgICAgICAga2V5OiBzLFxuICAgICAgICBpZDogdFxuICAgICAgfSwgdCsrKSwgaVtlW3NdLmlkXSA9IG47XG4gICAgfSxcbiAgICBnZXQoZSwgcykge1xuICAgICAgaWYgKCFlIHx8IHR5cGVvZiBlW3NdID4gXCJ1XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbiA9IGVbc107XG4gICAgICByZXR1cm4gbi5rZXkgPT09IHMgPyBpW24uaWRdIDogbnVsbDtcbiAgICB9LFxuICAgIGRlbGV0ZShlLCBzKSB7XG4gICAgICBpZiAodHlwZW9mIGVbc10gPiBcInVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbiA9IGVbc107XG4gICAgICBuLmtleSA9PT0gcyAmJiAoZGVsZXRlIGlbbi5pZF0sIGRlbGV0ZSBlW3NdKTtcbiAgICB9XG4gIH07XG59KSgpLCBWID0ge1xuICBzZXREYXRhKGksIHQsIGUpIHtcbiAgICBTZS5zZXQoaSwgdCwgZSk7XG4gIH0sXG4gIGdldERhdGEoaSwgdCkge1xuICAgIHJldHVybiBTZS5nZXQoaSwgdCk7XG4gIH0sXG4gIHJlbW92ZURhdGEoaSwgdCkge1xuICAgIFNlLmRlbGV0ZShpLCB0KTtcbiAgfVxufSwgem4gPSAxZTYsIHFuID0gMWUzLCBaZSA9IFwidHJhbnNpdGlvbmVuZFwiLCBYbiA9IChpKSA9PiBpID09IG51bGwgPyBgJHtpfWAgOiB7fS50b1N0cmluZy5jYWxsKGkpLm1hdGNoKC9cXHMoW2Etel0rKS9pKVsxXS50b0xvd2VyQ2FzZSgpLCBHbiA9IChpKSA9PiB7XG4gIGRvXG4gICAgaSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB6bik7XG4gIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpKSk7XG4gIHJldHVybiBpO1xufSwga3MgPSAoaSkgPT4ge1xuICBsZXQgdCA9IGkuZ2V0QXR0cmlidXRlKFwiZGF0YS10d2UtdGFyZ2V0XCIpO1xuICBpZiAoIXQgfHwgdCA9PT0gXCIjXCIpIHtcbiAgICBsZXQgZSA9IGkuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBpZiAoIWUgfHwgIWUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIuXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIiNcIikgJiYgKGUgPSBgIyR7ZS5zcGxpdChcIiNcIilbMV19YCksIHQgPSBlICYmIGUgIT09IFwiI1wiID8gZS50cmltKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB0O1xufSwgY2kgPSAoaSkgPT4ge1xuICBjb25zdCB0ID0ga3MoaSk7XG4gIHJldHVybiB0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgPyB0IDogbnVsbDtcbn0sIG50ID0gKGkpID0+IHtcbiAgY29uc3QgdCA9IGtzKGkpO1xuICByZXR1cm4gdCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiBudWxsO1xufSwgSmUgPSAoaSkgPT4ge1xuICBpZiAoIWkpXG4gICAgcmV0dXJuIDA7XG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbjogdCwgdHJhbnNpdGlvbkRlbGF5OiBlIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpKTtcbiAgY29uc3QgcyA9IE51bWJlci5wYXJzZUZsb2F0KHQpLCBuID0gTnVtYmVyLnBhcnNlRmxvYXQoZSk7XG4gIHJldHVybiAhcyAmJiAhbiA/IDAgOiAodCA9IHQuc3BsaXQoXCIsXCIpWzBdLCBlID0gZS5zcGxpdChcIixcIilbMF0sIChOdW1iZXIucGFyc2VGbG9hdCh0KSArIE51bWJlci5wYXJzZUZsb2F0KGUpKSAqIHFuKTtcbn0sIFBzID0gKGkpID0+IHtcbiAgaS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChaZSkpO1xufSwgU3QgPSAoaSkgPT4gIWkgfHwgdHlwZW9mIGkgIT0gXCJvYmplY3RcIiA/ICExIDogKHR5cGVvZiBpLmpxdWVyeSA8IFwidVwiICYmIChpID0gaVswXSksIHR5cGVvZiBpLm5vZGVUeXBlIDwgXCJ1XCIpLCBydCA9IChpKSA9PiBTdChpKSA/IGkuanF1ZXJ5ID8gaVswXSA6IGkgOiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIGkubGVuZ3RoID4gMCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaSkgOiBudWxsLCBSID0gKGksIHQsIGUpID0+IHtcbiAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGNvbnN0IG4gPSBlW3NdLCByID0gdFtzXSwgbyA9IHIgJiYgU3QocikgPyBcImVsZW1lbnRcIiA6IFhuKHIpO1xuICAgIGlmICghbmV3IFJlZ0V4cChuKS50ZXN0KG8pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtpLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke3N9XCIgcHJvdmlkZWQgdHlwZSBcIiR7b31cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7bn1cIi5gXG4gICAgICApO1xuICB9KTtcbn0sIGt0ID0gKGkpID0+IHtcbiAgaWYgKCFpKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKGkuc3R5bGUgJiYgaS5wYXJlbnROb2RlICYmIGkucGFyZW50Tm9kZS5zdHlsZSkge1xuICAgIGNvbnN0IHQgPSBnZXRDb21wdXRlZFN0eWxlKGkpLCBlID0gZ2V0Q29tcHV0ZWRTdHlsZShpLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiB0LmRpc3BsYXkgIT09IFwibm9uZVwiICYmIGUuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgdC52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiO1xuICB9XG4gIHJldHVybiAhMTtcbn0sIGd0ID0gKGkpID0+ICFpIHx8IGkubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8IGkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikgPyAhMCA6IHR5cGVvZiBpLmRpc2FibGVkIDwgXCJ1XCIgPyBpLmRpc2FibGVkIDogaS5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiBpLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpICE9PSBcImZhbHNlXCIsIE1zID0gKGkpID0+IHtcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIGkuZ2V0Um9vdE5vZGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdCA9IGkuZ2V0Um9vdE5vZGUoKTtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyB0IDogbnVsbDtcbiAgfVxuICByZXR1cm4gaSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBpIDogaS5wYXJlbnROb2RlID8gTXMoaS5wYXJlbnROb2RlKSA6IG51bGw7XG59LCBtZSA9ICgpID0+IGZ1bmN0aW9uKCkge1xufSwgWHQgPSAoaSkgPT4ge1xuICBpLm9mZnNldEhlaWdodDtcbn0sIEhzID0gKCkgPT4ge1xuICBjb25zdCB7IGpRdWVyeTogaSB9ID0gd2luZG93O1xuICByZXR1cm4gaSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1uby1qcXVlcnlcIikgPyBpIDogbnVsbDtcbn0sIExlID0gW10sIFZzID0gKGkpID0+IHtcbiAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIgPyAoTGUubGVuZ3RoIHx8IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICBMZS5mb3JFYWNoKCh0KSA9PiB0KCkpO1xuICB9KSwgTGUucHVzaChpKSkgOiBpKCk7XG59LCBNID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gXCJydGxcIiwgRnQgPSAoaSkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpKSwgX3QgPSAoaSkgPT4ge1xuICB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgJiYgaSgpO1xufSwgV3MgPSAoaSwgdCwgZSA9ICEwKSA9PiB7XG4gIGlmICghZSkge1xuICAgIF90KGkpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzID0gNSwgbiA9IEplKHQpICsgcztcbiAgbGV0IHIgPSAhMTtcbiAgY29uc3QgbyA9ICh7IHRhcmdldDogYSB9KSA9PiB7XG4gICAgYSA9PT0gdCAmJiAociA9ICEwLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoWmUsIG8pLCBfdChpKSk7XG4gIH07XG4gIHQuYWRkRXZlbnRMaXN0ZW5lcihaZSwgbyksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHIgfHwgUHModCk7XG4gIH0sIG4pO1xufSwgQnMgPSAoaSwgdCwgZSwgcykgPT4ge1xuICBsZXQgbiA9IGkuaW5kZXhPZih0KTtcbiAgaWYgKG4gPT09IC0xKVxuICAgIHJldHVybiBpWyFlICYmIHMgPyBpLmxlbmd0aCAtIDEgOiAwXTtcbiAgY29uc3QgciA9IGkubGVuZ3RoO1xuICByZXR1cm4gbiArPSBlID8gMSA6IC0xLCBzICYmIChuID0gKG4gKyByKSAlIHIpLCBpW01hdGgubWF4KDAsIE1hdGgubWluKG4sIHIgLSAxKSldO1xufSwgUW4gPSAvW14uXSooPz1cXC4uKilcXC58LiovLCBabiA9IC9cXC4uKi8sIEpuID0gLzo6XFxkKyQvLCAkZSA9IHt9O1xubGV0IGtpID0gMTtcbmNvbnN0IHRyID0ge1xuICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIGVyID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pLCBqcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwibW91c2V1cFwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2V3aGVlbFwiLFxuICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gIFwibW91c2VvdmVyXCIsXG4gIFwibW91c2VvdXRcIixcbiAgXCJtb3VzZW1vdmVcIixcbiAgXCJzZWxlY3RzdGFydFwiLFxuICBcInNlbGVjdGVuZFwiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcImtleXVwXCIsXG4gIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcInBvaW50ZXJkb3duXCIsXG4gIFwicG9pbnRlcm1vdmVcIixcbiAgXCJwb2ludGVydXBcIixcbiAgXCJwb2ludGVybGVhdmVcIixcbiAgXCJwb2ludGVyY2FuY2VsXCIsXG4gIFwiZ2VzdHVyZXN0YXJ0XCIsXG4gIFwiZ2VzdHVyZWNoYW5nZVwiLFxuICBcImdlc3R1cmVlbmRcIixcbiAgXCJmb2N1c1wiLFxuICBcImJsdXJcIixcbiAgXCJjaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInNlbGVjdFwiLFxuICBcInN1Ym1pdFwiLFxuICBcImZvY3VzaW5cIixcbiAgXCJmb2N1c291dFwiLFxuICBcImxvYWRcIixcbiAgXCJ1bmxvYWRcIixcbiAgXCJiZWZvcmV1bmxvYWRcIixcbiAgXCJyZXNpemVcIixcbiAgXCJtb3ZlXCIsXG4gIFwiRE9NQ29udGVudExvYWRlZFwiLFxuICBcInJlYWR5c3RhdGVjaGFuZ2VcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCIsXG4gIFwic2Nyb2xsXCJcbl0pO1xuZnVuY3Rpb24gVXMoaSwgdCkge1xuICByZXR1cm4gdCAmJiBgJHt0fTo6JHtraSsrfWAgfHwgaS51aWRFdmVudCB8fCBraSsrO1xufVxuZnVuY3Rpb24gRnMoaSkge1xuICBjb25zdCB0ID0gVXMoaSk7XG4gIHJldHVybiBpLnVpZEV2ZW50ID0gdCwgJGVbdF0gPSAkZVt0XSB8fCB7fSwgJGVbdF07XG59XG5mdW5jdGlvbiBpcihpLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKHMpIHtcbiAgICByZXR1cm4gcy5kZWxlZ2F0ZVRhcmdldCA9IGksIGUub25lT2ZmICYmIGQub2ZmKGksIHMudHlwZSwgdCksIHQuYXBwbHkoaSwgW3NdKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNyKGksIHQsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHMobikge1xuICAgIGNvbnN0IHIgPSBpLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gICAgZm9yIChsZXQgeyB0YXJnZXQ6IG8gfSA9IG47IG8gJiYgbyAhPT0gdGhpczsgbyA9IG8ucGFyZW50Tm9kZSlcbiAgICAgIGZvciAobGV0IGEgPSByLmxlbmd0aDsgYS0tOyBcIlwiKVxuICAgICAgICBpZiAoclthXSA9PT0gbylcbiAgICAgICAgICByZXR1cm4gbi5kZWxlZ2F0ZVRhcmdldCA9IG8sIHMub25lT2ZmICYmIGQub2ZmKGksIG4udHlwZSwgZSksIGUuYXBwbHkobywgW25dKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIFlzKGksIHQsIGUgPSBudWxsKSB7XG4gIGNvbnN0IHMgPSBPYmplY3Qua2V5cyhpKTtcbiAgZm9yIChsZXQgbiA9IDAsIHIgPSBzLmxlbmd0aDsgbiA8IHI7IG4rKykge1xuICAgIGNvbnN0IG8gPSBpW3Nbbl1dO1xuICAgIGlmIChvLm9yaWdpbmFsSGFuZGxlciA9PT0gdCAmJiBvLmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZSlcbiAgICAgIHJldHVybiBvO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gS3MoaSwgdCwgZSkge1xuICBjb25zdCBzID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiwgbiA9IHMgPyBlIDogdDtcbiAgbGV0IHIgPSB6cyhpKTtcbiAgcmV0dXJuIGpzLmhhcyhyKSB8fCAociA9IGkpLCBbcywgbiwgcl07XG59XG5mdW5jdGlvbiBQaShpLCB0LCBlLCBzLCBuKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFpKVxuICAgIHJldHVybjtcbiAgaWYgKGUgfHwgKGUgPSBzLCBzID0gbnVsbCksIGVyLnRlc3QodCkpIHtcbiAgICBjb25zdCBnID0gKE8pID0+IGZ1bmN0aW9uKFQpIHtcbiAgICAgIGlmICghVC5yZWxhdGVkVGFyZ2V0IHx8IFQucmVsYXRlZFRhcmdldCAhPT0gVC5kZWxlZ2F0ZVRhcmdldCAmJiAhVC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhULnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICByZXR1cm4gTy5jYWxsKHRoaXMsIFQpO1xuICAgIH07XG4gICAgcyA/IHMgPSBnKHMpIDogZSA9IGcoZSk7XG4gIH1cbiAgY29uc3QgW3IsIG8sIGFdID0gS3MoXG4gICAgdCxcbiAgICBlLFxuICAgIHNcbiAgKSwgbCA9IEZzKGkpLCB1ID0gbFthXSB8fCAobFthXSA9IHt9KSwgYyA9IFlzKFxuICAgIHUsXG4gICAgbyxcbiAgICByID8gZSA6IG51bGxcbiAgKTtcbiAgaWYgKGMpIHtcbiAgICBjLm9uZU9mZiA9IGMub25lT2ZmICYmIG47XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGYgPSBVcyhcbiAgICBvLFxuICAgIHQucmVwbGFjZShRbiwgXCJcIilcbiAgKSwgdiA9IHIgPyBzcihpLCBlLCBzKSA6IGlyKGksIGUpO1xuICB2LmRlbGVnYXRpb25TZWxlY3RvciA9IHIgPyBlIDogbnVsbCwgdi5vcmlnaW5hbEhhbmRsZXIgPSBvLCB2Lm9uZU9mZiA9IG4sIHYudWlkRXZlbnQgPSBmLCB1W2ZdID0gdiwgaS5hZGRFdmVudExpc3RlbmVyKGEsIHYsIHIpO1xufVxuZnVuY3Rpb24gdGkoaSwgdCwgZSwgcywgbikge1xuICBjb25zdCByID0gWXModFtlXSwgcywgbik7XG4gIHIgJiYgKGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCByLCAhIW4pLCBkZWxldGUgdFtlXVtyLnVpZEV2ZW50XSk7XG59XG5mdW5jdGlvbiBucihpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSB0W2VdIHx8IHt9O1xuICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgaWYgKHIuaW5jbHVkZXMocykpIHtcbiAgICAgIGNvbnN0IG8gPSBuW3JdO1xuICAgICAgdGkoXG4gICAgICAgIGksXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIG8ub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICBvLmRlbGVnYXRpb25TZWxlY3RvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24genMoaSkge1xuICByZXR1cm4gaSA9IGkucmVwbGFjZShabiwgXCJcIiksIHRyW2ldIHx8IGk7XG59XG5jb25zdCBkID0ge1xuICBvbihpLCB0LCBlLCBzKSB7XG4gICAgUGkoaSwgdCwgZSwgcywgITEpO1xuICB9LFxuICBvbmUoaSwgdCwgZSwgcykge1xuICAgIFBpKGksIHQsIGUsIHMsICEwKTtcbiAgfSxcbiAgb2ZmKGksIHQsIGUsIHMpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhaSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbbiwgciwgb10gPSBLcyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgc1xuICAgICksIGEgPSBvICE9PSB0LCBsID0gRnMoaSksIHUgPSB0LnN0YXJ0c1dpdGgoXCIuXCIpO1xuICAgIGlmICh0eXBlb2YgciA8IFwidVwiKSB7XG4gICAgICBpZiAoIWwgfHwgIWxbb10pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRpKFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBvLFxuICAgICAgICByLFxuICAgICAgICBuID8gZSA6IG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHUgJiYgT2JqZWN0LmtleXMobCkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgbnIoXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGYsXG4gICAgICAgIHQuc2xpY2UoMSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgYyA9IGxbb10gfHwge307XG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgY29uc3QgdiA9IGYucmVwbGFjZShKbiwgXCJcIik7XG4gICAgICBpZiAoIWEgfHwgdC5pbmNsdWRlcyh2KSkge1xuICAgICAgICBjb25zdCBnID0gY1tmXTtcbiAgICAgICAgdGkoXG4gICAgICAgICAgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgZy5vcmlnaW5hbEhhbmRsZXIsXG4gICAgICAgICAgZy5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdHJpZ2dlcihpLCB0LCBlKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIWkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBzID0gSHMoKSwgbiA9IHpzKHQpLCByID0gdCAhPT0gbiwgbyA9IGpzLmhhcyhuKTtcbiAgICBsZXQgYSwgbCA9ICEwLCB1ID0gITAsIGMgPSAhMSwgZiA9IG51bGw7XG4gICAgcmV0dXJuIHIgJiYgcyAmJiAoYSA9IHMuRXZlbnQodCwgZSksIHMoaSkudHJpZ2dlcihhKSwgbCA9ICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCksIHUgPSAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpLCBjID0gYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSksIG8gPyAoZiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSwgZi5pbml0RXZlbnQobiwgbCwgITApKSA6IGYgPSBuZXcgQ3VzdG9tRXZlbnQodCwge1xuICAgICAgYnViYmxlczogbCxcbiAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgfSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIHYsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBlW3ZdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgYyAmJiBmLnByZXZlbnREZWZhdWx0KCksIHUgJiYgaS5kaXNwYXRjaEV2ZW50KGYpLCBmLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGEgPCBcInVcIiAmJiBhLnByZXZlbnREZWZhdWx0KCksIGY7XG4gIH1cbn0sIHJyID0gXCI1LjEuM1wiO1xuY2xhc3MgdHQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdCA9IHJ0KHQpLCB0ICYmICh0aGlzLl9lbGVtZW50ID0gdCwgVi5zZXREYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIFYucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKSwgZC5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzW3RdID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICBfcXVldWVDYWxsYmFjayh0LCBlLCBzID0gITApIHtcbiAgICBXcyh0LCBlLCBzKTtcbiAgfVxuICAvKiogU3RhdGljICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIFYuZ2V0RGF0YShydCh0KSwgdGhpcy5EQVRBX0tFWSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIHJyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJ1xuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gYHR3ZS4ke3RoaXMuTkFNRX1gO1xuICB9XG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICB9XG59XG5jb25zdCBvciA9IFwiYnV0dG9uXCIsIGFyID0gXCJhY3RpdmVcIjtcbmNsYXNzIHFzIGV4dGVuZHMgdHQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gb3I7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1wcmVzc2VkXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoYXIpXG4gICAgKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBxcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgdCA9PT0gXCJ0b2dnbGVcIiAmJiBlW3RdKCk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBrID0gXCJ0b3BcIiwgVyA9IFwiYm90dG9tXCIsIEIgPSBcInJpZ2h0XCIsIFAgPSBcImxlZnRcIiwgdmUgPSBcImF1dG9cIiwgUHQgPSBbaywgVywgQiwgUF0sIEV0ID0gXCJzdGFydFwiLCBMdCA9IFwiZW5kXCIsIFhzID0gXCJjbGlwcGluZ1BhcmVudHNcIiwgZGkgPSBcInZpZXdwb3J0XCIsIEN0ID0gXCJwb3BwZXJcIiwgR3MgPSBcInJlZmVyZW5jZVwiLCBlaSA9IC8qIEBfX1BVUkVfXyAqLyBQdC5yZWR1Y2UoZnVuY3Rpb24oaSwgdCkge1xuICByZXR1cm4gaS5jb25jYXQoW3QgKyBcIi1cIiArIEV0LCB0ICsgXCItXCIgKyBMdF0pO1xufSwgW10pLCB1aSA9IC8qIEBfX1BVUkVfXyAqLyBbXS5jb25jYXQoUHQsIFt2ZV0pLnJlZHVjZShmdW5jdGlvbihpLCB0KSB7XG4gIHJldHVybiBpLmNvbmNhdChbdCwgdCArIFwiLVwiICsgRXQsIHQgKyBcIi1cIiArIEx0XSk7XG59LCBbXSksIFFzID0gXCJiZWZvcmVSZWFkXCIsIFpzID0gXCJyZWFkXCIsIEpzID0gXCJhZnRlclJlYWRcIiwgdG4gPSBcImJlZm9yZU1haW5cIiwgZW4gPSBcIm1haW5cIiwgc24gPSBcImFmdGVyTWFpblwiLCBubiA9IFwiYmVmb3JlV3JpdGVcIiwgcm4gPSBcIndyaXRlXCIsIG9uID0gXCJhZnRlcldyaXRlXCIsIGFuID0gW1FzLCBacywgSnMsIHRuLCBlbiwgc24sIG5uLCBybiwgb25dO1xuZnVuY3Rpb24gUShpKSB7XG4gIHJldHVybiBpID8gKGkubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5mdW5jdGlvbiBqKGkpIHtcbiAgaWYgKGkgPT0gbnVsbClcbiAgICByZXR1cm4gd2luZG93O1xuICBpZiAoaS50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XG4gICAgdmFyIHQgPSBpLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIHQgJiYgdC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB2dChpKSB7XG4gIHZhciB0ID0gaihpKS5FbGVtZW50O1xuICByZXR1cm4gaSBpbnN0YW5jZW9mIHQgfHwgaSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBGKGkpIHtcbiAgdmFyIHQgPSBqKGkpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gaSBpbnN0YW5jZW9mIHQgfHwgaSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaGkoaSkge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gaihpKS5TaGFkb3dSb290O1xuICByZXR1cm4gaSBpbnN0YW5jZW9mIHQgfHwgaSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBscihpKSB7XG4gIHZhciB0ID0gaS5zdGF0ZTtcbiAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgdmFyIHMgPSB0LnN0eWxlc1tlXSB8fCB7fSwgbiA9IHQuYXR0cmlidXRlc1tlXSB8fCB7fSwgciA9IHQuZWxlbWVudHNbZV07XG4gICAgIUYocikgfHwgIVEocikgfHwgKE9iamVjdC5hc3NpZ24oci5zdHlsZSwgcyksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgdmFyIGEgPSBuW29dO1xuICAgICAgYSA9PT0gITEgPyByLnJlbW92ZUF0dHJpYnV0ZShvKSA6IHIuc2V0QXR0cmlidXRlKG8sIGEgPT09ICEwID8gXCJcIiA6IGEpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcihpKSB7XG4gIHZhciB0ID0gaS5zdGF0ZSwgZSA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBtYXJnaW46IFwiMFwiXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgZS5wb3BwZXIpLCB0LnN0eWxlcyA9IGUsIHQuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLCBlLmFycm93KSwgZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgbiA9IHQuZWxlbWVudHNbc10sIHIgPSB0LmF0dHJpYnV0ZXNbc10gfHwge30sIG8gPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzKSA/IHQuc3R5bGVzW3NdIDogZVtzXSksIGEgPSBvLnJlZHVjZShmdW5jdGlvbihsLCB1KSB7XG4gICAgICAgIHJldHVybiBsW3VdID0gXCJcIiwgbDtcbiAgICAgIH0sIHt9KTtcbiAgICAgICFGKG4pIHx8ICFRKG4pIHx8IChPYmplY3QuYXNzaWduKG4uc3R5bGUsIGEpLCBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUobCk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG59XG5jb25zdCBmaSA9IHtcbiAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IGxyLFxuICBlZmZlY3Q6IGNyLFxuICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXVxufTtcbmZ1bmN0aW9uIEcoaSkge1xuICByZXR1cm4gaS5zcGxpdChcIi1cIilbMF07XG59XG52YXIgbXQgPSBNYXRoLm1heCwgRWUgPSBNYXRoLm1pbiwgJHQgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gaWkoKSB7XG4gIHZhciBpID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHJldHVybiBpICE9IG51bGwgJiYgaS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheShpLmJyYW5kcykgPyBpLmJyYW5kcy5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIGxuKCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoaWkoKSk7XG59XG5mdW5jdGlvbiBJdChpLCB0LCBlKSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgcyA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSAxLCByID0gMTtcbiAgdCAmJiBGKGkpICYmIChuID0gaS5vZmZzZXRXaWR0aCA+IDAgJiYgJHQocy53aWR0aCkgLyBpLm9mZnNldFdpZHRoIHx8IDEsIHIgPSBpLm9mZnNldEhlaWdodCA+IDAgJiYgJHQocy5oZWlnaHQpIC8gaS5vZmZzZXRIZWlnaHQgfHwgMSk7XG4gIHZhciBvID0gdnQoaSkgPyBqKGkpIDogd2luZG93LCBhID0gby52aXN1YWxWaWV3cG9ydCwgbCA9ICFsbigpICYmIGUsIHUgPSAocy5sZWZ0ICsgKGwgJiYgYSA/IGEub2Zmc2V0TGVmdCA6IDApKSAvIG4sIGMgPSAocy50b3AgKyAobCAmJiBhID8gYS5vZmZzZXRUb3AgOiAwKSkgLyByLCBmID0gcy53aWR0aCAvIG4sIHYgPSBzLmhlaWdodCAvIHI7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGYsXG4gICAgaGVpZ2h0OiB2LFxuICAgIHRvcDogYyxcbiAgICByaWdodDogdSArIGYsXG4gICAgYm90dG9tOiBjICsgdixcbiAgICBsZWZ0OiB1LFxuICAgIHg6IHUsXG4gICAgeTogY1xuICB9O1xufVxuZnVuY3Rpb24gcGkoaSkge1xuICB2YXIgdCA9IEl0KGkpLCBlID0gaS5vZmZzZXRXaWR0aCwgcyA9IGkub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4gTWF0aC5hYnModC53aWR0aCAtIGUpIDw9IDEgJiYgKGUgPSB0LndpZHRoKSwgTWF0aC5hYnModC5oZWlnaHQgLSBzKSA8PSAxICYmIChzID0gdC5oZWlnaHQpLCB7XG4gICAgeDogaS5vZmZzZXRMZWZ0LFxuICAgIHk6IGkub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlLFxuICAgIGhlaWdodDogc1xuICB9O1xufVxuZnVuY3Rpb24gY24oaSwgdCkge1xuICB2YXIgZSA9IHQuZ2V0Um9vdE5vZGUgJiYgdC5nZXRSb290Tm9kZSgpO1xuICBpZiAoaS5jb250YWlucyh0KSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChlICYmIGhpKGUpKSB7XG4gICAgdmFyIHMgPSB0O1xuICAgIGRvIHtcbiAgICAgIGlmIChzICYmIGkuaXNTYW1lTm9kZShzKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcyA9IHMucGFyZW50Tm9kZSB8fCBzLmhvc3Q7XG4gICAgfSB3aGlsZSAocyk7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gSihpKSB7XG4gIHJldHVybiBqKGkpLmdldENvbXB1dGVkU3R5bGUoaSk7XG59XG5mdW5jdGlvbiBkcihpKSB7XG4gIHJldHVybiBbXCJ0YWJsZVwiLCBcInRkXCIsIFwidGhcIl0uaW5kZXhPZihRKGkpKSA+PSAwO1xufVxuZnVuY3Rpb24gb3QoaSkge1xuICByZXR1cm4gKCh2dChpKSA/IGkub3duZXJEb2N1bWVudCA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBpLmRvY3VtZW50XG4gICkpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gYmUoaSkge1xuICByZXR1cm4gUShpKSA9PT0gXCJodG1sXCIgPyBpIDogKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGkuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgaS5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKGhpKGkpID8gaS5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBvdChpKVxuICApO1xufVxuZnVuY3Rpb24gTWkoaSkge1xuICByZXR1cm4gIUYoaSkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgSihpKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gbnVsbCA6IGkub2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gdXIoaSkge1xuICB2YXIgdCA9IC9maXJlZm94L2kudGVzdChpaSgpKSwgZSA9IC9UcmlkZW50L2kudGVzdChpaSgpKTtcbiAgaWYgKGUgJiYgRihpKSkge1xuICAgIHZhciBzID0gSihpKTtcbiAgICBpZiAocy5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG4gPSBiZShpKTtcbiAgZm9yIChoaShuKSAmJiAobiA9IG4uaG9zdCk7IEYobikgJiYgW1wiaHRtbFwiLCBcImJvZHlcIl0uaW5kZXhPZihRKG4pKSA8IDA7ICkge1xuICAgIHZhciByID0gSihuKTtcbiAgICBpZiAoci50cmFuc2Zvcm0gIT09IFwibm9uZVwiIHx8IHIucGVyc3BlY3RpdmUgIT09IFwibm9uZVwiIHx8IHIuY29udGFpbiA9PT0gXCJwYWludFwiIHx8IFtcInRyYW5zZm9ybVwiLCBcInBlcnNwZWN0aXZlXCJdLmluZGV4T2Yoci53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgdCAmJiByLndpbGxDaGFuZ2UgPT09IFwiZmlsdGVyXCIgfHwgdCAmJiByLmZpbHRlciAmJiByLmZpbHRlciAhPT0gXCJub25lXCIpXG4gICAgICByZXR1cm4gbjtcbiAgICBuID0gbi5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gR3QoaSkge1xuICBmb3IgKHZhciB0ID0gaihpKSwgZSA9IE1pKGkpOyBlICYmIGRyKGUpICYmIEooZSkucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcbiAgICBlID0gTWkoZSk7XG4gIHJldHVybiBlICYmIChRKGUpID09PSBcImh0bWxcIiB8fCBRKGUpID09PSBcImJvZHlcIiAmJiBKKGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSA/IHQgOiBlIHx8IHVyKGkpIHx8IHQ7XG59XG5mdW5jdGlvbiBfaShpKSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5kZXhPZihpKSA+PSAwID8gXCJ4XCIgOiBcInlcIjtcbn1cbmZ1bmN0aW9uIHp0KGksIHQsIGUpIHtcbiAgcmV0dXJuIG10KGksIEVlKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIGhyKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB6dChpLCB0LCBlKTtcbiAgcmV0dXJuIHMgPiBlID8gZSA6IHM7XG59XG5mdW5jdGlvbiBkbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVuKGkpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRuKCksIGkpO1xufVxuZnVuY3Rpb24gaG4oaSwgdCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oZSwgcykge1xuICAgIHJldHVybiBlW3NdID0gaSwgZTtcbiAgfSwge30pO1xufVxudmFyIGZyID0gZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoT2JqZWN0LmFzc2lnbih7fSwgZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogZS5wbGFjZW1lbnRcbiAgfSkpIDogdCwgdW4odHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBobih0LCBQdCkpO1xufTtcbmZ1bmN0aW9uIHByKGkpIHtcbiAgdmFyIHQsIGUgPSBpLnN0YXRlLCBzID0gaS5uYW1lLCBuID0gaS5vcHRpb25zLCByID0gZS5lbGVtZW50cy5hcnJvdywgbyA9IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBhID0gRyhlLnBsYWNlbWVudCksIGwgPSBfaShhKSwgdSA9IFtQLCBCXS5pbmRleE9mKGEpID49IDAsIGMgPSB1ID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIXIgfHwgIW8pKSB7XG4gICAgdmFyIGYgPSBmcihuLnBhZGRpbmcsIGUpLCB2ID0gcGkociksIGcgPSBsID09PSBcInlcIiA/IGsgOiBQLCBPID0gbCA9PT0gXCJ5XCIgPyBXIDogQiwgVCA9IGUucmVjdHMucmVmZXJlbmNlW2NdICsgZS5yZWN0cy5yZWZlcmVuY2VbbF0gLSBvW2xdIC0gZS5yZWN0cy5wb3BwZXJbY10sIEEgPSBvW2xdIC0gZS5yZWN0cy5yZWZlcmVuY2VbbF0sIEQgPSBHdChyKSwgTCA9IEQgPyBsID09PSBcInlcIiA/IEQuY2xpZW50SGVpZ2h0IHx8IDAgOiBELmNsaWVudFdpZHRoIHx8IDAgOiAwLCBtID0gVCAvIDIgLSBBIC8gMiwgcCA9IGZbZ10sIF8gPSBMIC0gdltjXSAtIGZbT10sIGIgPSBMIC8gMiAtIHZbY10gLyAyICsgbSwgdyA9IHp0KHAsIGIsIF8pLCBDID0gbDtcbiAgICBlLm1vZGlmaWVyc0RhdGFbc10gPSAodCA9IHt9LCB0W0NdID0gdywgdC5jZW50ZXJPZmZzZXQgPSB3IC0gYiwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9yKGkpIHtcbiAgdmFyIHQgPSBpLnN0YXRlLCBlID0gaS5vcHRpb25zLCBzID0gZS5lbGVtZW50LCBuID0gcyA9PT0gdm9pZCAwID8gXCJbZGF0YS1wb3BwZXItYXJyb3ddXCIgOiBzO1xuICBuICE9IG51bGwgJiYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKG4gPSB0LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKG4pLCAhbikgfHwgY24odC5lbGVtZW50cy5wb3BwZXIsIG4pICYmICh0LmVsZW1lbnRzLmFycm93ID0gbikpO1xufVxuY29uc3QgZm4gPSB7XG4gIG5hbWU6IFwiYXJyb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHByLFxuICBlZmZlY3Q6IF9yLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdXG59O1xuZnVuY3Rpb24gUnQoaSkge1xuICByZXR1cm4gaS5zcGxpdChcIi1cIilbMV07XG59XG52YXIgZ3IgPSB7XG4gIHRvcDogXCJhdXRvXCIsXG4gIHJpZ2h0OiBcImF1dG9cIixcbiAgYm90dG9tOiBcImF1dG9cIixcbiAgbGVmdDogXCJhdXRvXCJcbn07XG5mdW5jdGlvbiBtcihpLCB0KSB7XG4gIHZhciBlID0gaS54LCBzID0gaS55LCBuID0gdC5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogJHQoZSAqIG4pIC8gbiB8fCAwLFxuICAgIHk6ICR0KHMgKiBuKSAvIG4gfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gSGkoaSkge1xuICB2YXIgdCwgZSA9IGkucG9wcGVyLCBzID0gaS5wb3BwZXJSZWN0LCBuID0gaS5wbGFjZW1lbnQsIHIgPSBpLnZhcmlhdGlvbiwgbyA9IGkub2Zmc2V0cywgYSA9IGkucG9zaXRpb24sIGwgPSBpLmdwdUFjY2VsZXJhdGlvbiwgdSA9IGkuYWRhcHRpdmUsIGMgPSBpLnJvdW5kT2Zmc2V0cywgZiA9IGkuaXNGaXhlZCwgdiA9IG8ueCwgZyA9IHYgPT09IHZvaWQgMCA/IDAgOiB2LCBPID0gby55LCBUID0gTyA9PT0gdm9pZCAwID8gMCA6IE8sIEEgPSB0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIgPyBjKHtcbiAgICB4OiBnLFxuICAgIHk6IFRcbiAgfSkgOiB7XG4gICAgeDogZyxcbiAgICB5OiBUXG4gIH07XG4gIGcgPSBBLngsIFQgPSBBLnk7XG4gIHZhciBEID0gby5oYXNPd25Qcm9wZXJ0eShcInhcIiksIEwgPSBvLmhhc093blByb3BlcnR5KFwieVwiKSwgbSA9IFAsIHAgPSBrLCBfID0gd2luZG93O1xuICBpZiAodSkge1xuICAgIHZhciBiID0gR3QoZSksIHcgPSBcImNsaWVudEhlaWdodFwiLCBDID0gXCJjbGllbnRXaWR0aFwiO1xuICAgIGlmIChiID09PSBqKGUpICYmIChiID0gb3QoZSksIEooYikucG9zaXRpb24gIT09IFwic3RhdGljXCIgJiYgYSA9PT0gXCJhYnNvbHV0ZVwiICYmICh3ID0gXCJzY3JvbGxIZWlnaHRcIiwgQyA9IFwic2Nyb2xsV2lkdGhcIikpLCBiID0gYiwgbiA9PT0gayB8fCAobiA9PT0gUCB8fCBuID09PSBCKSAmJiByID09PSBMdCkge1xuICAgICAgcCA9IFc7XG4gICAgICB2YXIgeSA9IGYgJiYgYiA9PT0gXyAmJiBfLnZpc3VhbFZpZXdwb3J0ID8gXy52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBiW3ddXG4gICAgICApO1xuICAgICAgVCAtPSB5IC0gcy5oZWlnaHQsIFQgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG4gPT09IFAgfHwgKG4gPT09IGsgfHwgbiA9PT0gVykgJiYgciA9PT0gTHQpIHtcbiAgICAgIG0gPSBCO1xuICAgICAgdmFyIE4gPSBmICYmIGIgPT09IF8gJiYgXy52aXN1YWxWaWV3cG9ydCA/IF8udmlzdWFsVmlld3BvcnQud2lkdGggOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBiW0NdXG4gICAgICApO1xuICAgICAgZyAtPSBOIC0gcy53aWR0aCwgZyAqPSBsID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuICB2YXIgUyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBhXG4gIH0sIHUgJiYgZ3IpLCB4ID0gYyA9PT0gITAgPyBtcih7XG4gICAgeDogZyxcbiAgICB5OiBUXG4gIH0sIGooZSkpIDoge1xuICAgIHg6IGcsXG4gICAgeTogVFxuICB9O1xuICBpZiAoZyA9IHgueCwgVCA9IHgueSwgbCkge1xuICAgIHZhciBJO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBTLCAoSSA9IHt9LCBJW3BdID0gTCA/IFwiMFwiIDogXCJcIiwgSVttXSA9IEQgPyBcIjBcIiA6IFwiXCIsIEkudHJhbnNmb3JtID0gKF8uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyBnICsgXCJweCwgXCIgKyBUICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyBnICsgXCJweCwgXCIgKyBUICsgXCJweCwgMClcIiwgSSkpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBTLCAodCA9IHt9LCB0W3BdID0gTCA/IFQgKyBcInB4XCIgOiBcIlwiLCB0W21dID0gRCA/IGcgKyBcInB4XCIgOiBcIlwiLCB0LnRyYW5zZm9ybSA9IFwiXCIsIHQpKTtcbn1cbmZ1bmN0aW9uIEVyKGkpIHtcbiAgdmFyIHQgPSBpLnN0YXRlLCBlID0gaS5vcHRpb25zLCBzID0gZS5ncHVBY2NlbGVyYXRpb24sIG4gPSBzID09PSB2b2lkIDAgPyAhMCA6IHMsIHIgPSBlLmFkYXB0aXZlLCBvID0gciA9PT0gdm9pZCAwID8gITAgOiByLCBhID0gZS5yb3VuZE9mZnNldHMsIGwgPSBhID09PSB2b2lkIDAgPyAhMCA6IGEsIHUgPSB7XG4gICAgcGxhY2VtZW50OiBHKHQucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IFJ0KHQucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHQuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogbixcbiAgICBpc0ZpeGVkOiB0Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIlxuICB9O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0LnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5wb3BwZXIsIEhpKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgIGFkYXB0aXZlOiBvLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIEhpKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBhZGFwdGl2ZTogITEsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3QgZ2kgPSB7XG4gIG5hbWU6IFwiY29tcHV0ZVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgZm46IEVyLFxuICBkYXRhOiB7fVxufTtcbnZhciBzZSA9IHtcbiAgcGFzc2l2ZTogITBcbn07XG5mdW5jdGlvbiB2cihpKSB7XG4gIHZhciB0ID0gaS5zdGF0ZSwgZSA9IGkuaW5zdGFuY2UsIHMgPSBpLm9wdGlvbnMsIG4gPSBzLnNjcm9sbCwgciA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgbyA9IHMucmVzaXplLCBhID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBsID0gaih0LmVsZW1lbnRzLnBvcHBlciksIHUgPSBbXS5jb25jYXQodC5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgdC5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG4gIHJldHVybiByICYmIHUuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgYy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUudXBkYXRlLCBzZSk7XG4gIH0pLCBhICYmIGwuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlLnVwZGF0ZSwgc2UpLCBmdW5jdGlvbigpIHtcbiAgICByICYmIHUuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS51cGRhdGUsIHNlKTtcbiAgICB9KSwgYSAmJiBsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIHNlKTtcbiAgfTtcbn1cbmNvbnN0IG1pID0ge1xuICBuYW1lOiBcImV2ZW50TGlzdGVuZXJzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogZnVuY3Rpb24oKSB7XG4gIH0sXG4gIGVmZmVjdDogdnIsXG4gIGRhdGE6IHt9XG59O1xudmFyIGJyID0ge1xuICBsZWZ0OiBcInJpZ2h0XCIsXG4gIHJpZ2h0OiBcImxlZnRcIixcbiAgYm90dG9tOiBcInRvcFwiLFxuICB0b3A6IFwiYm90dG9tXCJcbn07XG5mdW5jdGlvbiB1ZShpKSB7XG4gIHJldHVybiBpLnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGJyW3RdO1xuICB9KTtcbn1cbnZhciB3ciA9IHtcbiAgc3RhcnQ6IFwiZW5kXCIsXG4gIGVuZDogXCJzdGFydFwiXG59O1xuZnVuY3Rpb24gVmkoaSkge1xuICByZXR1cm4gaS5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB3clt0XTtcbiAgfSk7XG59XG5mdW5jdGlvbiBFaShpKSB7XG4gIHZhciB0ID0gaihpKSwgZSA9IHQucGFnZVhPZmZzZXQsIHMgPSB0LnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGUsXG4gICAgc2Nyb2xsVG9wOiBzXG4gIH07XG59XG5mdW5jdGlvbiB2aShpKSB7XG4gIHJldHVybiBJdChvdChpKSkubGVmdCArIEVpKGkpLnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBUcihpLCB0KSB7XG4gIHZhciBlID0gaihpKSwgcyA9IG90KGkpLCBuID0gZS52aXN1YWxWaWV3cG9ydCwgciA9IHMuY2xpZW50V2lkdGgsIG8gPSBzLmNsaWVudEhlaWdodCwgYSA9IDAsIGwgPSAwO1xuICBpZiAobikge1xuICAgIHIgPSBuLndpZHRoLCBvID0gbi5oZWlnaHQ7XG4gICAgdmFyIHUgPSBsbigpO1xuICAgICh1IHx8ICF1ICYmIHQgPT09IFwiZml4ZWRcIikgJiYgKGEgPSBuLm9mZnNldExlZnQsIGwgPSBuLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IG8sXG4gICAgeDogYSArIHZpKGkpLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHlyKGkpIHtcbiAgdmFyIHQsIGUgPSBvdChpKSwgcyA9IEVpKGkpLCBuID0gKHQgPSBpLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmJvZHksIHIgPSBtdChlLnNjcm9sbFdpZHRoLCBlLmNsaWVudFdpZHRoLCBuID8gbi5zY3JvbGxXaWR0aCA6IDAsIG4gPyBuLmNsaWVudFdpZHRoIDogMCksIG8gPSBtdChlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIG4gPyBuLnNjcm9sbEhlaWdodCA6IDAsIG4gPyBuLmNsaWVudEhlaWdodCA6IDApLCBhID0gLXMuc2Nyb2xsTGVmdCArIHZpKGkpLCBsID0gLXMuc2Nyb2xsVG9wO1xuICByZXR1cm4gSihuIHx8IGUpLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAoYSArPSBtdChlLmNsaWVudFdpZHRoLCBuID8gbi5jbGllbnRXaWR0aCA6IDApIC0gciksIHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IG8sXG4gICAgeDogYSxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiBiaShpKSB7XG4gIHZhciB0ID0gSihpKSwgZSA9IHQub3ZlcmZsb3csIHMgPSB0Lm92ZXJmbG93WCwgbiA9IHQub3ZlcmZsb3dZO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KGUgKyBuICsgcyk7XG59XG5mdW5jdGlvbiBwbihpKSB7XG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmRleE9mKFEoaSkpID49IDAgPyBpLm93bmVyRG9jdW1lbnQuYm9keSA6IEYoaSkgJiYgYmkoaSkgPyBpIDogcG4oYmUoaSkpO1xufVxuZnVuY3Rpb24gcXQoaSwgdCkge1xuICB2YXIgZTtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gW10pO1xuICB2YXIgcyA9IHBuKGkpLCBuID0gcyA9PT0gKChlID0gaS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogZS5ib2R5KSwgciA9IGoocyksIG8gPSBuID8gW3JdLmNvbmNhdChyLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBiaShzKSA/IHMgOiBbXSkgOiBzLCBhID0gdC5jb25jYXQobyk7XG4gIHJldHVybiBuID8gYSA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICBhLmNvbmNhdChxdChiZShvKSkpXG4gICk7XG59XG5mdW5jdGlvbiBzaShpKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpLCB7XG4gICAgbGVmdDogaS54LFxuICAgIHRvcDogaS55LFxuICAgIHJpZ2h0OiBpLnggKyBpLndpZHRoLFxuICAgIGJvdHRvbTogaS55ICsgaS5oZWlnaHRcbiAgfSk7XG59XG5mdW5jdGlvbiBBcihpLCB0KSB7XG4gIHZhciBlID0gSXQoaSwgITEsIHQgPT09IFwiZml4ZWRcIik7XG4gIHJldHVybiBlLnRvcCA9IGUudG9wICsgaS5jbGllbnRUb3AsIGUubGVmdCA9IGUubGVmdCArIGkuY2xpZW50TGVmdCwgZS5ib3R0b20gPSBlLnRvcCArIGkuY2xpZW50SGVpZ2h0LCBlLnJpZ2h0ID0gZS5sZWZ0ICsgaS5jbGllbnRXaWR0aCwgZS53aWR0aCA9IGkuY2xpZW50V2lkdGgsIGUuaGVpZ2h0ID0gaS5jbGllbnRIZWlnaHQsIGUueCA9IGUubGVmdCwgZS55ID0gZS50b3AsIGU7XG59XG5mdW5jdGlvbiBXaShpLCB0LCBlKSB7XG4gIHJldHVybiB0ID09PSBkaSA/IHNpKFRyKGksIGUpKSA6IHZ0KHQpID8gQXIodCwgZSkgOiBzaSh5cihvdChpKSkpO1xufVxuZnVuY3Rpb24gQ3IoaSkge1xuICB2YXIgdCA9IHF0KGJlKGkpKSwgZSA9IFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5kZXhPZihKKGkpLnBvc2l0aW9uKSA+PSAwLCBzID0gZSAmJiBGKGkpID8gR3QoaSkgOiBpO1xuICByZXR1cm4gdnQocykgPyB0LmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHZ0KG4pICYmIGNuKG4sIHMpICYmIFEobikgIT09IFwiYm9keVwiO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gT3IoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQgPT09IFwiY2xpcHBpbmdQYXJlbnRzXCIgPyBDcihpKSA6IFtdLmNvbmNhdCh0KSwgciA9IFtdLmNvbmNhdChuLCBbZV0pLCBvID0gclswXSwgYSA9IHIucmVkdWNlKGZ1bmN0aW9uKGwsIHUpIHtcbiAgICB2YXIgYyA9IFdpKGksIHUsIHMpO1xuICAgIHJldHVybiBsLnRvcCA9IG10KGMudG9wLCBsLnRvcCksIGwucmlnaHQgPSBFZShjLnJpZ2h0LCBsLnJpZ2h0KSwgbC5ib3R0b20gPSBFZShjLmJvdHRvbSwgbC5ib3R0b20pLCBsLmxlZnQgPSBtdChjLmxlZnQsIGwubGVmdCksIGw7XG4gIH0sIFdpKGksIG8sIHMpKTtcbiAgcmV0dXJuIGEud2lkdGggPSBhLnJpZ2h0IC0gYS5sZWZ0LCBhLmhlaWdodCA9IGEuYm90dG9tIC0gYS50b3AsIGEueCA9IGEubGVmdCwgYS55ID0gYS50b3AsIGE7XG59XG5mdW5jdGlvbiBfbihpKSB7XG4gIHZhciB0ID0gaS5yZWZlcmVuY2UsIGUgPSBpLmVsZW1lbnQsIHMgPSBpLnBsYWNlbWVudCwgbiA9IHMgPyBHKHMpIDogbnVsbCwgciA9IHMgPyBSdChzKSA6IG51bGwsIG8gPSB0LnggKyB0LndpZHRoIC8gMiAtIGUud2lkdGggLyAyLCBhID0gdC55ICsgdC5oZWlnaHQgLyAyIC0gZS5oZWlnaHQgLyAyLCBsO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIGs6XG4gICAgICBsID0ge1xuICAgICAgICB4OiBvLFxuICAgICAgICB5OiB0LnkgLSBlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVzpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IG8sXG4gICAgICAgIHk6IHQueSArIHQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCOlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCAtIGUud2lkdGgsXG4gICAgICAgIHk6IGFcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54LFxuICAgICAgICB5OiB0LnlcbiAgICAgIH07XG4gIH1cbiAgdmFyIHUgPSBuID8gX2kobikgOiBudWxsO1xuICBpZiAodSAhPSBudWxsKSB7XG4gICAgdmFyIGMgPSB1ID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gICAgc3dpdGNoIChyKSB7XG4gICAgICBjYXNlIEV0OlxuICAgICAgICBsW3VdID0gbFt1XSAtICh0W2NdIC8gMiAtIGVbY10gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEx0OlxuICAgICAgICBsW3VdID0gbFt1XSArICh0W2NdIC8gMiAtIGVbY10gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24geHQoaSwgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgcyA9IGUucGxhY2VtZW50LCBuID0gcyA9PT0gdm9pZCAwID8gaS5wbGFjZW1lbnQgOiBzLCByID0gZS5zdHJhdGVneSwgbyA9IHIgPT09IHZvaWQgMCA/IGkuc3RyYXRlZ3kgOiByLCBhID0gZS5ib3VuZGFyeSwgbCA9IGEgPT09IHZvaWQgMCA/IFhzIDogYSwgdSA9IGUucm9vdEJvdW5kYXJ5LCBjID0gdSA9PT0gdm9pZCAwID8gZGkgOiB1LCBmID0gZS5lbGVtZW50Q29udGV4dCwgdiA9IGYgPT09IHZvaWQgMCA/IEN0IDogZiwgZyA9IGUuYWx0Qm91bmRhcnksIE8gPSBnID09PSB2b2lkIDAgPyAhMSA6IGcsIFQgPSBlLnBhZGRpbmcsIEEgPSBUID09PSB2b2lkIDAgPyAwIDogVCwgRCA9IHVuKHR5cGVvZiBBICE9IFwibnVtYmVyXCIgPyBBIDogaG4oQSwgUHQpKSwgTCA9IHYgPT09IEN0ID8gR3MgOiBDdCwgbSA9IGkucmVjdHMucG9wcGVyLCBwID0gaS5lbGVtZW50c1tPID8gTCA6IHZdLCBfID0gT3IodnQocCkgPyBwIDogcC5jb250ZXh0RWxlbWVudCB8fCBvdChpLmVsZW1lbnRzLnBvcHBlciksIGwsIGMsIG8pLCBiID0gSXQoaS5lbGVtZW50cy5yZWZlcmVuY2UpLCB3ID0gX24oe1xuICAgIHJlZmVyZW5jZTogYixcbiAgICBlbGVtZW50OiBtLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiBuXG4gIH0pLCBDID0gc2koT2JqZWN0LmFzc2lnbih7fSwgbSwgdykpLCB5ID0gdiA9PT0gQ3QgPyBDIDogYiwgTiA9IHtcbiAgICB0b3A6IF8udG9wIC0geS50b3AgKyBELnRvcCxcbiAgICBib3R0b206IHkuYm90dG9tIC0gXy5ib3R0b20gKyBELmJvdHRvbSxcbiAgICBsZWZ0OiBfLmxlZnQgLSB5LmxlZnQgKyBELmxlZnQsXG4gICAgcmlnaHQ6IHkucmlnaHQgLSBfLnJpZ2h0ICsgRC5yaWdodFxuICB9LCBTID0gaS5tb2RpZmllcnNEYXRhLm9mZnNldDtcbiAgaWYgKHYgPT09IEN0ICYmIFMpIHtcbiAgICB2YXIgeCA9IFNbbl07XG4gICAgT2JqZWN0LmtleXMoTikuZm9yRWFjaChmdW5jdGlvbihJKSB7XG4gICAgICB2YXIgYXQgPSBbQiwgV10uaW5kZXhPZihJKSA+PSAwID8gMSA6IC0xLCBsdCA9IFtrLCBXXS5pbmRleE9mKEkpID49IDAgPyBcInlcIiA6IFwieFwiO1xuICAgICAgTltJXSArPSB4W2x0XSAqIGF0O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBOO1xufVxuZnVuY3Rpb24gRHIoaSwgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgcyA9IGUucGxhY2VtZW50LCBuID0gZS5ib3VuZGFyeSwgciA9IGUucm9vdEJvdW5kYXJ5LCBvID0gZS5wYWRkaW5nLCBhID0gZS5mbGlwVmFyaWF0aW9ucywgbCA9IGUuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCB1ID0gbCA9PT0gdm9pZCAwID8gdWkgOiBsLCBjID0gUnQocyksIGYgPSBjID8gYSA/IGVpIDogZWkuZmlsdGVyKGZ1bmN0aW9uKE8pIHtcbiAgICByZXR1cm4gUnQoTykgPT09IGM7XG4gIH0pIDogUHQsIHYgPSBmLmZpbHRlcihmdW5jdGlvbihPKSB7XG4gICAgcmV0dXJuIHUuaW5kZXhPZihPKSA+PSAwO1xuICB9KTtcbiAgdi5sZW5ndGggPT09IDAgJiYgKHYgPSBmKTtcbiAgdmFyIGcgPSB2LnJlZHVjZShmdW5jdGlvbihPLCBUKSB7XG4gICAgcmV0dXJuIE9bVF0gPSB4dChpLCB7XG4gICAgICBwbGFjZW1lbnQ6IFQsXG4gICAgICBib3VuZGFyeTogbixcbiAgICAgIHJvb3RCb3VuZGFyeTogcixcbiAgICAgIHBhZGRpbmc6IG9cbiAgICB9KVtHKFQpXSwgTztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZykuc29ydChmdW5jdGlvbihPLCBUKSB7XG4gICAgcmV0dXJuIGdbT10gLSBnW1RdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE5yKGkpIHtcbiAgaWYgKEcoaSkgPT09IHZlKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHQgPSB1ZShpKTtcbiAgcmV0dXJuIFtWaShpKSwgdCwgVmkodCldO1xufVxuZnVuY3Rpb24gU3IoaSkge1xuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm9wdGlvbnMsIHMgPSBpLm5hbWU7XG4gIGlmICghdC5tb2RpZmllcnNEYXRhW3NdLl9za2lwKSB7XG4gICAgZm9yICh2YXIgbiA9IGUubWFpbkF4aXMsIHIgPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIG8gPSBlLmFsdEF4aXMsIGEgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIGwgPSBlLmZhbGxiYWNrUGxhY2VtZW50cywgdSA9IGUucGFkZGluZywgYyA9IGUuYm91bmRhcnksIGYgPSBlLnJvb3RCb3VuZGFyeSwgdiA9IGUuYWx0Qm91bmRhcnksIGcgPSBlLmZsaXBWYXJpYXRpb25zLCBPID0gZyA9PT0gdm9pZCAwID8gITAgOiBnLCBUID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIEEgPSB0Lm9wdGlvbnMucGxhY2VtZW50LCBEID0gRyhBKSwgTCA9IEQgPT09IEEsIG0gPSBsIHx8IChMIHx8ICFPID8gW3VlKEEpXSA6IE5yKEEpKSwgcCA9IFtBXS5jb25jYXQobSkucmVkdWNlKGZ1bmN0aW9uKHd0LCBldCkge1xuICAgICAgcmV0dXJuIHd0LmNvbmNhdChHKGV0KSA9PT0gdmUgPyBEcih0LCB7XG4gICAgICAgIHBsYWNlbWVudDogZXQsXG4gICAgICAgIGJvdW5kYXJ5OiBjLFxuICAgICAgICByb290Qm91bmRhcnk6IGYsXG4gICAgICAgIHBhZGRpbmc6IHUsXG4gICAgICAgIGZsaXBWYXJpYXRpb25zOiBPLFxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IFRcbiAgICAgIH0pIDogZXQpO1xuICAgIH0sIFtdKSwgXyA9IHQucmVjdHMucmVmZXJlbmNlLCBiID0gdC5yZWN0cy5wb3BwZXIsIHcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBDID0gITAsIHkgPSBwWzBdLCBOID0gMDsgTiA8IHAubGVuZ3RoOyBOKyspIHtcbiAgICAgIHZhciBTID0gcFtOXSwgeCA9IEcoUyksIEkgPSBSdChTKSA9PT0gRXQsIGF0ID0gW2ssIFddLmluZGV4T2YoeCkgPj0gMCwgbHQgPSBhdCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIEggPSB4dCh0LCB7XG4gICAgICAgIHBsYWNlbWVudDogUyxcbiAgICAgICAgYm91bmRhcnk6IGMsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogZixcbiAgICAgICAgYWx0Qm91bmRhcnk6IHYsXG4gICAgICAgIHBhZGRpbmc6IHVcbiAgICAgIH0pLCBZID0gYXQgPyBJID8gQiA6IFAgOiBJID8gVyA6IGs7XG4gICAgICBfW2x0XSA+IGJbbHRdICYmIChZID0gdWUoWSkpO1xuICAgICAgdmFyIFp0ID0gdWUoWSksIGN0ID0gW107XG4gICAgICBpZiAociAmJiBjdC5wdXNoKEhbeF0gPD0gMCksIGEgJiYgY3QucHVzaChIW1ldIDw9IDAsIEhbWnRdIDw9IDApLCBjdC5ldmVyeShmdW5jdGlvbih3dCkge1xuICAgICAgICByZXR1cm4gd3Q7XG4gICAgICB9KSkge1xuICAgICAgICB5ID0gUywgQyA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHcuc2V0KFMsIGN0KTtcbiAgICB9XG4gICAgaWYgKEMpXG4gICAgICBmb3IgKHZhciBKdCA9IE8gPyAzIDogMSwgQWUgPSBmdW5jdGlvbihldCkge1xuICAgICAgICB2YXIgVnQgPSBwLmZpbmQoZnVuY3Rpb24oZWUpIHtcbiAgICAgICAgICB2YXIgZHQgPSB3LmdldChlZSk7XG4gICAgICAgICAgaWYgKGR0KVxuICAgICAgICAgICAgcmV0dXJuIGR0LnNsaWNlKDAsIGV0KS5ldmVyeShmdW5jdGlvbihDZSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChWdClcbiAgICAgICAgICByZXR1cm4geSA9IFZ0LCBcImJyZWFrXCI7XG4gICAgICB9LCBIdCA9IEp0OyBIdCA+IDA7IEh0LS0pIHtcbiAgICAgICAgdmFyIHRlID0gQWUoSHQpO1xuICAgICAgICBpZiAodGUgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB0LnBsYWNlbWVudCAhPT0geSAmJiAodC5tb2RpZmllcnNEYXRhW3NdLl9za2lwID0gITAsIHQucGxhY2VtZW50ID0geSwgdC5yZXNldCA9ICEwKTtcbiAgfVxufVxuY29uc3QgZ24gPSB7XG4gIG5hbWU6IFwiZmxpcFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogU3IsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiAhMVxuICB9XG59O1xuZnVuY3Rpb24gQmkoaSwgdCwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9KSwge1xuICAgIHRvcDogaS50b3AgLSB0LmhlaWdodCAtIGUueSxcbiAgICByaWdodDogaS5yaWdodCAtIHQud2lkdGggKyBlLngsXG4gICAgYm90dG9tOiBpLmJvdHRvbSAtIHQuaGVpZ2h0ICsgZS55LFxuICAgIGxlZnQ6IGkubGVmdCAtIHQud2lkdGggLSBlLnhcbiAgfTtcbn1cbmZ1bmN0aW9uIGppKGkpIHtcbiAgcmV0dXJuIFtrLCBCLCBXLCBQXS5zb21lKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gaVt0XSA+PSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIExyKGkpIHtcbiAgdmFyIHQgPSBpLnN0YXRlLCBlID0gaS5uYW1lLCBzID0gdC5yZWN0cy5yZWZlcmVuY2UsIG4gPSB0LnJlY3RzLnBvcHBlciwgciA9IHQubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3csIG8gPSB4dCh0LCB7XG4gICAgZWxlbWVudENvbnRleHQ6IFwicmVmZXJlbmNlXCJcbiAgfSksIGEgPSB4dCh0LCB7XG4gICAgYWx0Qm91bmRhcnk6ICEwXG4gIH0pLCBsID0gQmkobywgcyksIHUgPSBCaShhLCBuLCByKSwgYyA9IGppKGwpLCBmID0gamkodSk7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IGwsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogdSxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogYyxcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBmXG4gIH0sIHQuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgXCJkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXCI6IGMsXG4gICAgXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6IGZcbiAgfSk7XG59XG5jb25zdCBtbiA9IHtcbiAgbmFtZTogXCJoaWRlXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXSxcbiAgZm46IExyXG59O1xuZnVuY3Rpb24gJHIoaSwgdCwgZSkge1xuICB2YXIgcyA9IEcoaSksIG4gPSBbUCwga10uaW5kZXhPZihzKSA+PSAwID8gLTEgOiAxLCByID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XG4gICAgcGxhY2VtZW50OiBpXG4gIH0pKSA6IGUsIG8gPSByWzBdLCBhID0gclsxXTtcbiAgcmV0dXJuIG8gPSBvIHx8IDAsIGEgPSAoYSB8fCAwKSAqIG4sIFtQLCBCXS5pbmRleE9mKHMpID49IDAgPyB7XG4gICAgeDogYSxcbiAgICB5OiBvXG4gIH0gOiB7XG4gICAgeDogbyxcbiAgICB5OiBhXG4gIH07XG59XG5mdW5jdGlvbiBJcihpKSB7XG4gIHZhciB0ID0gaS5zdGF0ZSwgZSA9IGkub3B0aW9ucywgcyA9IGkubmFtZSwgbiA9IGUub2Zmc2V0LCByID0gbiA9PT0gdm9pZCAwID8gWzAsIDBdIDogbiwgbyA9IHVpLnJlZHVjZShmdW5jdGlvbihjLCBmKSB7XG4gICAgcmV0dXJuIGNbZl0gPSAkcihmLCB0LnJlY3RzLCByKSwgYztcbiAgfSwge30pLCBhID0gb1t0LnBsYWNlbWVudF0sIGwgPSBhLngsIHUgPSBhLnk7XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0gbCwgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB1KSwgdC5tb2RpZmllcnNEYXRhW3NdID0gbztcbn1cbmNvbnN0IEVuID0ge1xuICBuYW1lOiBcIm9mZnNldFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgZm46IElyXG59O1xuZnVuY3Rpb24gUnIoaSkge1xuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm5hbWU7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IF9uKHtcbiAgICByZWZlcmVuY2U6IHQucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHQucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IHdpID0ge1xuICBuYW1lOiBcInBvcHBlck9mZnNldHNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcInJlYWRcIixcbiAgZm46IFJyLFxuICBkYXRhOiB7fVxufTtcbmZ1bmN0aW9uIHhyKGkpIHtcbiAgcmV0dXJuIGkgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIGtyKGkpIHtcbiAgdmFyIHQgPSBpLnN0YXRlLCBlID0gaS5vcHRpb25zLCBzID0gaS5uYW1lLCBuID0gZS5tYWluQXhpcywgciA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgbyA9IGUuYWx0QXhpcywgYSA9IG8gPT09IHZvaWQgMCA/ICExIDogbywgbCA9IGUuYm91bmRhcnksIHUgPSBlLnJvb3RCb3VuZGFyeSwgYyA9IGUuYWx0Qm91bmRhcnksIGYgPSBlLnBhZGRpbmcsIHYgPSBlLnRldGhlciwgZyA9IHYgPT09IHZvaWQgMCA/ICEwIDogdiwgTyA9IGUudGV0aGVyT2Zmc2V0LCBUID0gTyA9PT0gdm9pZCAwID8gMCA6IE8sIEEgPSB4dCh0LCB7XG4gICAgYm91bmRhcnk6IGwsXG4gICAgcm9vdEJvdW5kYXJ5OiB1LFxuICAgIHBhZGRpbmc6IGYsXG4gICAgYWx0Qm91bmRhcnk6IGNcbiAgfSksIEQgPSBHKHQucGxhY2VtZW50KSwgTCA9IFJ0KHQucGxhY2VtZW50KSwgbSA9ICFMLCBwID0gX2koRCksIF8gPSB4cihwKSwgYiA9IHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCB3ID0gdC5yZWN0cy5yZWZlcmVuY2UsIEMgPSB0LnJlY3RzLnBvcHBlciwgeSA9IHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIiA/IFQoT2JqZWN0LmFzc2lnbih7fSwgdC5yZWN0cywge1xuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSkpIDogVCwgTiA9IHR5cGVvZiB5ID09IFwibnVtYmVyXCIgPyB7XG4gICAgbWFpbkF4aXM6IHksXG4gICAgYWx0QXhpczogeVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB5KSwgUyA9IHQubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0W3QucGxhY2VtZW50XSA6IG51bGwsIHggPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGlmIChiKSB7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBJLCBhdCA9IHAgPT09IFwieVwiID8gayA6IFAsIGx0ID0gcCA9PT0gXCJ5XCIgPyBXIDogQiwgSCA9IHAgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgWSA9IGJbcF0sIFp0ID0gWSArIEFbYXRdLCBjdCA9IFkgLSBBW2x0XSwgSnQgPSBnID8gLUNbSF0gLyAyIDogMCwgQWUgPSBMID09PSBFdCA/IHdbSF0gOiBDW0hdLCBIdCA9IEwgPT09IEV0ID8gLUNbSF0gOiAtd1tIXSwgdGUgPSB0LmVsZW1lbnRzLmFycm93LCB3dCA9IGcgJiYgdGUgPyBwaSh0ZSkgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIGV0ID0gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXSA/IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZyA6IGRuKCksIFZ0ID0gZXRbYXRdLCBlZSA9IGV0W2x0XSwgZHQgPSB6dCgwLCB3W0hdLCB3dFtIXSksIENlID0gbSA/IHdbSF0gLyAyIC0gSnQgLSBkdCAtIFZ0IC0gTi5tYWluQXhpcyA6IEFlIC0gZHQgLSBWdCAtIE4ubWFpbkF4aXMsIFZuID0gbSA/IC13W0hdIC8gMiArIEp0ICsgZHQgKyBlZSArIE4ubWFpbkF4aXMgOiBIdCArIGR0ICsgZWUgKyBOLm1haW5BeGlzLCBPZSA9IHQuZWxlbWVudHMuYXJyb3cgJiYgR3QodC5lbGVtZW50cy5hcnJvdyksIFduID0gT2UgPyBwID09PSBcInlcIiA/IE9lLmNsaWVudFRvcCB8fCAwIDogT2UuY2xpZW50TGVmdCB8fCAwIDogMCwgT2kgPSAoSSA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbcF0pICE9IG51bGwgPyBJIDogMCwgQm4gPSBZICsgQ2UgLSBPaSAtIFduLCBqbiA9IFkgKyBWbiAtIE9pLCBEaSA9IHp0KGcgPyBFZShadCwgQm4pIDogWnQsIFksIGcgPyBtdChjdCwgam4pIDogY3QpO1xuICAgICAgYltwXSA9IERpLCB4W3BdID0gRGkgLSBZO1xuICAgIH1cbiAgICBpZiAoYSkge1xuICAgICAgdmFyIE5pLCBVbiA9IHAgPT09IFwieFwiID8gayA6IFAsIEZuID0gcCA9PT0gXCJ4XCIgPyBXIDogQiwgdXQgPSBiW19dLCBpZSA9IF8gPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgU2kgPSB1dCArIEFbVW5dLCBMaSA9IHV0IC0gQVtGbl0sIERlID0gW2ssIFBdLmluZGV4T2YoRCkgIT09IC0xLCAkaSA9IChOaSA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbX10pICE9IG51bGwgPyBOaSA6IDAsIElpID0gRGUgPyBTaSA6IHV0IC0gd1tpZV0gLSBDW2llXSAtICRpICsgTi5hbHRBeGlzLCBSaSA9IERlID8gdXQgKyB3W2llXSArIENbaWVdIC0gJGkgLSBOLmFsdEF4aXMgOiBMaSwgeGkgPSBnICYmIERlID8gaHIoSWksIHV0LCBSaSkgOiB6dChnID8gSWkgOiBTaSwgdXQsIGcgPyBSaSA6IExpKTtcbiAgICAgIGJbX10gPSB4aSwgeFtfXSA9IHhpIC0gdXQ7XG4gICAgfVxuICAgIHQubW9kaWZpZXJzRGF0YVtzXSA9IHg7XG4gIH1cbn1cbmNvbnN0IHZuID0ge1xuICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjoga3IsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXVxufTtcbmZ1bmN0aW9uIFByKGkpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBpLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBpLnNjcm9sbFRvcFxuICB9O1xufVxuZnVuY3Rpb24gTXIoaSkge1xuICByZXR1cm4gaSA9PT0gaihpKSB8fCAhRihpKSA/IEVpKGkpIDogUHIoaSk7XG59XG5mdW5jdGlvbiBIcihpKSB7XG4gIHZhciB0ID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZSA9ICR0KHQud2lkdGgpIC8gaS5vZmZzZXRXaWR0aCB8fCAxLCBzID0gJHQodC5oZWlnaHQpIC8gaS5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIGUgIT09IDEgfHwgcyAhPT0gMTtcbn1cbmZ1bmN0aW9uIFZyKGksIHQsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgcyA9IEYodCksIG4gPSBGKHQpICYmIEhyKHQpLCByID0gb3QodCksIG8gPSBJdChpLCBuLCBlKSwgYSA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9LCBsID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICByZXR1cm4gKHMgfHwgIXMgJiYgIWUpICYmICgoUSh0KSAhPT0gXCJib2R5XCIgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gIGJpKHIpKSAmJiAoYSA9IE1yKHQpKSwgRih0KSA/IChsID0gSXQodCwgITApLCBsLnggKz0gdC5jbGllbnRMZWZ0LCBsLnkgKz0gdC5jbGllbnRUb3ApIDogciAmJiAobC54ID0gdmkocikpKSwge1xuICAgIHg6IG8ubGVmdCArIGEuc2Nyb2xsTGVmdCAtIGwueCxcbiAgICB5OiBvLnRvcCArIGEuc2Nyb2xsVG9wIC0gbC55LFxuICAgIHdpZHRoOiBvLndpZHRoLFxuICAgIGhlaWdodDogby5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIFdyKGkpIHtcbiAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgcyA9IFtdO1xuICBpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgIHQuc2V0KHIubmFtZSwgcik7XG4gIH0pO1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICBlLmFkZChyLm5hbWUpO1xuICAgIHZhciBvID0gW10uY29uY2F0KHIucmVxdWlyZXMgfHwgW10sIHIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgby5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmICghZS5oYXMoYSkpIHtcbiAgICAgICAgdmFyIGwgPSB0LmdldChhKTtcbiAgICAgICAgbCAmJiBuKGwpO1xuICAgICAgfVxuICAgIH0pLCBzLnB1c2gocik7XG4gIH1cbiAgcmV0dXJuIGkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgZS5oYXMoci5uYW1lKSB8fCBuKHIpO1xuICB9KSwgcztcbn1cbmZ1bmN0aW9uIEJyKGkpIHtcbiAgdmFyIHQgPSBXcihpKTtcbiAgcmV0dXJuIGFuLnJlZHVjZShmdW5jdGlvbihlLCBzKSB7XG4gICAgcmV0dXJuIGUuY29uY2F0KHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBuLnBoYXNlID09PSBzO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24ganIoaSkge1xuICB2YXIgdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0IHx8ICh0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24oZSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdCA9IHZvaWQgMCwgZShpKCkpO1xuICAgICAgfSk7XG4gICAgfSkpLCB0O1xuICB9O1xufVxuZnVuY3Rpb24gVXIoaSkge1xuICB2YXIgdCA9IGkucmVkdWNlKGZ1bmN0aW9uKGUsIHMpIHtcbiAgICB2YXIgbiA9IGVbcy5uYW1lXTtcbiAgICByZXR1cm4gZVtzLm5hbWVdID0gbiA/IE9iamVjdC5hc3NpZ24oe30sIG4sIHMsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG4ub3B0aW9ucywgcy5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIG4uZGF0YSwgcy5kYXRhKVxuICAgIH0pIDogcywgZTtcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdFtlXTtcbiAgfSk7XG59XG52YXIgVWkgPSB7XG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxufTtcbmZ1bmN0aW9uIEZpKCkge1xuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShpKSwgZSA9IDA7IGUgPCBpOyBlKyspXG4gICAgdFtlXSA9IGFyZ3VtZW50c1tlXTtcbiAgcmV0dXJuICF0LnNvbWUoZnVuY3Rpb24ocykge1xuICAgIHJldHVybiAhKHMgJiYgdHlwZW9mIHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09IFwiZnVuY3Rpb25cIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gd2UoaSkge1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSB7fSk7XG4gIHZhciB0ID0gaSwgZSA9IHQuZGVmYXVsdE1vZGlmaWVycywgcyA9IGUgPT09IHZvaWQgMCA/IFtdIDogZSwgbiA9IHQuZGVmYXVsdE9wdGlvbnMsIHIgPSBuID09PSB2b2lkIDAgPyBVaSA6IG47XG4gIHJldHVybiBmdW5jdGlvbihhLCBsLCB1KSB7XG4gICAgdSA9PT0gdm9pZCAwICYmICh1ID0gcik7XG4gICAgdmFyIGMgPSB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIFVpLCByKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiBhLFxuICAgICAgICBwb3BwZXI6IGxcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9LCBmID0gW10sIHYgPSAhMSwgZyA9IHtcbiAgICAgIHN0YXRlOiBjLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24oRCkge1xuICAgICAgICB2YXIgTCA9IHR5cGVvZiBEID09IFwiZnVuY3Rpb25cIiA/IEQoYy5vcHRpb25zKSA6IEQ7XG4gICAgICAgIFQoKSwgYy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgciwgYy5vcHRpb25zLCBMKSwgYy5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogdnQoYSkgPyBxdChhKSA6IGEuY29udGV4dEVsZW1lbnQgPyBxdChhLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogcXQobClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG0gPSBCcihVcihbXS5jb25jYXQocywgYy5vcHRpb25zLm1vZGlmaWVycykpKTtcbiAgICAgICAgcmV0dXJuIGMub3JkZXJlZE1vZGlmaWVycyA9IG0uZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcC5lbmFibGVkO1xuICAgICAgICB9KSwgTygpLCBnLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgdmFyIEQgPSBjLmVsZW1lbnRzLCBMID0gRC5yZWZlcmVuY2UsIG0gPSBELnBvcHBlcjtcbiAgICAgICAgICBpZiAoRmkoTCwgbSkpIHtcbiAgICAgICAgICAgIGMucmVjdHMgPSB7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogVnIoTCwgR3QobSksIGMub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiKSxcbiAgICAgICAgICAgICAgcG9wcGVyOiBwaShtKVxuICAgICAgICAgICAgfSwgYy5yZXNldCA9ICExLCBjLnBsYWNlbWVudCA9IGMub3B0aW9ucy5wbGFjZW1lbnQsIGMub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKE4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGMubW9kaWZpZXJzRGF0YVtOLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgTi5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBjLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgaWYgKGMucmVzZXQgPT09ICEwKSB7XG4gICAgICAgICAgICAgICAgYy5yZXNldCA9ICExLCBwID0gLTE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF8gPSBjLm9yZGVyZWRNb2RpZmllcnNbcF0sIGIgPSBfLmZuLCB3ID0gXy5vcHRpb25zLCBDID0gdyA9PT0gdm9pZCAwID8ge30gOiB3LCB5ID0gXy5uYW1lO1xuICAgICAgICAgICAgICB0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIgJiYgKGMgPSBiKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogYyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBDLFxuICAgICAgICAgICAgICAgIG5hbWU6IHksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGdcbiAgICAgICAgICAgICAgfSkgfHwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZToganIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihBKSB7XG4gICAgICAgICAgZy5mb3JjZVVwZGF0ZSgpLCBBKGMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIFQoKSwgdiA9ICEwO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFGaShhLCBsKSlcbiAgICAgIHJldHVybiBnO1xuICAgIGcuc2V0T3B0aW9ucyh1KS50aGVuKGZ1bmN0aW9uKEEpIHtcbiAgICAgICF2ICYmIHUub25GaXJzdFVwZGF0ZSAmJiB1Lm9uRmlyc3RVcGRhdGUoQSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gTygpIHtcbiAgICAgIGMub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgdmFyIEQgPSBBLm5hbWUsIEwgPSBBLm9wdGlvbnMsIG0gPSBMID09PSB2b2lkIDAgPyB7fSA6IEwsIHAgPSBBLmVmZmVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHZhciBfID0gcCh7XG4gICAgICAgICAgICBzdGF0ZTogYyxcbiAgICAgICAgICAgIG5hbWU6IEQsXG4gICAgICAgICAgICBpbnN0YW5jZTogZyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG1cbiAgICAgICAgICB9KSwgYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH07XG4gICAgICAgICAgZi5wdXNoKF8gfHwgYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgcmV0dXJuIEEoKTtcbiAgICAgIH0pLCBmID0gW107XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9O1xufVxudmFyIEZyID0gLyogQF9fUFVSRV9fICovIHdlKCksIFlyID0gW21pLCB3aSwgZ2ksIGZpXSwgS3IgPSAvKiBAX19QVVJFX18gKi8gd2Uoe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBZclxufSksIHpyID0gW21pLCB3aSwgZ2ksIGZpLCBFbiwgZ24sIHZuLCBmbiwgbW5dLCBUaSA9IC8qIEBfX1BVUkVfXyAqLyB3ZSh7XG4gIGRlZmF1bHRNb2RpZmllcnM6IHpyXG59KTtcbmNvbnN0IGJuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWZ0ZXJNYWluOiBzbixcbiAgYWZ0ZXJSZWFkOiBKcyxcbiAgYWZ0ZXJXcml0ZTogb24sXG4gIGFwcGx5U3R5bGVzOiBmaSxcbiAgYXJyb3c6IGZuLFxuICBhdXRvOiB2ZSxcbiAgYmFzZVBsYWNlbWVudHM6IFB0LFxuICBiZWZvcmVNYWluOiB0bixcbiAgYmVmb3JlUmVhZDogUXMsXG4gIGJlZm9yZVdyaXRlOiBubixcbiAgYm90dG9tOiBXLFxuICBjbGlwcGluZ1BhcmVudHM6IFhzLFxuICBjb21wdXRlU3R5bGVzOiBnaSxcbiAgY3JlYXRlUG9wcGVyOiBUaSxcbiAgY3JlYXRlUG9wcGVyQmFzZTogRnIsXG4gIGNyZWF0ZVBvcHBlckxpdGU6IEtyLFxuICBkZXRlY3RPdmVyZmxvdzogeHQsXG4gIGVuZDogTHQsXG4gIGV2ZW50TGlzdGVuZXJzOiBtaSxcbiAgZmxpcDogZ24sXG4gIGhpZGU6IG1uLFxuICBsZWZ0OiBQLFxuICBtYWluOiBlbixcbiAgbW9kaWZpZXJQaGFzZXM6IGFuLFxuICBvZmZzZXQ6IEVuLFxuICBwbGFjZW1lbnRzOiB1aSxcbiAgcG9wcGVyOiBDdCxcbiAgcG9wcGVyR2VuZXJhdG9yOiB3ZSxcbiAgcG9wcGVyT2Zmc2V0czogd2ksXG4gIHByZXZlbnRPdmVyZmxvdzogdm4sXG4gIHJlYWQ6IFpzLFxuICByZWZlcmVuY2U6IEdzLFxuICByaWdodDogQixcbiAgc3RhcnQ6IEV0LFxuICB0b3A6IGssXG4gIHZhcmlhdGlvblBsYWNlbWVudHM6IGVpLFxuICB2aWV3cG9ydDogZGksXG4gIHdyaXRlOiByblxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIEllKGkpIHtcbiAgcmV0dXJuIGkgPT09IFwidHJ1ZVwiID8gITAgOiBpID09PSBcImZhbHNlXCIgPyAhMSA6IGkgPT09IE51bWJlcihpKS50b1N0cmluZygpID8gTnVtYmVyKGkpIDogaSA9PT0gXCJcIiB8fCBpID09PSBcIm51bGxcIiA/IG51bGwgOiBpO1xufVxuZnVuY3Rpb24gUmUoaSkge1xuICByZXR1cm4gaS5yZXBsYWNlKC9bQS1aXS9nLCAodCkgPT4gYC0ke3QudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmNvbnN0IEUgPSB7XG4gIHNldERhdGFBdHRyaWJ1dGUoaSwgdCwgZSkge1xuICAgIGkuc2V0QXR0cmlidXRlKGBkYXRhLXR3ZS0ke1JlKHQpfWAsIGUpO1xuICB9LFxuICByZW1vdmVEYXRhQXR0cmlidXRlKGksIHQpIHtcbiAgICBpLnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10d2UtJHtSZSh0KX1gKTtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMoaSkge1xuICAgIGlmICghaSlcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGkuZGF0YXNldCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0d2VcIikpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlLnN0YXJ0c1dpdGgoXCJ0d2VDbGFzc1wiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHMgPSBlLnJlcGxhY2UoL150d2UvLCBcIlwiKTtcbiAgICAgIHMgPSBzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcy5zbGljZSgxLCBzLmxlbmd0aCksIHRbc10gPSBJZShpLmRhdGFzZXRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKGkpIHtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLmkuZGF0YXNldFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidHdlQ2xhc3NcIikpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBzID0gZS5yZXBsYWNlKC9edHdlQ2xhc3MvLCBcIlwiKTtcbiAgICAgIHMgPSBzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcy5zbGljZSgxLCBzLmxlbmd0aCksIHRbc10gPSBJZSh0W2VdKTtcbiAgICB9KSwgdDtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZShpLCB0KSB7XG4gICAgcmV0dXJuIEllKFxuICAgICAgaS5nZXRBdHRyaWJ1dGUoYGRhdGEtdHdlLSR7UmUodCl9YClcbiAgICApO1xuICB9LFxuICBvZmZzZXQoaSkge1xuICAgIGNvbnN0IHQgPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuICBwb3NpdGlvbihpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogaS5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBpLm9mZnNldExlZnRcbiAgICB9O1xuICB9LFxuICBzdHlsZShpLCB0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihpLnN0eWxlLCB0KTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3MoaSwgdCkge1xuICAgIGkgJiYgeGUodCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaS5jbGFzc0xpc3QuY29udGFpbnMoZSkgPyBpLmNsYXNzTGlzdC5yZW1vdmUoZSkgOiBpLmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZENsYXNzKGksIHQpIHtcbiAgICB4ZSh0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+ICFpLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBpLmNsYXNzTGlzdC5hZGQoZSlcbiAgICApO1xuICB9LFxuICBhZGRTdHlsZShpLCB0KSB7XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaS5zdHlsZVtlXSA9IHRbZV07XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZUNsYXNzKGksIHQpIHtcbiAgICB4ZSh0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+IGkuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIGkuY2xhc3NMaXN0LnJlbW92ZShlKVxuICAgICk7XG4gIH0sXG4gIGhhc0NsYXNzKGksIHQpIHtcbiAgICByZXR1cm4gaS5jbGFzc0xpc3QuY29udGFpbnModCk7XG4gIH0sXG4gIG1heE9mZnNldChpKSB7XG4gICAgY29uc3QgdCA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxZXG4gICAgICApLFxuICAgICAgbGVmdDogdC5sZWZ0ICsgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxYXG4gICAgICApXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHhlKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBpLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkoaSkgPyBpIDogITE7XG59XG5jb25zdCBxciA9IDMsIGggPSB7XG4gIGNsb3Nlc3QoaSwgdCkge1xuICAgIHJldHVybiBpLmNsb3Nlc3QodCk7XG4gIH0sXG4gIG1hdGNoZXMoaSwgdCkge1xuICAgIHJldHVybiBpLm1hdGNoZXModCk7XG4gIH0sXG4gIGZpbmQoaSwgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwodCwgaSlcbiAgICApO1xuICB9LFxuICBmaW5kT25lKGksIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIGkpO1xuICB9LFxuICBjaGlsZHJlbihpLCB0KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5pLmNoaWxkcmVuKS5maWx0ZXIoKHMpID0+IHMubWF0Y2hlcyh0KSk7XG4gIH0sXG4gIHBhcmVudHMoaSwgdCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgcyA9IGkucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgcyAmJiBzLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBzLm5vZGVUeXBlICE9PSBxcjsgKVxuICAgICAgdGhpcy5tYXRjaGVzKHMsIHQpICYmIGUucHVzaChzKSwgcyA9IHMucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgcHJldihpLCB0KSB7XG4gICAgbGV0IGUgPSBpLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgbmV4dChpLCB0KSB7XG4gICAgbGV0IGUgPSBpLm5leHRFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKGkpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJhXCIsXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJzZWxlY3RcIixcbiAgICAgIFwiZGV0YWlsc1wiLFxuICAgICAgXCJbdGFiaW5kZXhdXCIsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoKGUpID0+IGAke2V9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluZCh0LCBpKS5maWx0ZXIoXG4gICAgICAoZSkgPT4gIWd0KGUpICYmIGt0KGUpXG4gICAgKTtcbiAgfVxufSwga2UgPSBcImRyb3Bkb3duXCIsIFhyID0gXCJ0d2UuZHJvcGRvd25cIiwgYnQgPSBgLiR7WHJ9YCwgeWkgPSBcIi5kYXRhLWFwaVwiLCBoZSA9IFwiRXNjYXBlXCIsIFlpID0gXCJTcGFjZVwiLCBLaSA9IFwiVGFiXCIsIG5pID0gXCJBcnJvd1VwXCIsIGZlID0gXCJBcnJvd0Rvd25cIiwgR3IgPSAyLCBRciA9IG5ldyBSZWdFeHAoXG4gIGAke25pfXwke2ZlfXwke2hlfWBcbiksIFpyID0gYGhpZGUke2J0fWAsIEpyID0gYGhpZGRlbiR7YnR9YCwgdG8gPSBgc2hvdyR7YnR9YCwgZW8gPSBgc2hvd24ke2J0fWAsIGlvID0gYGNsaWNrJHtidH0ke3lpfWAsIHppID0gYGtleWRvd24ke2J0fSR7eWl9YCwgc28gPSBga2V5dXAke2J0fSR7eWl9YCwgaXQgPSBcInNob3dcIiwgbm8gPSBcImRyb3B1cFwiLCBybyA9IFwiZHJvcGVuZFwiLCBvbyA9IFwiZHJvcHN0YXJ0XCIsIGFvID0gXCJbZGF0YS10d2UtbmF2YmFyLXJlZl1cIiwgbmUgPSBcIltkYXRhLXR3ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBQZSA9IFwiW2RhdGEtdHdlLWRyb3Bkb3duLW1lbnUtcmVmXVwiLCBsbyA9IFwiW2RhdGEtdHdlLW5hdmJhci1uYXYtcmVmXVwiLCBjbyA9IFwiW2RhdGEtdHdlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10d2UtZHJvcGRvd24taXRlbS1yZWZdOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpXCIsIHVvID0gTSgpID8gXCJ0b3AtZW5kXCIgOiBcInRvcC1zdGFydFwiLCBobyA9IE0oKSA/IFwidG9wLXN0YXJ0XCIgOiBcInRvcC1lbmRcIiwgZm8gPSBNKCkgPyBcImJvdHRvbS1lbmRcIiA6IFwiYm90dG9tLXN0YXJ0XCIsIHBvID0gTSgpID8gXCJib3R0b20tc3RhcnRcIiA6IFwiYm90dG9tLWVuZFwiLCBfbyA9IE0oKSA/IFwibGVmdC1zdGFydFwiIDogXCJyaWdodC1zdGFydFwiLCBnbyA9IE0oKSA/IFwicmlnaHQtc3RhcnRcIiA6IFwibGVmdC1zdGFydFwiLCBtbyA9IFt7IG9wYWNpdHk6IFwiMFwiIH0sIHsgb3BhY2l0eTogXCIxXCIgfV0sIEVvID0gW3sgb3BhY2l0eTogXCIxXCIgfSwgeyBvcGFjaXR5OiBcIjBcIiB9XSwgcWkgPSB7XG4gIGl0ZXJhdGlvbnM6IDEsXG4gIGVhc2luZzogXCJlYXNlXCIsXG4gIGZpbGw6IFwiYm90aFwiXG59LCB2byA9IHtcbiAgb2Zmc2V0OiBbMCwgMl0sXG4gIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiLFxuICByZWZlcmVuY2U6IFwidG9nZ2xlXCIsXG4gIGRpc3BsYXk6IFwiZHluYW1pY1wiLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIGF1dG9DbG9zZTogITAsXG4gIGRyb3Bkb3duQW5pbWF0aW9uOiBcIm9uXCIsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1NTBcbn0sIGJvID0ge1xuICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgYm91bmRhcnk6IFwiKHN0cmluZ3xlbGVtZW50KVwiLFxuICByZWZlcmVuY2U6IFwiKHN0cmluZ3xlbGVtZW50fG9iamVjdClcIixcbiAgZGlzcGxheTogXCJzdHJpbmdcIixcbiAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIixcbiAgYXV0b0Nsb3NlOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZHJvcGRvd25BbmltYXRpb246IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiBcIm51bWJlclwiXG59O1xuY2xhc3MgWCBleHRlbmRzIHR0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IG51bGw7XG4gICAgY29uc3QgcyA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICAgXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPSB0aGlzLl9jb25maWcuZHJvcGRvd25BbmltYXRpb24gPT09IFwib25cIiAmJiAhcywgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHZvO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIGJvO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4ga2U7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmIChndCh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBpZiAoZC50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRvLFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gWC5nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9pbk5hdmJhciA/IEUuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcIm5vbmVcIikgOiB0aGlzLl9jcmVhdGVQb3BwZXIocyksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFzLmNsb3Nlc3QobG8pICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChuKSA9PiBkLm9uKG4sIFwibW91c2VvdmVyXCIsIG1lKSksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKSwgdGhpcy5fbWVudS5zZXRBdHRyaWJ1dGUoYGRhdGEtdHdlLWRyb3Bkb3duLSR7aXR9YCwgXCJcIiksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgdGhpcy5fbWVudS5hbmltYXRlKG1vLCB7XG4gICAgICAuLi5xaSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdHdlLWRyb3Bkb3duLSR7aXR9YCwgXCJcIiksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBlbywgdCk7XG4gICAgICB9LFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA/IHRoaXMuX2NvbmZpZy5hbmltYXRpb25EdXJhdGlvbiA6IDBcbiAgICApO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKGd0KHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICB0aGlzLl9jb21wbGV0ZUhpZGUodCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoZC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgemksXG4gICAgICBuZSxcbiAgICAgIFguZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgZC5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgemksXG4gICAgICBQZSxcbiAgICAgIFguZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgZC5vbihkb2N1bWVudCwgaW8sIFguY2xlYXJNZW51cyksIGQub24oZG9jdW1lbnQsIHNvLCBYLmNsZWFyTWVudXMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9jb21wbGV0ZUhpZGUodCkge1xuICAgIHRoaXMuX2ZhZGVPdXRBbmltYXRlICYmIHRoaXMuX2ZhZGVPdXRBbmltYXRlLnBsYXlTdGF0ZSA9PT0gXCJydW5uaW5nXCIgfHwgZC50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFpyLFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKHMpID0+IGQub2ZmKHMsIFwibW91c2VvdmVyXCIsIG1lKSksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgKHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gdGhpcy5fbWVudS5hbmltYXRlKEVvLCB7XG4gICAgICAuLi5xaSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9KSksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10d2UtZHJvcGRvd24tJHtpdH1gKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdHdlLWRyb3Bkb3duLSR7aXR9YCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpLCBFLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiksIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBKciwgdCk7XG4gICAgICB9LFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA/IHRoaXMuX2NvbmZpZy5hbmltYXRpb25EdXJhdGlvbiA6IDBcbiAgICApKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLkUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgUihrZSwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHR5cGVvZiB0LnJlZmVyZW5jZSA9PSBcIm9iamVjdFwiICYmICFTdCh0LnJlZmVyZW5jZSkgJiYgdHlwZW9mIHQucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgJHtrZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gXG4gICAgICApO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jcmVhdGVQb3BwZXIodCkge1xuICAgIGlmICh0eXBlb2YgYm4gPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgbGV0IGUgPSB0aGlzLl9lbGVtZW50O1xuICAgIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09IFwicGFyZW50XCIgPyBlID0gdCA6IFN0KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpID8gZSA9IHJ0KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpIDogdHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAoZSA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xuICAgIGNvbnN0IHMgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSwgbiA9IHMubW9kaWZpZXJzLmZpbmQoXG4gICAgICAocikgPT4gci5uYW1lID09PSBcImFwcGx5U3R5bGVzXCIgJiYgci5lbmFibGVkID09PSAhMVxuICAgICk7XG4gICAgdGhpcy5fcG9wcGVyID0gVGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fbWVudSxcbiAgICAgIHNcbiAgICApLCBuICYmIEUuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcInN0YXRpY1wiKTtcbiAgfVxuICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiB0LmRhdGFzZXRbYHR3ZURyb3Bkb3duJHtpdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGl0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICB9XG4gIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICByZXR1cm4gaC5uZXh0KHRoaXMuX2VsZW1lbnQsIFBlKVswXTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHQuZGF0YXNldC50d2VEcm9wZG93blBvc2l0aW9uID09PSBybylcbiAgICAgIHJldHVybiBfbztcbiAgICBpZiAodC5kYXRhc2V0LnR3ZURyb3Bkb3duUG9zaXRpb24gPT09IG9vKVxuICAgICAgcmV0dXJuIGdvO1xuICAgIGNvbnN0IGUgPSB0LmRhdGFzZXQudHdlRHJvcGRvd25BbGlnbm1lbnQgPT09IFwiZW5kXCI7XG4gICAgcmV0dXJuIHQuZGF0YXNldC50d2VEcm9wZG93blBvc2l0aW9uID09PSBubyA/IGUgPyBobyA6IHVvIDogZSA/IHBvIDogZm87XG4gIH1cbiAgX2RldGVjdE5hdmJhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KGFvKSAhPT0gbnVsbDtcbiAgfVxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0OiB0IH0gPSB0aGlzLl9jb25maWc7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0LnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IE51bWJlci5wYXJzZUludChlLCAxMCkpIDogdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gKGUpID0+IHQoZSwgdGhpcy5fZWxlbWVudCkgOiB0O1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSBcInN0YXRpY1wiICYmICh0Lm1vZGlmaWVycyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICAgICAgICBlbmFibGVkOiAhMVxuICAgICAgfVxuICAgIF0pLCB7XG4gICAgICAuLi50LFxuICAgICAgLi4udHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyh0KSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWdcbiAgICB9O1xuICB9XG4gIF9zZWxlY3RNZW51SXRlbSh7IGtleTogdCwgdGFyZ2V0OiBlIH0pIHtcbiAgICBjb25zdCBzID0gaC5maW5kKFxuICAgICAgY28sXG4gICAgICB0aGlzLl9tZW51XG4gICAgKS5maWx0ZXIoa3QpO1xuICAgIHMubGVuZ3RoICYmIEJzKFxuICAgICAgcyxcbiAgICAgIGUsXG4gICAgICB0ID09PSBmZSxcbiAgICAgICFzLmluY2x1ZGVzKGUpXG4gICAgKS5mb2N1cygpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IFguZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWVudXModCkge1xuICAgIGlmICh0ICYmICh0LmJ1dHRvbiA9PT0gR3IgfHwgdC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgIT09IEtpKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gaC5maW5kKG5lKTtcbiAgICBmb3IgKGxldCBzID0gMCwgbiA9IGUubGVuZ3RoOyBzIDwgbjsgcysrKSB7XG4gICAgICBjb25zdCByID0gWC5nZXRJbnN0YW5jZShlW3NdKTtcbiAgICAgIGlmICghciB8fCByLl9jb25maWcuYXV0b0Nsb3NlID09PSAhMSB8fCAhci5faXNTaG93bigpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IG8gPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHIuX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBhID0gdC5jb21wb3NlZFBhdGgoKSwgbCA9IGEuaW5jbHVkZXMoci5fbWVudSk7XG4gICAgICAgIGlmIChhLmluY2x1ZGVzKHIuX2VsZW1lbnQpIHx8IHIuX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwiaW5zaWRlXCIgJiYgIWwgfHwgci5fY29uZmlnLmF1dG9DbG9zZSA9PT0gXCJvdXRzaWRlXCIgJiYgbCB8fCByLl9tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAodC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgPT09IEtpIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdC50eXBlID09PSBcImNsaWNrXCIgJiYgKG8uY2xpY2tFdmVudCA9IHQpO1xuICAgICAgfVxuICAgICAgci5fY29tcGxldGVIaWRlKG8pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQodCkge1xuICAgIHJldHVybiBudCh0KSB8fCB0LnBhcmVudE5vZGU7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkgPyB0LmtleSA9PT0gWWkgfHwgdC5rZXkgIT09IGhlICYmICh0LmtleSAhPT0gZmUgJiYgdC5rZXkgIT09IG5pIHx8IHQudGFyZ2V0LmNsb3Nlc3QoUGUpKSA6ICFRci50ZXN0KHQua2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5kYXRhc2V0W2B0d2VEcm9wZG93biR7aXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpdC5zbGljZSgxKX1gXSA9PT0gXCJcIjtcbiAgICBpZiAoIWUgJiYgdC5rZXkgPT09IGhlIHx8ICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIGd0KHRoaXMpKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gdGhpcy5tYXRjaGVzKG5lKSA/IHRoaXMgOiBoLnByZXYodGhpcywgbmUpWzBdLCBuID0gWC5nZXRPckNyZWF0ZUluc3RhbmNlKHMpO1xuICAgIGlmICh0LmtleSA9PT0gaGUpIHtcbiAgICAgIG4uaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodC5rZXkgPT09IG5pIHx8IHQua2V5ID09PSBmZSkge1xuICAgICAgZSB8fCBuLnNob3coKSwgbi5fc2VsZWN0TWVudUl0ZW0odCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICghZSB8fCB0LmtleSA9PT0gWWkpICYmIFguY2xlYXJNZW51cygpO1xuICB9XG59XG5jb25zdCBNZSA9IFwiY29sbGFwc2VcIiwgd24gPSBcInR3ZS5jb2xsYXBzZVwiLCBUZSA9IGAuJHt3bn1gLCBYaSA9IHtcbiAgdG9nZ2xlOiAhMCxcbiAgcGFyZW50OiBudWxsXG59LCB3byA9IHtcbiAgdG9nZ2xlOiBcImJvb2xlYW5cIixcbiAgcGFyZW50OiBcIihudWxsfGVsZW1lbnQpXCJcbn0sIFRvID0gYHNob3cke1RlfWAsIHlvID0gYHNob3duJHtUZX1gLCBBbyA9IGBoaWRlJHtUZX1gLCBDbyA9IGBoaWRkZW4ke1RlfWAsIEhlID0gXCJkYXRhLXR3ZS1jb2xsYXBzZS1zaG93XCIsIEdpID0gXCJkYXRhLXR3ZS1jb2xsYXBzZS1jb2xsYXBzZWRcIiwgcmUgPSBcImRhdGEtdHdlLWNvbGxhcHNlLWNvbGxhcHNpbmdcIiwgT28gPSBcImRhdGEtdHdlLWNvbGxhcHNlLWhvcml6b250YWxcIiwgTnQgPSBcImRhdGEtdHdlLWNvbGxhcHNlLWl0ZW1cIiwgUWkgPSBgOnNjb3BlIFske050fV0gWyR7TnR9XWAsIERvID0gXCJ3aWR0aFwiLCBObyA9IFwiaGVpZ2h0XCIsIFNvID0gXCJbZGF0YS10d2UtY29sbGFwc2UtaXRlbV1bZGF0YS10d2UtY29sbGFwc2Utc2hvd10sIFtkYXRhLXR3ZS1jb2xsYXBzZS1pdGVtXVtkYXRhLXR3ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXVwiLCBaaSA9IFwiW2RhdGEtdHdlLWNvbGxhcHNlLWluaXRdXCIsIExvID0ge1xuICB2aXNpYmxlOiBcIiF2aXNpYmxlXCIsXG4gIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgYmFzZVRyYW5zaXRpb246IFwib3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgY29sbGFwc2luZzogXCJoLTAgdHJhbnNpdGlvbi1baGVpZ2h0XSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJ3LTAgaC1hdXRvIHRyYW5zaXRpb24tW3dpZHRoXSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG59LCAkbyA9IHtcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaGlkZGVuOiBcInN0cmluZ1wiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZzogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZ0hvcml6b250YWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBwZSBleHRlbmRzIHR0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgcykge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhzKSwgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XG4gICAgY29uc3QgbiA9IGguZmluZChaaSk7XG4gICAgZm9yIChsZXQgciA9IDAsIG8gPSBuLmxlbmd0aDsgciA8IG87IHIrKykge1xuICAgICAgY29uc3QgYSA9IG5bcl0sIGwgPSBjaShhKSwgdSA9IGguZmluZChsKS5maWx0ZXIoXG4gICAgICAgIChjKSA9PiBjID09PSB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgbCAhPT0gbnVsbCAmJiB1Lmxlbmd0aCAmJiAodGhpcy5fc2VsZWN0b3IgPSBsLCB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChhKSk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpLCB0aGlzLl9jb25maWcucGFyZW50IHx8IHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSksIHRoaXMuX2NvbmZpZy50b2dnbGUgJiYgdGhpcy50b2dnbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gWGk7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBNZTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdCA9IFtdLCBlO1xuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICBjb25zdCBjID0gaC5maW5kKFxuICAgICAgICBRaSxcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICAgKTtcbiAgICAgIHQgPSBoLmZpbmQoXG4gICAgICAgIFNvLFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApLmZpbHRlcigoZikgPT4gIWMuaW5jbHVkZXMoZikpO1xuICAgIH1cbiAgICBjb25zdCBzID0gaC5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcbiAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGMgPSB0LmZpbmQoKGYpID0+IHMgIT09IGYpO1xuICAgICAgaWYgKGUgPSBjID8gcGUuZ2V0SW5zdGFuY2UoYykgOiBudWxsLCBlICYmIGUuX2lzVHJhbnNpdGlvbmluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFRvKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgcyAhPT0gYyAmJiBwZS5nZXRPckNyZWF0ZUluc3RhbmNlKGMsIHsgdG9nZ2xlOiAhMSB9KS5oaWRlKCksIGUgfHwgVi5zZXREYXRhKGMsIHduLCBudWxsKTtcbiAgICB9KTtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIG8gPSByID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcbiAgICBFLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIEUucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBFLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIG8pLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShOdCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHJlLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtyXSA9IDAsIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksICEwKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBFLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgRS5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBvKSwgRS5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShyZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE50LCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoSGUsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW3JdID0gXCJcIiwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHlvKTtcbiAgICB9LCB1ID0gYHNjcm9sbCR7clswXS50b1VwcGVyQ2FzZSgpICsgci5zbGljZSgxKX1gO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soYSwgdGhpcy5fZWxlbWVudCwgITApLCB0aGlzLl9lbGVtZW50LnN0eWxlW3JdID0gYCR7dGhpcy5fZWxlbWVudFt1XX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkgfHwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEFvKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgcyA9IGUgPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZV0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2VdfXB4YCwgWHQodGhpcy5fZWxlbWVudCksIEUuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgcyksIEUucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgRS5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHJlLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTnQpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShIZSk7XG4gICAgY29uc3QgbiA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuOyBvKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl90cmlnZ2VyQXJyYXlbb10sIGwgPSBudChhKTtcbiAgICAgIGwgJiYgIXRoaXMuX2lzU2hvd24obCkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFthXSwgITEpO1xuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCByID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIEUucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgcyksIEUuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgRS5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHJlKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTnQsIFwiXCIpLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQ28pO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IFwiXCIsIHRoaXMuX3F1ZXVlQ2FsbGJhY2sociwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIF9pc1Nob3duKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKEhlKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uWGksXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIHQudG9nZ2xlID0gISF0LnRvZ2dsZSwgdC5wYXJlbnQgPSBydCh0LnBhcmVudCksIFIoTWUsIHQsIHdvKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IEUuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkxvLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBSKE1lLCB0LCAkbyksIHQ7XG4gIH1cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoT28pID8gRG8gOiBObztcbiAgfVxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gaC5maW5kKFxuICAgICAgUWksXG4gICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgKTtcbiAgICBoLmZpbmQoWmksIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcigoZSkgPT4gIXQuaW5jbHVkZXMoZSkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBudChlKTtcbiAgICAgIHMgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlXSwgdGhpcy5faXNTaG93bihzKSk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0LCBlKSB7XG4gICAgdC5sZW5ndGggJiYgdC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBlID8gcy5yZW1vdmVBdHRyaWJ1dGUoR2kpIDogcy5zZXRBdHRyaWJ1dGUoYCR7R2l9YCwgXCJcIiksIHMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB7fTtcbiAgICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XG4gICAgICBjb25zdCBzID0gcGUuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc1t0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBzW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEppID0gXCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsIHRzID0gXCIuc3RpY2t5LXRvcFwiO1xuY2xhc3Mgcmkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIHQpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICAgIChlKSA9PiBlICsgdFxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgSmksXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB0cyxcbiAgICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICAgIChlKSA9PiBlIC0gdFxuICAgICk7XG4gIH1cbiAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCksIHIgPSAobykgPT4ge1xuICAgICAgaWYgKG8gIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiBvLmNsaWVudFdpZHRoICsgbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUobywgZSk7XG4gICAgICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobylbZV07XG4gICAgICBvLnN0eWxlW2VdID0gYCR7cyhcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYSlcbiAgICAgICl9cHhgO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCByKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoSmksIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRzLCBcIm1hcmdpblJpZ2h0XCIpO1xuICB9XG4gIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHQuc3R5bGVbZV07XG4gICAgcyAmJiBFLnNldERhdGFBdHRyaWJ1dGUodCwgZSwgcyk7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xuICAgIGNvbnN0IHMgPSAobikgPT4ge1xuICAgICAgY29uc3QgciA9IEUuZ2V0RGF0YUF0dHJpYnV0ZShuLCBlKTtcbiAgICAgIHR5cGVvZiByID4gXCJ1XCIgPyBuLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogKEUucmVtb3ZlRGF0YUF0dHJpYnV0ZShuLCBlKSwgbi5zdHlsZVtlXSA9IHIpO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBzKTtcbiAgfVxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBlKSB7XG4gICAgU3QodCkgPyBlKHQpIDogaC5maW5kKHQsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goZSk7XG4gIH1cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgfVxufVxuY29uc3QgSW8gPSB7XG4gIGlzVmlzaWJsZTogITAsXG4gIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gIGlzQW5pbWF0ZWQ6ICExLFxuICByb290RWxlbWVudDogXCJib2R5XCIsXG4gIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgYmFja2Ryb3BDbGFzc2VzOiBudWxsXG59LCBSbyA9IHtcbiAgaXNWaXNpYmxlOiBcImJvb2xlYW5cIixcbiAgaXNBbmltYXRlZDogXCJib29sZWFuXCIsXG4gIHJvb3RFbGVtZW50OiBcIihlbGVtZW50fHN0cmluZylcIixcbiAgY2xpY2tDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIixcbiAgYmFja2Ryb3BDbGFzc2VzOiBcIihhcnJheXxzdHJpbmd8bnVsbClcIlxufSwgVG4gPSBcImJhY2tkcm9wXCIsIGVzID0gYG1vdXNlZG93bi50d2UuJHtUbn1gO1xuY2xhc3MgeW4ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKHQpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEsIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgX3QodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiBYdCh0aGlzLl9nZXRFbGVtZW50KCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25maWcuYmFja2Ryb3BDbGFzc2VzIHx8IFtcbiAgICAgIFwib3BhY2l0eS01MFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uLWFsbFwiLFxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcbiAgICAgIFwiZWFzZS1pbi1vdXRcIixcbiAgICAgIFwiZml4ZWRcIixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotWzEwNDBdXCIsXG4gICAgICBcImJnLWJsYWNrXCIsXG4gICAgICBcInctc2NyZWVuXCIsXG4gICAgICBcImgtc2NyZWVuXCJcbiAgICBdO1xuICAgIEUucmVtb3ZlQ2xhc3ModGhpcy5fZ2V0RWxlbWVudCgpLCBcIm9wYWNpdHktMFwiKSwgRS5hZGRDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdHdlLWJhY2tkcm9wLXNob3dcIiwgXCJcIiksIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgX3QodCk7XG4gICAgfSk7XG4gIH1cbiAgaGlkZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBfdCh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1iYWNrZHJvcC1zaG93XCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpLCBfdCh0KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGUodCA9IHt9KSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fY29uZmlnLCAuLi50IH0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLklvLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIHQucm9vdEVsZW1lbnQgPSBydCh0LnJvb3RFbGVtZW50KSwgUihUbiwgdCwgUm8pLCB0O1xuICB9XG4gIF9hcHBlbmQoKSB7XG4gICAgdGhpcy5faXNBcHBlbmRlZCB8fCAodGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZCh0aGlzLl9nZXRFbGVtZW50KCkpLCBkLm9uKHRoaXMuX2dldEVsZW1lbnQoKSwgZXMsICgpID0+IHtcbiAgICAgIF90KHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICB9KSwgdGhpcy5faXNBcHBlbmRlZCA9ICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgJiYgKGQub2ZmKHRoaXMuX2VsZW1lbnQsIGVzKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSwgdGhpcy5faXNBcHBlbmRlZCA9ICExKTtcbiAgfVxuICBfZW11bGF0ZUFuaW1hdGlvbih0KSB7XG4gICAgV3MoXG4gICAgICB0LFxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLFxuICAgICAgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWRcbiAgICApO1xuICB9XG59XG5jbGFzcyBBbiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgcykge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl90b2dnbGVyID0gcywgdGhpcy5fZXZlbnQgPSBlLmV2ZW50IHx8IFwiYmx1clwiLCB0aGlzLl9jb25kaXRpb24gPSBlLmNvbmRpdGlvbiB8fCAoKCkgPT4gITApLCB0aGlzLl9zZWxlY3RvciA9IGUuc2VsZWN0b3IgfHwgJ2J1dHRvbiwgYSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsIHRoaXMuX29ubHlWaXNpYmxlID0gZS5vbmx5VmlzaWJsZSB8fCAhMSwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSBbXSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5fbGFzdEVsZW1lbnQgPSBudWxsLCB0aGlzLmhhbmRsZXIgPSAobikgPT4ge1xuICAgICAgdGhpcy5fY29uZGl0aW9uKG4pICYmICFuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9sYXN0RWxlbWVudCA/IChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpKSA6IHRoaXMuX2NvbmRpdGlvbihuKSAmJiBuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9maXJzdEVsZW1lbnQgJiYgKG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5fbGFzdEVsZW1lbnQuZm9jdXMoKSk7XG4gICAgfTtcbiAgfVxuICB0cmFwKCkge1xuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX2luaXQoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSksIHRoaXMuX3RvZ2dsZXIgJiYgdGhpcy5fdG9nZ2xlci5mb2N1cygpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9zZXRGb2N1c1RyYXAoKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICF0aGlzLl9maXJzdEVsZW1lbnQgfHwgZS5rZXkgIT09IFwiVGFiXCIgfHwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuaW5jbHVkZXMoZS50YXJnZXQpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCkpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpO1xuICB9XG4gIF9maWx0ZXJWaXNpYmxlKHQpIHtcbiAgICByZXR1cm4gdC5maWx0ZXIoKGUpID0+IHtcbiAgICAgIGlmICgha3QoZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHMgPSBoLnBhcmVudHMoZSwgXCIqXCIpO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGNvbnN0IHIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzW25dKTtcbiAgICAgICAgaWYgKHIgJiYgKHIuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgci52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSk7XG4gIH1cbiAgX3NldEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmQodGhpcy5fc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gdC5maWx0ZXIoKGUpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBlLmdldEF0dHJpYnV0ZShcImRhdGEtdHdlLWRpc2FibGVkXCIpID09PSBcInRydWVcIiB8fCBlLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgICAgcmV0dXJuIGUuZGlzYWJsZWQgfHwgcyA/IG51bGwgOiBlO1xuICAgIH0pLCB0aGlzLl9vbmx5VmlzaWJsZSAmJiAodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLl9maWx0ZXJWaXNpYmxlKHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzKSksIHRoaXMuX2ZpcnN0RWxlbWVudCA9IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzWzBdLCB0aGlzLl9sYXN0RWxlbWVudCA9IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzW3RoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgZSA9PT0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMSB8fCBlID09PSAwID8gdC5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpIDogdC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5sZXQgaXMgPSBbXTtcbmNvbnN0IENuID0gKGksIHQgPSBcImhpZGVcIikgPT4ge1xuICBjb25zdCBlID0gYGNsaWNrLmRpc21pc3Mke2kuRVZFTlRfS0VZfWAsIHMgPSBpLk5BTUU7XG4gIGlzLmluY2x1ZGVzKHMpIHx8IChpcy5wdXNoKHMpLCBkLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGUsXG4gICAgYFtkYXRhLXR3ZS0ke3N9LWRpc21pc3NdYCxcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBuLnByZXZlbnREZWZhdWx0KCksIGd0KHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gbnQodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtzfWApIHx8IHRoaXMuY2xvc2VzdChgW2RhdGEtdHdlLSR7c30taW5pdF1gKTtcbiAgICAgIGlmICghcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaS5nZXRPckNyZWF0ZUluc3RhbmNlKHIpW3RdKCk7XG4gICAgfVxuICApKTtcbn0sIHhvID0gOSwgc3MgPSBcIm9mZmNhbnZhc1wiLCBrbyA9IFwidHdlLm9mZmNhbnZhc1wiLCBNdCA9IGAuJHtrb31gLCBQbyA9IFwiLmRhdGEtYXBpXCIsIE1vID0gYGxvYWQke010fSR7UG99YCwgSG8gPSBcIkVzY2FwZVwiLCBucyA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIHNjcm9sbDogITFcbn0sIFZvID0ge1xuICBiYWNrZHJvcDogXCJib29sZWFuXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsOiBcImJvb2xlYW5cIlxufSwgcnMgPSBcInNob3dcIiwgV28gPSBcIltkYXRhLXR3ZS1vZmZjYW52YXMtaW5pdF1bZGF0YS10d2Utb2ZmY2FudmFzLXNob3ddXCIsIEJvID0gYHNob3cke010fWAsIGpvID0gYHNob3duJHtNdH1gLCBVbyA9IGBoaWRlJHtNdH1gLCBGbyA9IGBoaWRkZW4ke010fWAsIFlvID0gYGtleWRvd24uZGlzbWlzcyR7TXR9YDtcbmNsYXNzIF9lIGV4dGVuZHMgdHQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBzcztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIG5zO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEJvLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHJpKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXR3ZS1vZmZjYW52YXMtJHtyc31gLCBcIlwiKTtcbiAgICBjb25zdCBzID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgam8sIHsgcmVsYXRlZFRhcmdldDogdCB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2socywgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBVbykuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCB0aGlzLl9lbGVtZW50LmJsdXIoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10d2Utb2ZmY2FudmFzLSR7cnN9YCksIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiLCB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IG5ldyByaSgpLnJlc2V0KCksIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBGbyk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoZC5vbihcbiAgICAgIHdpbmRvdyxcbiAgICAgIE1vLFxuICAgICAgKCkgPT4gaC5maW5kKFdvKS5mb3JFYWNoKFxuICAgICAgICAodCkgPT4gX2UuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0KS5zaG93KClcbiAgICAgIClcbiAgICApLCB0aGlzLl9kaWRJbml0ID0gITAsIENuKF9lKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ucyxcbiAgICAgIC4uLkUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgUihzcywgdCwgVm8pLCB0O1xuICB9XG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgcmV0dXJuIG5ldyB5bih7XG4gICAgICBpc1Zpc2libGU6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcbiAgICAgIGlzQW5pbWF0ZWQ6ICEwLFxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGNsaWNrQ2FsbGJhY2s6ICgpID0+IHRoaXMuaGlkZSgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBBbih0aGlzLl9lbGVtZW50LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleUNvZGUgPT09IHhvLFxuICAgICAgb25seVZpc2libGU6ICEwXG4gICAgfSk7XG4gIH1cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGQub24odGhpcy5fZWxlbWVudCwgWW8sICh0KSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IEhvICYmIHRoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IF9lLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBWZSA9IFwiY2Fyb3VzZWxcIiwgS28gPSBcInR3ZS5jYXJvdXNlbFwiLCBVID0gYC4ke0tvfWAsIE9uID0gXCIuZGF0YS1hcGlcIiwgem8gPSBcIkFycm93TGVmdFwiLCBxbyA9IFwiQXJyb3dSaWdodFwiLCBYbyA9IDUwMCwgR28gPSA0MCwgb3MgPSB7XG4gIGludGVydmFsOiA1ZTMsXG4gIGtleWJvYXJkOiAhMCxcbiAgcmlkZTogITEsXG4gIHBhdXNlOiBcImhvdmVyXCIsXG4gIHdyYXA6ICEwLFxuICB0b3VjaDogITBcbn0sIFFvID0ge1xuICBpbnRlcnZhbDogXCIobnVtYmVyfGJvb2xlYW4pXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgcmlkZTogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIHBhdXNlOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgd3JhcDogXCJib29sZWFuXCIsXG4gIHRvdWNoOiBcImJvb2xlYW5cIlxufSwgWm8gPSB7XG4gIHBvaW50ZXI6IFwidG91Y2gtcGFuLXlcIixcbiAgYmxvY2s6IFwiIWJsb2NrXCIsXG4gIHZpc2libGU6IFwiZGF0YS1bdHdlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMTAwIGRhdGEtW3R3ZS1jYXJvdXNlbC1mYWRlXTp6LVsxXVwiLFxuICBpbnZpc2libGU6IFwiZGF0YS1bdHdlLWNhcm91c2VsLWZhZGVdOnotMCBkYXRhLVt0d2UtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0wIGRhdGEtW3R3ZS1jYXJvdXNlbC1mYWRlXTpkdXJhdGlvbi1bNjAwbXNdIGRhdGEtW3R3ZS1jYXJvdXNlbC1mYWRlXTpkZWxheS02MDBcIixcbiAgc2xpZGVSaWdodDogXCJ0cmFuc2xhdGUteC1mdWxsXCIsXG4gIHNsaWRlTGVmdDogXCItdHJhbnNsYXRlLXgtZnVsbFwiXG59LCBKbyA9IHtcbiAgcG9pbnRlcjogXCJzdHJpbmdcIixcbiAgYmxvY2s6IFwic3RyaW5nXCIsXG4gIHZpc2libGU6IFwic3RyaW5nXCIsXG4gIGludmlzaWJsZTogXCJzdHJpbmdcIixcbiAgc2xpZGVSaWdodDogXCJzdHJpbmdcIixcbiAgc2xpZGVMZWZ0OiBcInN0cmluZ1wiXG59LCBodCA9IFwibmV4dFwiLCBmdCA9IFwicHJldlwiLCBwdCA9IFwibGVmdFwiLCBZdCA9IFwicmlnaHRcIiwgdGEgPSB7XG4gIFt6b106IFl0LFxuICBbcW9dOiBwdFxufSwgZWEgPSBgc2xpZGUke1V9YCwgV2UgPSBgc2xpZCR7VX1gLCBpYSA9IGBrZXlkb3duJHtVfWAsIHNhID0gYG1vdXNlZW50ZXIke1V9YCwgbmEgPSBgbW91c2VsZWF2ZSR7VX1gLCByYSA9IGB0b3VjaHN0YXJ0JHtVfWAsIG9hID0gYHRvdWNobW92ZSR7VX1gLCBhYSA9IGB0b3VjaGVuZCR7VX1gLCBsYSA9IGBwb2ludGVyZG93biR7VX1gLCBjYSA9IGBwb2ludGVydXAke1V9YCwgZGEgPSBgZHJhZ3N0YXJ0JHtVfWAsIGFzID0gYGxvYWQke1V9JHtPbn1gLCBscyA9IGBjbGljayR7VX0ke09ufWAsIFd0ID0gXCJkYXRhLXR3ZS1jYXJvdXNlbC1hY3RpdmVcIiwgdWEgPSBcImRhdGEtdHdlLWNhcm91c2VsLWl0ZW0tZW5kXCIsIEJlID0gXCJkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtLXN0YXJ0XCIsIGhhID0gXCJkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtLW5leHRcIiwgZmEgPSBcImRhdGEtdHdlLWNhcm91c2VsLWl0ZW0tcHJldlwiLCBwYSA9IFwiZGF0YS10d2UtY2Fyb3VzZWwtcG9pbnRlci1ldmVudFwiLCBfYSA9IFwiW2RhdGEtdHdlLWNhcm91c2VsLWluaXRdXCIsIERuID0gXCJbZGF0YS10d2UtY2Fyb3VzZWwtYWN0aXZlXVwiLCBBaSA9IFwiW2RhdGEtdHdlLWNhcm91c2VsLWl0ZW1dXCIsIFR0ID0gYCR7RG59JHtBaX1gLCBnYSA9IGAke0FpfSBpbWdgLCBtYSA9IFwiW2RhdGEtdHdlLWNhcm91c2VsLWl0ZW0tbmV4dF0sIFtkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtLXByZXZdXCIsIEVhID0gXCJbZGF0YS10d2UtY2Fyb3VzZWwtaW5kaWNhdG9yc11cIiwgdmEgPSBcIltkYXRhLXR3ZS10YXJnZXRdXCIsIGNzID0gXCJbZGF0YS10d2Utc2xpZGVdLCBbZGF0YS10d2Utc2xpZGUtdG9dXCIsIGJhID0gXCJ0b3VjaFwiLCB3YSA9IFwicGVuXCI7XG5jbGFzcyBaIGV4dGVuZHMgdHQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBzKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2l0ZW1zID0gbnVsbCwgdGhpcy5faW50ZXJ2YWwgPSBudWxsLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbCwgdGhpcy5faXNQYXVzZWQgPSAhMSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbCwgdGhpcy50b3VjaFN0YXJ0WCA9IDAsIHRoaXMudG91Y2hEZWx0YVggPSAwLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKHMpLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IGguZmluZE9uZShcbiAgICAgIEVhLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCwgdGhpcy5fcG9pbnRlckV2ZW50ID0gISF3aW5kb3cuUG9pbnRlckV2ZW50LCB0aGlzLl9zZXRBY3RpdmVFbGVtZW50Q2xhc3MoKSwgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCksIHRoaXMuX2NvbmZpZy5yaWRlID09PSBcImNhcm91c2VsXCIgJiYgdGhpcy5jeWNsZSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBvcztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFZlO1xuICB9XG4gIC8vIFB1YmxpY1xuICBuZXh0KCkge1xuICAgIHRoaXMuX3NsaWRlKGh0KTtcbiAgfVxuICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgIWRvY3VtZW50LmhpZGRlbiAmJiBrdCh0aGlzLl9lbGVtZW50KSAmJiB0aGlzLm5leHQoKTtcbiAgfVxuICBwcmV2KCkge1xuICAgIHRoaXMuX3NsaWRlKGZ0KTtcbiAgfVxuICBwYXVzZSh0KSB7XG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMCksIGguZmluZE9uZShtYSwgdGhpcy5fZWxlbWVudCkgJiYgKFBzKHRoaXMuX2VsZW1lbnQpLCB0aGlzLmN5Y2xlKCEwKSksIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gIH1cbiAgY3ljbGUodCkge1xuICAgIHQgfHwgKHRoaXMuX2lzUGF1c2VkID0gITEpLCB0aGlzLl9pbnRlcnZhbCAmJiAoY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbCksIHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcuaW50ZXJ2YWwgJiYgIXRoaXMuX2lzUGF1c2VkICYmICh0aGlzLl91cGRhdGVJbnRlcnZhbCgpLCB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKFxuICAgICAgICB0aGlzXG4gICAgICApLFxuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsXG4gICAgKSk7XG4gIH1cbiAgdG8odCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBoLmZpbmRPbmUoXG4gICAgICBUdCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XG4gICAgaWYgKHQgPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IHQgPCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIGQub25lKHRoaXMuX2VsZW1lbnQsIFdlLCAoKSA9PiB0aGlzLnRvKHQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUgPT09IHQpIHtcbiAgICAgIHRoaXMucGF1c2UoKSwgdGhpcy5jeWNsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzID0gdCA+IGUgPyBodCA6IGZ0O1xuICAgIHRoaXMuX3NsaWRlKHMsIHRoaXMuX2l0ZW1zW3RdKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGQub2ZmKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBscyxcbiAgICAgIGNzLFxuICAgICAgWi5kYXRhQXBpQ2xpY2tIYW5kbGVyXG4gICAgKSwgZC5vZmYod2luZG93LCBhcyksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGQub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIGxzLFxuICAgICAgY3MsXG4gICAgICBaLmRhdGFBcGlDbGlja0hhbmRsZXJcbiAgICApLCBkLm9uKHdpbmRvdywgYXMsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBoLmZpbmQoX2EpO1xuICAgICAgZm9yIChsZXQgZSA9IDAsIHMgPSB0Lmxlbmd0aDsgZSA8IHM7IGUrKylcbiAgICAgICAgWi5jYXJvdXNlbEludGVyZmFjZShcbiAgICAgICAgICB0W2VdLFxuICAgICAgICAgIFouZ2V0SW5zdGFuY2UodFtlXSlcbiAgICAgICAgKTtcbiAgICB9KSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLm9zLFxuICAgICAgLi4uRS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBSKFZlLCB0LCBRbyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5abyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgUihWZSwgdCwgSm8pLCB0O1xuICB9XG4gIF9lbmFibGVDeWNsZSgpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLnJpZGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgZC5vbmUodGhpcy5fZWxlbWVudCwgV2UsICgpID0+IHRoaXMuY3ljbGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICB9XG4gIH1cbiAgX2FwcGx5SW5pdGlhbENsYXNzZXMoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdC5jbGFzc0xpc3QuYWRkKFxuICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9jayxcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHQpO1xuICB9XG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7XG4gICAgaWYgKHQgPD0gR28pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQgLyB0aGlzLnRvdWNoRGVsdGFYO1xuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwLCBlICYmIHRoaXMuX3NsaWRlKGUgPiAwID8gWXQgOiBwdCk7XG4gIH1cbiAgX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gaC5maW5kT25lKFxuICAgICAgVHQsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgRS5hZGRDbGFzcyh0aGlzLl9hY3RpdmVFbGVtZW50LCBcImhpZGRlblwiKTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGQub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgaWEsXG4gICAgICAodCkgPT4gdGhpcy5fa2V5ZG93bih0KVxuICAgICksIHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gXCJob3ZlclwiICYmIChkLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHNhLFxuICAgICAgKHQpID0+IHRoaXMucGF1c2UodClcbiAgICApLCBkLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG5hLFxuICAgICAgKHQpID0+IHRoaXMuX2VuYWJsZUN5Y2xlKHQpXG4gICAgKSksIHRoaXMuX2NvbmZpZy50b3VjaCAmJiB0aGlzLl90b3VjaFN1cHBvcnRlZCAmJiB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoKTtcbiAgfVxuICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0ID0gKHIpID0+IHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoci5wb2ludGVyVHlwZSA9PT0gd2EgfHwgci5wb2ludGVyVHlwZSA9PT0gYmEpLCBlID0gKHIpID0+IHtcbiAgICAgIHQocikgPyB0aGlzLnRvdWNoU3RhcnRYID0gci5jbGllbnRYIDogdGhpcy5fcG9pbnRlckV2ZW50IHx8ICh0aGlzLnRvdWNoU3RhcnRYID0gci50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgIH0sIHMgPSAocikgPT4ge1xuICAgICAgdGhpcy50b3VjaERlbHRhWCA9IHIudG91Y2hlcyAmJiByLnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiByLnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFg7XG4gICAgfSwgbiA9IChyKSA9PiB7XG4gICAgICB0KHIpICYmICh0aGlzLnRvdWNoRGVsdGFYID0gci5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WCksIHRoaXMuX2hhbmRsZVN3aXBlKCksIHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gXCJob3ZlclwiICYmICh0aGlzLnBhdXNlKCksIHRoaXMudG91Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCksIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgKG8pID0+IHRoaXMuX2VuYWJsZUN5Y2xlKG8pLFxuICAgICAgICBYbyArIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICAgKSk7XG4gICAgfTtcbiAgICBoLmZpbmQoZ2EsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAocikgPT4ge1xuICAgICAgICBkLm9uKFxuICAgICAgICAgIHIsXG4gICAgICAgICAgZGEsXG4gICAgICAgICAgKG8pID0+IG8ucHJldmVudERlZmF1bHQoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksIHRoaXMuX3BvaW50ZXJFdmVudCA/IChkLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGxhLFxuICAgICAgKHIpID0+IGUocilcbiAgICApLCBkLm9uKHRoaXMuX2VsZW1lbnQsIGNhLCAocikgPT4gbihyKSksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnBvaW50ZXIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgJHtwYX1gLCBcIlwiKSkgOiAoZC5vbih0aGlzLl9lbGVtZW50LCByYSwgKHIpID0+IGUocikpLCBkLm9uKHRoaXMuX2VsZW1lbnQsIG9hLCAocikgPT4gcyhyKSksIGQub24odGhpcy5fZWxlbWVudCwgYWEsIChyKSA9PiBuKHIpKSk7XG4gIH1cbiAgX2tleWRvd24odCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0YVt0LmtleV07XG4gICAgZSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9zbGlkZShlKSk7XG4gIH1cbiAgX2dldEl0ZW1JbmRleCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zID0gdCAmJiB0LnBhcmVudE5vZGUgPyBoLmZpbmQoQWksIHQucGFyZW50Tm9kZSkgOiBbXSwgdGhpcy5faXRlbXMuaW5kZXhPZih0KTtcbiAgfVxuICBfZ2V0SXRlbUJ5T3JkZXIodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0ID09PSBodDtcbiAgICByZXR1cm4gQnMoXG4gICAgICB0aGlzLl9pdGVtcyxcbiAgICAgIGUsXG4gICAgICBzLFxuICAgICAgdGhpcy5fY29uZmlnLndyYXBcbiAgICApO1xuICB9XG4gIF90cmlnZ2VyU2xpZGVFdmVudCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX2dldEl0ZW1JbmRleCh0KSwgbiA9IHRoaXMuX2dldEl0ZW1JbmRleChcbiAgICAgIGguZmluZE9uZShUdCwgdGhpcy5fZWxlbWVudClcbiAgICApO1xuICAgIHJldHVybiBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZWEsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHQsXG4gICAgICBkaXJlY3Rpb246IGUsXG4gICAgICBmcm9tOiBuLFxuICAgICAgdG86IHNcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KSB7XG4gICAgaWYgKHRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICBjb25zdCBlID0gaC5maW5kT25lKFxuICAgICAgICBEbixcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcbiAgICAgICk7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShXdCksIGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIpLCBlLmNsYXNzTGlzdC5yZW1vdmUoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICBjb25zdCBzID0gaC5maW5kKFxuICAgICAgICB2YSxcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgICAgc1tuXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1zbGlkZS10b1wiKSxcbiAgICAgICAgICAxMFxuICAgICAgICApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgodCkpIHtcbiAgICAgICAgICBzW25dLnNldEF0dHJpYnV0ZShgJHtXdH1gLCBcIlwiKSwgc1tuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpLCBzW25dLmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IGguZmluZE9uZShUdCwgdGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICB0LmdldEF0dHJpYnV0ZShcImRhdGEtdHdlLWludGVydmFsXCIpLFxuICAgICAgMTBcbiAgICApO1xuICAgIGUgPyAodGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlKSA6IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICB9XG4gIF9zbGlkZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX2RpcmVjdGlvblRvT3JkZXIodCksIG4gPSBoLmZpbmRPbmUoXG4gICAgICBUdCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCByID0gdGhpcy5fZ2V0SXRlbUluZGV4KG4pLCBvID0gZSB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihzLCBuKSwgYSA9IHRoaXMuX2dldEl0ZW1JbmRleChvKSwgbCA9ICEhdGhpcy5faW50ZXJ2YWwsIHUgPSBzID09PSBodCwgYyA9IHUgPyBCZSA6IHVhLCBmID0gdSA/IGhhIDogZmEsIHYgPSB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKHMpLCBnID0gYyA9PT0gQmUgPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCwgTyA9IGMgIT09IEJlID8gdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnQgOiB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQ7XG4gICAgaWYgKG8gJiYgby5oYXNBdHRyaWJ1dGUoV3QpKSB7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZyB8fCB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChvLCB2KS5kZWZhdWx0UHJldmVudGVkIHx8ICFuIHx8ICFvKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9ICEwLCBsICYmIHRoaXMucGF1c2UoKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChvKSwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG87XG4gICAgY29uc3QgQSA9ICgpID0+IHtcbiAgICAgIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXZSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBvLFxuICAgICAgICBkaXJlY3Rpb246IHYsXG4gICAgICAgIGZyb206IHIsXG4gICAgICAgIHRvOiBhXG4gICAgICB9KTtcbiAgICB9O1xuICAgIG8uc2V0QXR0cmlidXRlKGAke2Z9YCwgXCJcIiksIG8uY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrLCBPKSwgWHQobyksIG4uc2V0QXR0cmlidXRlKGAke2N9YCwgXCJcIiksIG4uY2xhc3NMaXN0LmFkZChcbiAgICAgIGcsXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICApLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIG8uc2V0QXR0cmlidXRlKGAke2N9YCwgXCJcIiksIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgby5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LFxuICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnRcbiAgICApO1xuICAgIGNvbnN0IEQgPSAoKSA9PiB7XG4gICAgICBvLnJlbW92ZUF0dHJpYnV0ZShjKSwgby5yZW1vdmVBdHRyaWJ1dGUoZiksIG8uc2V0QXR0cmlidXRlKGAke1d0fWAsIFwiXCIpLCBuLnJlbW92ZUF0dHJpYnV0ZShXdCksIG4uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgZyxcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrXG4gICAgICApLCBuLnJlbW92ZUF0dHJpYnV0ZShmKSwgbi5yZW1vdmVBdHRyaWJ1dGUoYyksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBzZXRUaW1lb3V0KEEsIDApO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhELCBuLCAhMCksIChsIHx8IHRoaXMuX2NvbmZpZy5yaWRlID09PSAhMCkgJiYgdGhpcy5jeWNsZSgpO1xuICB9XG4gIF9kaXJlY3Rpb25Ub09yZGVyKHQpIHtcbiAgICByZXR1cm4gW1l0LCBwdF0uaW5jbHVkZXModCkgPyBNKCkgPyB0ID09PSBwdCA/IGZ0IDogaHQgOiB0ID09PSBwdCA/IGh0IDogZnQgOiB0O1xuICB9XG4gIF9vcmRlclRvRGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4gW2h0LCBmdF0uaW5jbHVkZXModCkgPyBNKCkgPyB0ID09PSBmdCA/IHB0IDogWXQgOiB0ID09PSBmdCA/IFl0IDogcHQgOiB0O1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgY2Fyb3VzZWxJbnRlcmZhY2UodCwgZSkge1xuICAgIGNvbnN0IHMgPSBaLmdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSk7XG4gICAgbGV0IHsgX2NvbmZpZzogbiB9ID0gcztcbiAgICB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIChuID0ge1xuICAgICAgLi4ubixcbiAgICAgIC4uLmVcbiAgICB9KTtcbiAgICBjb25zdCByID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLnNsaWRlO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBzLnRvKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHR5cGVvZiBzW3JdID4gXCJ1XCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7cn1cImApO1xuICAgICAgc1tyXSgpO1xuICAgIH0gZWxzZVxuICAgICAgbi5pbnRlcnZhbCAmJiBuLnJpZGUgPT09ICEwICYmIHMucGF1c2UoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSBaLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBlLnRvKHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBkYXRhQXBpQ2xpY2tIYW5kbGVyKHQpIHtcbiAgICBjb25zdCBlID0gbnQodGhpcyk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSB7XG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4uRS5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxuICAgIH0sIG4gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdHdlLXNsaWRlLXRvXCIpO1xuICAgIG4gJiYgKHMuaW50ZXJ2YWwgPSAhMSksIFouY2Fyb3VzZWxJbnRlcmZhY2UoZSwgcyksIG4gJiYgWi5nZXRJbnN0YW5jZShlKS50byhuKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5jb25zdCBUYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJiYWNrZ3JvdW5kXCIsXG4gIFwiY2l0ZVwiLFxuICBcImhyZWZcIixcbiAgXCJpdGVtdHlwZVwiLFxuICBcImxvbmdkZXNjXCIsXG4gIFwicG9zdGVyXCIsXG4gIFwic3JjXCIsXG4gIFwieGxpbms6aHJlZlwiXG5dKSwgeWEgPSAvXmFyaWEtW1xcdy1dKiQvaSwgQWEgPSAvXmRhdGEtdHdlLVtcXHctXSokL2ksIENhID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaSwgT2EgPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pLCBEYSA9IChpLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBpLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmICh0LmluY2x1ZGVzKGUpKVxuICAgIHJldHVybiBUYS5oYXMoZSkgPyAhIShDYS50ZXN0KGkubm9kZVZhbHVlKSB8fCBPYS50ZXN0KGkubm9kZVZhbHVlKSkgOiAhMDtcbiAgY29uc3QgcyA9IHQuZmlsdGVyKFxuICAgIChuKSA9PiBuIGluc3RhbmNlb2YgUmVnRXhwXG4gICk7XG4gIGZvciAobGV0IG4gPSAwLCByID0gcy5sZW5ndGg7IG4gPCByOyBuKyspXG4gICAgaWYgKHNbbl0udGVzdChlKSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufSwgTmEgPSB7XG4gIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gIFwiKlwiOiBbXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiZGlyXCIsXG4gICAgXCJpZFwiLFxuICAgIFwibGFuZ1wiLFxuICAgIFwicm9sZVwiLFxuICAgIHlhLFxuICAgIEFhXG4gIF0sXG4gIGE6IFtcInRhcmdldFwiLCBcImhyZWZcIiwgXCJ0aXRsZVwiLCBcInJlbFwiXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogW1wic3JjXCIsIFwic3Jjc2V0XCIsIFwiYWx0XCIsIFwidGl0bGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufTtcbmZ1bmN0aW9uIGRzKGksIHQsIGUpIHtcbiAgaWYgKCFpLmxlbmd0aClcbiAgICByZXR1cm4gaTtcbiAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlKGkpO1xuICBjb25zdCBuID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaSwgXCJ0ZXh0L2h0bWxcIiksIHIgPSBbXS5jb25jYXQoLi4ubi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKTtcbiAgZm9yIChsZXQgbyA9IDAsIGEgPSByLmxlbmd0aDsgbyA8IGE7IG8rKykge1xuICAgIGNvbnN0IGwgPSByW29dLCB1ID0gbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghT2JqZWN0LmtleXModCkuaW5jbHVkZXModSkpIHtcbiAgICAgIGwucmVtb3ZlKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYyA9IFtdLmNvbmNhdCguLi5sLmF0dHJpYnV0ZXMpLCBmID0gW10uY29uY2F0KFxuICAgICAgdFtcIipcIl0gfHwgW10sXG4gICAgICB0W3VdIHx8IFtdXG4gICAgKTtcbiAgICBjLmZvckVhY2goKHYpID0+IHtcbiAgICAgIERhKHYsIGYpIHx8IGwucmVtb3ZlQXR0cmlidXRlKHYubm9kZU5hbWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuLmJvZHkuaW5uZXJIVE1MO1xufVxuY29uc3QgdXMgPSBcInRvb2x0aXBcIiwgU2EgPSBcInR3ZS50b29sdGlwXCIsIHogPSBgLiR7U2F9YCwgTGEgPSBcInRlLXRvb2x0aXBcIiwgJGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJzYW5pdGl6ZVwiLCBcImFsbG93TGlzdFwiLCBcInNhbml0aXplRm5cIl0pLCBJYSA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgdGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHRpdGxlOiBcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIixcbiAgdHJpZ2dlcjogXCJzdHJpbmdcIixcbiAgZGVsYXk6IFwiKG51bWJlcnxvYmplY3QpXCIsXG4gIGh0bWw6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RvcjogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHBsYWNlbWVudDogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgY29udGFpbmVyOiBcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFwiYXJyYXlcIixcbiAgYm91bmRhcnk6IFwiKHN0cmluZ3xlbGVtZW50KVwiLFxuICBjdXN0b21DbGFzczogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBzYW5pdGl6ZTogXCJib29sZWFuXCIsXG4gIHNhbml0aXplRm46IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFsbG93TGlzdDogXCJvYmplY3RcIixcbiAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIlxufSwgUmEgPSB7XG4gIEFVVE86IFwiYXV0b1wiLFxuICBUT1A6IFwidG9wXCIsXG4gIFJJR0hUOiBNKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgQk9UVE9NOiBcImJvdHRvbVwiLFxuICBMRUZUOiBNKCkgPyBcInJpZ2h0XCIgOiBcImxlZnRcIlxufSwgeGEgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cIm9wYWNpdHktMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IGFic29sdXRlIHotWzEwODBdIGJsb2NrIG0tMCB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWxcIiByb2xlPVwidG9vbHRpcFwiPlxuICAgICAgPGRpdiBkYXRhLXR3ZS10b29sdGlwLWlubmVyLXJlZiBjbGFzcz1cIm1heC13LVsyMDBweF0gdGV4dC1zbSBweS0xLjUgcHgtNCB0ZXh0LXdoaXRlIHRleHQtY2VudGVyIGJnLVsjNmQ2ZDZkXSByb3VuZGVkXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgdHJpZ2dlcjogXCJob3ZlciBmb2N1c1wiLFxuICB0aXRsZTogXCJcIixcbiAgZGVsYXk6IDAsXG4gIGh0bWw6ICExLFxuICBzZWxlY3RvcjogITEsXG4gIHBsYWNlbWVudDogXCJ0b3BcIixcbiAgb2Zmc2V0OiBbMCwgMF0sXG4gIGNvbnRhaW5lcjogITEsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLFxuICBib3VuZGFyeTogXCJjbGlwcGluZ1BhcmVudHNcIixcbiAgY3VzdG9tQ2xhc3M6IFwiXCIsXG4gIHNhbml0aXplOiAhMCxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgYWxsb3dMaXN0OiBOYSxcbiAgcG9wcGVyQ29uZmlnOiB7IGhpZGU6ICEwIH1cbn0sIGthID0ge1xuICBISURFOiBgaGlkZSR7en1gLFxuICBISURERU46IGBoaWRkZW4ke3p9YCxcbiAgU0hPVzogYHNob3cke3p9YCxcbiAgU0hPV046IGBzaG93biR7en1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHt6fWAsXG4gIENMSUNLOiBgY2xpY2ske3p9YCxcbiAgRk9DVVNJTjogYGZvY3VzaW4ke3p9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7en1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7en1gLFxuICBNT1VTRUxFQVZFOiBgbW91c2VsZWF2ZSR7en1gXG59LCBQYSA9IFwiZmFkZVwiLCBNYSA9IFwibW9kYWxcIiwgamUgPSBcInNob3dcIiwgQnQgPSBcInNob3dcIiwgVWUgPSBcIm91dFwiLCBocyA9IFwiW2RhdGEtdHdlLXRvb2x0aXAtaW5uZXItcmVmXVwiLCBmcyA9IGAuJHtNYX1gLCBwcyA9IFwiaGlkZS50d2UubW9kYWxcIiwganQgPSBcImhvdmVyXCIsIEZlID0gXCJmb2N1c1wiLCBIYSA9IFwiY2xpY2tcIiwgVmEgPSBcIm1hbnVhbFwiO1xuY2xhc3MgUXQgZXh0ZW5kcyB0dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBpZiAodHlwZW9mIGJuID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgc3VwZXIodCksIHRoaXMuX2lzRW5hYmxlZCA9ICEwLCB0aGlzLl90aW1lb3V0ID0gMCwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCIsIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fSwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLnRpcCA9IG51bGwsIHRoaXMuX3NldExpc3RlbmVycygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB4YTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHVzO1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIGthO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIElhO1xuICB9XG4gIC8vIFB1YmxpY1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gITA7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMTtcbiAgfVxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XG4gIH1cbiAgdG9nZ2xlKHQpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKVxuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0KTtcbiAgICAgICAgZS5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrLCBlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgPyBlLl9lbnRlcihudWxsLCBlKSA6IGUuX2xlYXZlKG51bGwsIGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhqZSkpIHtcbiAgICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIGQub2ZmKFxuICAgICAgdGhpcy5fZWxlbWVudC5jbG9zZXN0KGZzKSxcbiAgICAgIHBzLFxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlclxuICAgICksIHRoaXMudGlwICYmIHRoaXMudGlwLnJlbW92ZSgpLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHNcIik7XG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV1xuICAgICksIGUgPSBNcyh0aGlzLl9lbGVtZW50KSwgcyA9IGUgPT09IG51bGwgPyB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpIDogZS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodC5kZWZhdWx0UHJldmVudGVkIHx8ICFzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY29uc3RydWN0b3IuTkFNRSA9PT0gXCJ0b29sdGlwXCIgJiYgdGhpcy50aXAgJiYgdGhpcy5nZXRUaXRsZSgpICE9PSB0aGlzLnRpcC5xdWVyeVNlbGVjdG9yKGhzKS5pbm5lckhUTUwgJiYgKHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMudGlwID0gbnVsbCk7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCByID0gR24odGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcbiAgICBuLnNldEF0dHJpYnV0ZShcImlkXCIsIHIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgciksIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRpcC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0xMDBcIiksIHRoaXMudGlwLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIik7XG4gICAgfSwgMTAwKTtcbiAgICBjb25zdCBvID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIG4sIHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnBsYWNlbWVudCwgYSA9IHRoaXMuX2dldEF0dGFjaG1lbnQobyk7XG4gICAgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKGEpO1xuICAgIGNvbnN0IHsgY29udGFpbmVyOiBsIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKFYuc2V0RGF0YShuLCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkgfHwgKGwuYXBwZW5kKG4pLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCkpLCB0aGlzLl9wb3BwZXIgPyB0aGlzLl9wb3BwZXIudXBkYXRlKCkgOiB0aGlzLl9wb3BwZXIgPSBUaShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBuLFxuICAgICAgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGEpXG4gICAgKSwgbi5nZXRBdHRyaWJ1dGUoXCJpZFwiKS5pbmNsdWRlcyhcInRvb2x0aXBcIikpXG4gICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweC1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweS1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjb25zdCBjID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmN1c3RvbUNsYXNzKTtcbiAgICBjICYmIG4uY2xhc3NMaXN0LmFkZCguLi5jLnNwbGl0KFwiIFwiKSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChnKSA9PiB7XG4gICAgICBkLm9uKGcsIFwibW91c2VvdmVyXCIsIG1lKTtcbiAgICB9KTtcbiAgICBjb25zdCBmID0gKCkgPT4ge1xuICAgICAgY29uc3QgZyA9IHRoaXMuX2hvdmVyU3RhdGU7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbCwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pLCBnID09PSBVZSAmJiB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICB9LCB2ID0gdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKFwidHJhbnNpdGlvbi1vcGFjaXR5XCIpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZiwgdGhpcy50aXAsIHYpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9wb3BwZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpIHx8ICh0aGlzLl9ob3ZlclN0YXRlICE9PSBCdCAmJiB0LnJlbW92ZSgpLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiKSwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKSwgdGhpcy5fZGlzcG9zZVBvcHBlcigpKTtcbiAgICB9O1xuICAgIGlmIChkLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFXG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChyKSA9PiBkLm9mZihyLCBcIm1vdXNlb3ZlclwiLCBtZSkpLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW0hhXSA9ICExLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW0ZlXSA9ICExLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW2p0XSA9ICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJvcGFjaXR5LTBcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLnRpcCwgbiksIHRoaXMuX2hvdmVyU3RhdGUgPSBcIlwiO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9wb3BwZXIgIT09IG51bGwgJiYgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8vIFByb3RlY3RlZFxuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0VGl0bGUoKTtcbiAgfVxuICBnZXRUaXBFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnRpcClcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmlubmVySFRNTCA9IHRoaXMuX2NvbmZpZy50ZW1wbGF0ZTtcbiAgICBjb25zdCBlID0gdC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gdGhpcy5zZXRDb250ZW50KGUpLCBlLmNsYXNzTGlzdC5yZW1vdmUoUGEsIGplKSwgdGhpcy50aXAgPSBlLCB0aGlzLnRpcDtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCBocyk7XG4gIH1cbiAgX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IGguZmluZE9uZShzLCB0KTtcbiAgICBpZiAoIWUgJiYgbikge1xuICAgICAgbi5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChuLCBlKTtcbiAgfVxuICBzZXRFbGVtZW50Q29udGVudCh0LCBlKSB7XG4gICAgaWYgKHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChTdChlKSkge1xuICAgICAgICBlID0gcnQoZSksIHRoaXMuX2NvbmZpZy5odG1sID8gZS5wYXJlbnROb2RlICE9PSB0ICYmICh0LmlubmVySFRNTCA9IFwiXCIsIHQuYXBwZW5kKGUpKSA6IHQudGV4dENvbnRlbnQgPSBlLnRleHRDb250ZW50O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcuaHRtbCA/ICh0aGlzLl9jb25maWcuc2FuaXRpemUgJiYgKGUgPSBkcyhcbiAgICAgICAgZSxcbiAgICAgICAgdGhpcy5fY29uZmlnLmFsbG93TGlzdCxcbiAgICAgICAgdGhpcy5fY29uZmlnLnNhbml0aXplRm5cbiAgICAgICkpLCB0LmlubmVySFRNTCA9IGUpIDogdC50ZXh0Q29udGVudCA9IGU7XG4gICAgfVxuICB9XG4gIGdldFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHdlLW9yaWdpbmFsLXRpdGxlXCIpIHx8IHRoaXMuX2NvbmZpZy50aXRsZTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCk7XG4gIH1cbiAgdXBkYXRlQXR0YWNobWVudCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IFwicmlnaHRcIiA/IFwiZW5kXCIgOiB0ID09PSBcImxlZnRcIiA/IFwic3RhcnRcIiA6IHQ7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpIHtcbiAgICByZXR1cm4gZSB8fCB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoXG4gICAgICB0LmRlbGVnYXRlVGFyZ2V0LFxuICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldDogdCB9ID0gdGhpcy5fY29uZmlnO1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdC5zcGxpdChcIixcIikubWFwKChlKSA9PiBOdW1iZXIucGFyc2VJbnQoZSwgMTApKSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChlKSA9PiB0KGUsIHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0LmNhbGwodGhpcy5fZWxlbWVudCkgOiB0O1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHQsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogdGhpcy5fY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYXJyb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBlbGVtZW50OiBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hcnJvd2BcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9uQ2hhbmdlXCIsXG4gICAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgICAgcGhhc2U6IFwiYWZ0ZXJXcml0ZVwiLFxuICAgICAgICAgIGZuOiAocykgPT4gdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHMpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbkZpcnN0VXBkYXRlOiAocykgPT4ge1xuICAgICAgICBzLm9wdGlvbnMucGxhY2VtZW50ICE9PSBzLnBsYWNlbWVudCAmJiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2Uocyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZSxcbiAgICAgIC4uLnR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZSkgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfTtcbiAgfVxuICBfYWRkQXR0YWNobWVudENsYXNzKHQpIHtcbiAgICB0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFxuICAgICAgYCR7dGhpcy5fZ2V0QmFzaWNDbGFzc1ByZWZpeCgpfS0ke3RoaXMudXBkYXRlQXR0YWNobWVudCh0KX1gXG4gICAgKTtcbiAgfVxuICBfZ2V0QXR0YWNobWVudCh0KSB7XG4gICAgcmV0dXJuIFJhW3QudG9VcHBlckNhc2UoKV07XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdChcIiBcIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUgPT09IFwiY2xpY2tcIilcbiAgICAgICAgZC5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChzKSA9PiB0aGlzLnRvZ2dsZShzKVxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAoZSAhPT0gVmEpIHtcbiAgICAgICAgY29uc3QgcyA9IGUgPT09IGp0ID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOLCBuID0gZSA9PT0ganQgPyB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuICAgICAgICBkLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgcyxcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKHIpID0+IHRoaXMuX2VudGVyKHIpXG4gICAgICAgICksIGQub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAocikgPT4gdGhpcy5fbGVhdmUocilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSwgZC5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChmcyksXG4gICAgICBwcyxcbiAgICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXJcbiAgICApLCB0aGlzLl9jb25maWcuc2VsZWN0b3IgPyB0aGlzLl9jb25maWcgPSB7XG4gICAgICAuLi50aGlzLl9jb25maWcsXG4gICAgICB0cmlnZ2VyOiBcIm1hbnVhbFwiLFxuICAgICAgc2VsZWN0b3I6IFwiXCJcbiAgICB9IDogdGhpcy5fZml4VGl0bGUoKTtcbiAgfVxuICBfZml4VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGl0bGVcIiksIGUgPSB0eXBlb2YgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXG4gICAgICBcImRhdGEtdHdlLW9yaWdpbmFsLXRpdGxlXCJcbiAgICApO1xuICAgICh0IHx8IGUgIT09IFwic3RyaW5nXCIpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdHdlLW9yaWdpbmFsLXRpdGxlXCIsIHQgfHwgXCJcIiksIHQgJiYgIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudCAmJiB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgXCJcIikpO1xuICB9XG4gIF9lbnRlcih0LCBlKSB7XG4gICAgaWYgKGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSksIHQgJiYgKGUuX2FjdGl2ZVRyaWdnZXJbdC50eXBlID09PSBcImZvY3VzaW5cIiA/IEZlIDoganRdID0gITApLCBlLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoamUpIHx8IGUuX2hvdmVyU3RhdGUgPT09IEJ0KSB7XG4gICAgICBlLl9ob3ZlclN0YXRlID0gQnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGVhclRpbWVvdXQoZS5fdGltZW91dCksIGUuX2hvdmVyU3RhdGUgPSBCdCwgIWUuX2NvbmZpZy5kZWxheSB8fCAhZS5fY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgIGUuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlLl9ob3ZlclN0YXRlID09PSBCdCAmJiBlLnNob3coKTtcbiAgICB9LCBlLl9jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cbiAgX2xlYXZlKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNvdXRcIiA/IEZlIDoganRdID0gZS5fZWxlbWVudC5jb250YWlucyh0LnJlbGF0ZWRUYXJnZXQpKSwgIWUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IFVlLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgICBlLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlLl9ob3ZlclN0YXRlID09PSBVZSAmJiBlLmhpZGUoKTtcbiAgICAgIH0sIGUuX2NvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9XG4gIH1cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0IGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVHJpZ2dlclt0XSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gRS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgJGEuaGFzKHMpICYmIGRlbGV0ZSBlW3NdO1xuICAgIH0pLCB0ID0ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIHQuY29udGFpbmVyID0gdC5jb250YWluZXIgPT09ICExID8gZG9jdW1lbnQuYm9keSA6IHJ0KHQuY29udGFpbmVyKSwgdHlwZW9mIHQuZGVsYXkgPT0gXCJudW1iZXJcIiAmJiAodC5kZWxheSA9IHtcbiAgICAgIHNob3c6IHQuZGVsYXksXG4gICAgICBoaWRlOiB0LmRlbGF5XG4gICAgfSksIHR5cGVvZiB0LnRpdGxlID09IFwibnVtYmVyXCIgJiYgKHQudGl0bGUgPSB0LnRpdGxlLnRvU3RyaW5nKCkpLCB0eXBlb2YgdC5jb250ZW50ID09IFwibnVtYmVyXCIgJiYgKHQuY29udGVudCA9IHQuY29udGVudC50b1N0cmluZygpKSwgUih1cywgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQuc2FuaXRpemUgJiYgKHQudGVtcGxhdGUgPSBkcyhcbiAgICAgIHQudGVtcGxhdGUsXG4gICAgICB0LmFsbG93TGlzdCxcbiAgICAgIHQuc2FuaXRpemVGblxuICAgICkpLCB0O1xuICB9XG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMuX2NvbmZpZylcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlXSAhPT0gdGhpcy5fY29uZmlnW2VdICYmICh0W2VdID0gdGhpcy5fY29uZmlnW2VdKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSBuZXcgUmVnRXhwKFxuICAgICAgYChefFxcXFxzKSR7dGhpcy5fZ2V0QmFzaWNDbGFzc1ByZWZpeCgpfVxcXFxTK2AsXG4gICAgICBcImdcIlxuICAgICksIHMgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLm1hdGNoKGUpO1xuICAgIHMgIT09IG51bGwgJiYgcy5sZW5ndGggPiAwICYmIHMubWFwKChuKSA9PiBuLnRyaW0oKSkuZm9yRWFjaCgobikgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKG4pKTtcbiAgfVxuICBfZ2V0QmFzaWNDbGFzc1ByZWZpeCgpIHtcbiAgICByZXR1cm4gTGE7XG4gIH1cbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSh0KSB7XG4gICAgY29uc3QgeyBzdGF0ZTogZSB9ID0gdDtcbiAgICBlICYmICh0aGlzLnRpcCA9IGUuZWxlbWVudHMucG9wcGVyLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KGUucGxhY2VtZW50KSkpO1xuICB9XG4gIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fcG9wcGVyID0gbnVsbCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gUXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFdhID0gXCJwb3BvdmVyXCIsIEJhID0gXCJ0d2UucG9wb3ZlclwiLCBxID0gYC4ke0JhfWAsIGphID0gXCJ0ZS1wb3BvdmVyXCIsIFVhID0ge1xuICAuLi5RdC5EZWZhdWx0LFxuICBwbGFjZW1lbnQ6IFwicmlnaHRcIixcbiAgb2Zmc2V0OiBbMCwgOF0sXG4gIHRyaWdnZXI6IFwiY2xpY2tcIixcbiAgY29udGVudDogXCJcIixcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHotWzEwNzBdIGJsb2NrIG1heC13LVsyNjdweF0gYnJlYWstd29yZHMgYmctd2hpdGUgYmctY2xpcC1wYWRkaW5nIGJvcmRlciBib3JkZXItbmV1dHJhbC0xMDAgcm91bmRlZC1sZyBzaGFkb3ctMiB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWwgZGFyazpib3JkZXItd2hpdGUvMTAgZGFyazpiZy1zdXJmYWNlLWRhcmsgZGFyazp0ZXh0LXdoaXRlIGRhdGEtW3BvcHBlci1yZWZlcmVuY2UtaGlkZGVuXTpoaWRkZW5cIiByb2xlPVwidG9vbHRpcFwiPlxuICAgICAgPGgzIGRhdGEtdHdlLXBvcG92ZXItaGVhZGVyLXJlZiBjbGFzcz1cInB5LTIgcHgtNCBtYi0wIGJvcmRlci1iLTIgYm9yZGVyLW5ldXRyYWwtMTAwIHJvdW5kZWQtdC1sZyBmb250LW1lZGl1bSBlbXB0eTpoaWRkZW4gZGFyazpib3JkZXItd2hpdGUvMTBcIj48L2gzPlxuICAgICAgPGRpdiBkYXRhLXR3ZS1wb3BvdmVyLWJvZHktcmVmIGNsYXNzPVwicC00IHRleHQtc3VyZmFjZSBkYXJrOnRleHQtd2hpdGVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgXG59LCBGYSA9IHtcbiAgLi4uUXQuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG59LCBZYSA9IHtcbiAgSElERTogYGhpZGUke3F9YCxcbiAgSElEREVOOiBgaGlkZGVuJHtxfWAsXG4gIFNIT1c6IGBzaG93JHtxfWAsXG4gIFNIT1dOOiBgc2hvd24ke3F9YCxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7cX1gLFxuICBDTElDSzogYGNsaWNrJHtxfWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtxfWAsXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke3F9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke3F9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke3F9YFxufSwgS2EgPSBcIltkYXRhLXR3ZS1wb3BvdmVyLWhlYWRlci1yZWZdXCIsIHphID0gXCJbZGF0YS10d2UtcG9wb3Zlci1ib2R5LXJlZl1cIjtcbmNsYXNzIE5uIGV4dGVuZHMgUXQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gVWE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBXYTtcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBZYTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBGYTtcbiAgfVxuICAvLyBPdmVycmlkZXNcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCBLYSksIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLl9nZXRDb250ZW50KCksIHphKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIGphO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IE5uLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBZZSA9IFwic2Nyb2xsc3B5XCIsIHFhID0gXCJ0d2Uuc2Nyb2xsc3B5XCIsIENpID0gYC4ke3FhfWAsIF9zID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6IFwiYXV0b1wiLFxuICB0YXJnZXQ6IFwiXCJcbn0sIFhhID0ge1xuICBvZmZzZXQ6IFwibnVtYmVyXCIsXG4gIG1ldGhvZDogXCJzdHJpbmdcIixcbiAgdGFyZ2V0OiBcIihzdHJpbmd8ZWxlbWVudClcIlxufSwgR2EgPSB7XG4gIGFjdGl2ZTogXCIhdGV4dC1wcmltYXJ5IGZvbnQtc2VtaWJvbGQgYm9yZGVyLXMtWzAuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLXByaW1hcnlcIlxufSwgUWEgPSB7XG4gIGFjdGl2ZTogXCJzdHJpbmdcIlxufSwgS2UgPSBgYWN0aXZhdGUke0NpfWAsIFphID0gYHNjcm9sbCR7Q2l9YCwgS3QgPSBcImRhdGEtdHdlLW5hdi1saW5rLWFjdGl2ZVwiLCBTbiA9IFwiZGF0YS10d2UtY29sbGFwc2libGUtc2Nyb2xsc3B5LXJlZlwiLCBMbiA9IFwiW2RhdGEtdHdlLWRyb3Bkb3duLWl0ZW0tcmVmXVwiLCBKYSA9IFwiW2RhdGEtdHdlLW5hdi1saXN0LXJlZl1cIiwgb2kgPSBcIltkYXRhLXR3ZS1uYXYtbGluay1yZWZdXCIsIHRsID0gXCJbZGF0YS10d2UtbmF2LWl0ZW0tcmVmXVwiLCAkbiA9IFwiW2RhdGEtdHdlLWxpc3QtZ3JvdXAtaXRlbS1yZWZdXCIsIHplID0gYCR7b2l9LCAkeyRufSwgJHtMbn1gLCBlbCA9IFwiW2RhdGEtdHdlLWRyb3Bkb3duLXJlZl1cIiwgaWwgPSBcIltkYXRhLXR3ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBncyA9IGBbJHtTbn1dYCwgc2wgPSBgWyR7S3R9XWAsIHFlID0gXCJ1bFwiLCBubCA9IFwibWF4T2Zmc2V0XCIsIG1zID0gXCJwb3NpdGlvblwiO1xuY2xhc3MgSW4gZXh0ZW5kcyB0dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIgPyB3aW5kb3cgOiB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKHMpLCB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fY29sbGFwc2libGVzID0gW10sIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGwsIHRoaXMuX3Njcm9sbEhlaWdodCA9IDAsIGQub24odGhpcy5fc2Nyb2xsRWxlbWVudCwgWmEsICgpID0+IHRoaXMuX3Byb2Nlc3MoKSksIHRoaXMucmVmcmVzaCgpLCB0aGlzLl9wcm9jZXNzKCksIHRoaXMuX2JpbmRBY3RpdmF0ZUV2ZW50KCksIHRoaXMuX2dldENvbGxhcHNpYmxlcygpLCB0aGlzLl9jb2xsYXBzaWJsZXMubGVuZ3RoICE9PSAwICYmICh0aGlzLl9zaG93U3Vic2VjdGlvbigpLCB0aGlzLl9oaWRlU3Vic2VjdGlvbigpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gX3M7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBZZTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBubCA6IG1zLCBlID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gXCJhdXRvXCIgPyB0IDogdGhpcy5fY29uZmlnLm1ldGhvZCwgcyA9IGUgPT09IG1zID8gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwO1xuICAgIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgaC5maW5kKFxuICAgICAgemUsXG4gICAgICB0aGlzLl9jb25maWcudGFyZ2V0XG4gICAgKS5tYXAoKHIpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBjaShyKSwgYSA9IG8gPyBoLmZpbmRPbmUobykgOiBudWxsO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsLndpZHRoIHx8IGwuaGVpZ2h0KVxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBFW2VdKGEpLnRvcCArIHMsXG4gICAgICAgICAgICBvXG4gICAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcigocikgPT4gcikuc29ydCgociwgbykgPT4gclswXSAtIG9bMF0pLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHRoaXMuX29mZnNldHMucHVzaChyWzBdKSwgdGhpcy5fdGFyZ2V0cy5wdXNoKHJbMV0pO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgZC5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgQ2kpLCBkLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCBLZSksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uX3MsXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC50YXJnZXQgPSBydCh0LnRhcmdldCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBSKFllLCB0LCBYYSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5HYSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgUihZZSwgdCwgUWEpLCB0O1xuICB9XG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cbiAgX3Byb2Nlc3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldCwgZSA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBzID0gdGhpcy5fY29uZmlnLm9mZnNldCArIGUgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBlICYmIHRoaXMucmVmcmVzaCgpLCB0ID49IHMpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IG4gJiYgdGhpcy5fYWN0aXZhdGUobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgdCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGwsIHRoaXMuX2NsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgbi0tOyApXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbbl0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW25dICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tuICsgMV0gPiBcInVcIiB8fCB0IDwgdGhpcy5fb2Zmc2V0c1tuICsgMV0pICYmIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbbl0pO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdCwgdGhpcy5fY2xlYXIoKTtcbiAgICBjb25zdCBlID0gemUuc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgIChuKSA9PiBgJHtufVtkYXRhLXR3ZS10YXJnZXQ9XCIke3R9XCJdLCR7bn1baHJlZj1cIiR7dH1cIl1gXG4gICAgKSwgcyA9IGguZmluZE9uZShlLmpvaW4oXCIsXCIpLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICBzLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSwgcy5zZXRBdHRyaWJ1dGUoS3QsIFwiXCIpLCBzLmdldEF0dHJpYnV0ZShMbikgPyBoLmZpbmRPbmUoXG4gICAgICBpbCxcbiAgICAgIHMuY2xvc2VzdChlbClcbiAgICApLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSA6IGgucGFyZW50cyhzLCBKYSkuZm9yRWFjaChcbiAgICAgIChuKSA9PiB7XG4gICAgICAgIGgucHJldihcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke29pfSwgJHskbn1gXG4gICAgICAgICkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICAgIHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCByLnNldEF0dHJpYnV0ZShLdCwgXCJcIik7XG4gICAgICAgIH0pLCBoLnByZXYobiwgdGwpLmZvckVhY2goXG4gICAgICAgICAgKHIpID0+IHtcbiAgICAgICAgICAgIGguY2hpbGRyZW4ociwgb2kpLmZvckVhY2goXG4gICAgICAgICAgICAgIChvKSA9PiBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgZC50cmlnZ2VyKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEtlLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSk7XG4gIH1cbiAgX2NsZWFyKCkge1xuICAgIGguZmluZCh6ZSwgdGhpcy5fY29uZmlnLnRhcmdldCkuZmlsdGVyKFxuICAgICAgKHQpID0+IHQuY2xhc3NMaXN0LmNvbnRhaW5zKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSlcbiAgICApLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCB0LnJlbW92ZUF0dHJpYnV0ZShLdCk7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGUodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoXG4gICAgICBxZSxcbiAgICAgIHQucGFyZW50Tm9kZVxuICAgICk7XG4gICAgZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIGUuc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcbiAgfVxuICBfc2hvdyh0LCBlKSB7XG4gICAgdC5zdHlsZS5oZWlnaHQgPSBlO1xuICB9XG4gIF9nZXRDb2xsYXBzaWJsZXMoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZChcbiAgICAgIGdzXG4gICAgKTtcbiAgICB0ICYmIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgcyA9IGUucGFyZW50Tm9kZSwgbiA9IGguZmluZE9uZShxZSwgcyksIHIgPSBuLm9mZnNldEhlaWdodCB8fCBuLnNjcm9sbEhlaWdodDtcbiAgICAgIHRoaXMuX2NvbGxhcHNpYmxlcy5wdXNoKHtcbiAgICAgICAgZWxlbWVudDogbixcbiAgICAgICAgcmVsYXRlZFRhcmdldDogZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLFxuICAgICAgICBoZWlnaHQ6IGAke3J9cHhgXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2hvd1N1YnNlY3Rpb24oKSB7XG4gICAgaC5maW5kKHNsKS5maWx0ZXIoKHMpID0+IHMuaGFzQXR0cmlidXRlKFNuKSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3QgbiA9IGguZmluZE9uZShxZSwgcy5wYXJlbnROb2RlKSwgciA9IHRoaXMuX2NvbGxhcHNpYmxlcy5maW5kKChvKSA9PiBvLnJlbGF0ZWRUYXJnZXQgPSBzLmdldEF0dHJpYnV0ZShcImhyZWZcIikpLmhlaWdodDtcbiAgICAgIHRoaXMuX3Nob3cobiwgcik7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGVTdWJzZWN0aW9uKCkge1xuICAgIGguZmluZChcbiAgICAgIGdzXG4gICAgKS5maWx0ZXIoKGUpID0+IGUuaGFzQXR0cmlidXRlKEt0KSA9PT0gITEpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuX2hpZGUoZSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRBY3RpdmF0ZUV2ZW50KCkge1xuICAgIGQub24odGhpcy5fZWxlbWVudCwgS2UsICgpID0+IHtcbiAgICAgIHRoaXMuX3Nob3dTdWJzZWN0aW9uKCksIHRoaXMuX2hpZGVTdWJzZWN0aW9uKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gSW4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEVzID0gXCJ0YWJcIiwgcmwgPSBcInR3ZS50YWJcIiwgeWUgPSBgLiR7cmx9YCwgb2wgPSBgaGlkZSR7eWV9YCwgYWwgPSBgaGlkZGVuJHt5ZX1gLCBsbCA9IGBzaG93JHt5ZX1gLCBjbCA9IGBzaG93biR7eWV9YCwgZGwgPSBcImRhdGEtdHdlLWRyb3Bkb3duLW1lbnUtcmVmXCIsIE90ID0gXCJkYXRhLXR3ZS10YWItYWN0aXZlXCIsIGdlID0gXCJkYXRhLXR3ZS1uYXYtYWN0aXZlXCIsIHVsID0gXCJbZGF0YS10d2UtZHJvcGRvd24tcmVmXVwiLCBobCA9IFwiW2RhdGEtdHdlLW5hdi1yZWZdXCIsIHZzID0gYFske090fV1gLCBmbCA9IGBbJHtnZX1dYCwgYnMgPSBcIjpzY29wZSA+IGxpID4gLmFjdGl2ZVwiLCBwbCA9IFwiW2RhdGEtdHdlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIF9sID0gXCI6c2NvcGUgPiBbZGF0YS10d2UtZHJvcGRvd24tbWVudS1yZWZdIFtkYXRhLXR3ZS1kcm9wZG93bi1zaG93XVwiLCBnbCA9IHtcbiAgc2hvdzogXCJvcGFjaXR5LTEwMFwiLFxuICBoaWRlOiBcIm9wYWNpdHktMFwiXG59LCBtbCA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgaGlkZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFJuIGV4dGVuZHMgdHQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGUpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBFcztcbiAgfVxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoZ2UpID09PSBcIlwiKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IGUgPSBudCh0aGlzLl9lbGVtZW50KSwgcyA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChobCksIG4gPSBoLmZpbmRPbmUoXG4gICAgICBmbCxcbiAgICAgIHNcbiAgICApO1xuICAgIGlmIChzKSB7XG4gICAgICBjb25zdCBsID0gcy5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IHMubm9kZU5hbWUgPT09IFwiT0xcIiA/IGJzIDogdnM7XG4gICAgICB0ID0gaC5maW5kKGwsIHMpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCByID0gdCA/IGQudHJpZ2dlcih0LCBvbCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH0pIDogbnVsbDtcbiAgICBpZiAoZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxsLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCByICE9PSBudWxsICYmIHIuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBzLFxuICAgICAgbnVsbCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgZC50cmlnZ2VyKHQsIGFsLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgY2wsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBlID8gdGhpcy5fYWN0aXZhdGUoXG4gICAgICBlLFxuICAgICAgZS5wYXJlbnROb2RlLFxuICAgICAgYSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSA6IGEoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gRS5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZ2wsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIFIoRXMsIHQsIG1sKSwgdDtcbiAgfVxuICBfYWN0aXZhdGUodCwgZSwgcywgbiwgcikge1xuICAgIGNvbnN0IGEgPSAoZSAmJiAoZS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGUubm9kZU5hbWUgPT09IFwiT0xcIikgPyBoLmZpbmQoYnMsIGUpIDogaC5jaGlsZHJlbihlLCB2cykpWzBdLCBsID0gcyAmJiBhICYmIGEuaGFzQXR0cmlidXRlKE90KSwgdSA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcbiAgICAgIHQsXG4gICAgICBhLFxuICAgICAgcyxcbiAgICAgIG4sXG4gICAgICByXG4gICAgKTtcbiAgICBhICYmIGwgPyAoRS5yZW1vdmVDbGFzcyhhLCB0aGlzLl9jbGFzc2VzLnNob3cpLCBFLmFkZENsYXNzKGEsIHRoaXMuX2NsYXNzZXMuaGlkZSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodSwgdCwgITApKSA6IHUoKTtcbiAgfVxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKHQsIGUsIHMsIG4sIHIpIHtcbiAgICBpZiAoZSAmJiBuKSB7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShPdCksIG4ucmVtb3ZlQXR0cmlidXRlKGdlKTtcbiAgICAgIGNvbnN0IGEgPSBoLmZpbmRPbmUoXG4gICAgICAgIF9sLFxuICAgICAgICBlLnBhcmVudE5vZGVcbiAgICAgICk7XG4gICAgICBhICYmIGEucmVtb3ZlQXR0cmlidXRlKE90KSwgZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcInRhYlwiICYmIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSk7XG4gICAgfVxuICAgIHQuc2V0QXR0cmlidXRlKE90LCBcIlwiKSwgci5zZXRBdHRyaWJ1dGUoZ2UsIFwiXCIpLCB0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgWHQodCksIHQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2NsYXNzZXMuaGlkZSkgJiYgKEUucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgRS5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnNob3cpKTtcbiAgICBsZXQgbyA9IHQucGFyZW50Tm9kZTtcbiAgICBpZiAobyAmJiBvLm5vZGVOYW1lID09PSBcIkxJXCIgJiYgKG8gPSBvLnBhcmVudE5vZGUpLCBvICYmIG8uaGFzQXR0cmlidXRlKGRsKSkge1xuICAgICAgY29uc3QgYSA9IHQuY2xvc2VzdCh1bCk7XG4gICAgICBhICYmIGguZmluZChwbCwgYSkuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwuc2V0QXR0cmlidXRlKE90LCBcIlwiKVxuICAgICAgKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKTtcbiAgICB9XG4gICAgcyAmJiBzKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gUm4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbigoKSA9PiB7XG4gIHZhciBpID0geyA0NTQ6IChzLCBuLCByKSA9PiB7XG4gICAgci5kKG4sIHsgWjogKCkgPT4gbCB9KTtcbiAgICB2YXIgbyA9IHIoNjQ1KSwgYSA9IHIubihvKSgpKGZ1bmN0aW9uKHUpIHtcbiAgICAgIHJldHVybiB1WzFdO1xuICAgIH0pO1xuICAgIGEucHVzaChbcy5pZCwgXCJJTlBVVDotd2Via2l0LWF1dG9maWxsLFNFTEVDVDotd2Via2l0LWF1dG9maWxsLFRFWFRBUkVBOi13ZWJraXQtYXV0b2ZpbGx7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbHN0YXJ0fUlOUFVUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksU0VMRUNUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksVEVYVEFSRUE6bm90KDotd2Via2l0LWF1dG9maWxsKXthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsY2FuY2VsfUBrZXlmcmFtZXMgb25hdXRvZmlsbHN0YXJ0e31Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxjYW5jZWx7fVwiLCBcIlwiXSk7XG4gICAgY29uc3QgbCA9IGE7XG4gIH0sIDY0NTogKHMpID0+IHtcbiAgICBzLmV4cG9ydHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgciA9IFtdO1xuICAgICAgcmV0dXJuIHIudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIgYSA9IG4obyk7XG4gICAgICAgICAgcmV0dXJuIG9bMl0gPyBcIkBtZWRpYSBcIi5jb25jYXQob1syXSwgXCIge1wiKS5jb25jYXQoYSwgXCJ9XCIpIDogYTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH0sIHIuaSA9IGZ1bmN0aW9uKG8sIGEsIGwpIHtcbiAgICAgICAgdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAobyA9IFtbbnVsbCwgbywgXCJcIl1dKTtcbiAgICAgICAgdmFyIHUgPSB7fTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHRoaXNbY11bMF07XG4gICAgICAgICAgICBmICE9IG51bGwgJiYgKHVbZl0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IG8ubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICB2YXIgZyA9IFtdLmNvbmNhdChvW3ZdKTtcbiAgICAgICAgICBsICYmIHVbZ1swXV0gfHwgKGEgJiYgKGdbMl0gPyBnWzJdID0gXCJcIi5jb25jYXQoYSwgXCIgYW5kIFwiKS5jb25jYXQoZ1syXSkgOiBnWzJdID0gYSksIHIucHVzaChnKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHI7XG4gICAgfTtcbiAgfSwgODEwOiAoKSA9PiB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcyA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJ0ZXN0XCIsIHsgY2FuY2VsYWJsZTogITAgfSk7XG4gICAgICAgICAgaWYgKHMucHJldmVudERlZmF1bHQoKSwgcy5kZWZhdWx0UHJldmVudGVkICE9PSAhMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwcmV2ZW50IGRlZmF1bHRcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHZhciBuID0gZnVuY3Rpb24obywgYSkge1xuICAgICAgICAgICAgdmFyIGwsIHU7XG4gICAgICAgICAgICByZXR1cm4gKGEgPSBhIHx8IHt9KS5idWJibGVzID0gISFhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSA9ICEhYS5jYW5jZWxhYmxlLCAobCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChvLCBhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSwgYS5kZXRhaWwpLCB1ID0gbC5wcmV2ZW50RGVmYXVsdCwgbC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB1LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFByZXZlbnRlZFwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBuLnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIHdpbmRvdy5DdXN0b21FdmVudCA9IG47XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICB9LCAzNzk6IChzLCBuLCByKSA9PiB7XG4gICAgdmFyIG8sIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtID0ge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocCkge1xuICAgICAgICBpZiAobVtwXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIF8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHApO1xuICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgXyBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF8gPSBfLmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIF8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIG1bcF0gPSBfO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtW3BdO1xuICAgICAgfTtcbiAgICB9KCksIGwgPSBbXTtcbiAgICBmdW5jdGlvbiB1KG0pIHtcbiAgICAgIGZvciAodmFyIHAgPSAtMSwgXyA9IDA7IF8gPCBsLmxlbmd0aDsgXysrKVxuICAgICAgICBpZiAobFtfXS5pZGVudGlmaWVyID09PSBtKSB7XG4gICAgICAgICAgcCA9IF87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKG0sIHApIHtcbiAgICAgIGZvciAodmFyIF8gPSB7fSwgYiA9IFtdLCB3ID0gMDsgdyA8IG0ubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgdmFyIEMgPSBtW3ddLCB5ID0gcC5iYXNlID8gQ1swXSArIHAuYmFzZSA6IENbMF0sIE4gPSBfW3ldIHx8IDAsIFMgPSBcIlwiLmNvbmNhdCh5LCBcIiBcIikuY29uY2F0KE4pO1xuICAgICAgICBfW3ldID0gTiArIDE7XG4gICAgICAgIHZhciB4ID0gdShTKSwgSSA9IHsgY3NzOiBDWzFdLCBtZWRpYTogQ1syXSwgc291cmNlTWFwOiBDWzNdIH07XG4gICAgICAgIHggIT09IC0xID8gKGxbeF0ucmVmZXJlbmNlcysrLCBsW3hdLnVwZGF0ZXIoSSkpIDogbC5wdXNoKHsgaWRlbnRpZmllcjogUywgdXBkYXRlcjogTChJLCBwKSwgcmVmZXJlbmNlczogMSB9KSwgYi5wdXNoKFMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYobSkge1xuICAgICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIF8gPSBtLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICBpZiAoXy5ub25jZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBiID0gci5uYztcbiAgICAgICAgYiAmJiAoXy5ub25jZSA9IGIpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKF8pLmZvckVhY2goZnVuY3Rpb24oQykge1xuICAgICAgICBwLnNldEF0dHJpYnV0ZShDLCBfW0NdKTtcbiAgICAgIH0pLCB0eXBlb2YgbS5pbnNlcnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBtLmluc2VydChwKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdyA9IGEobS5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXcpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgdy5hcHBlbmRDaGlsZChwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB2YXIgdiwgZyA9ICh2ID0gW10sIGZ1bmN0aW9uKG0sIHApIHtcbiAgICAgIHJldHVybiB2W21dID0gcCwgdi5maWx0ZXIoQm9vbGVhbikuam9pbihgXG5gKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBPKG0sIHAsIF8sIGIpIHtcbiAgICAgIHZhciB3ID0gXyA/IFwiXCIgOiBiLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KGIubWVkaWEsIFwiIHtcIikuY29uY2F0KGIuY3NzLCBcIn1cIikgOiBiLmNzcztcbiAgICAgIGlmIChtLnN0eWxlU2hlZXQpXG4gICAgICAgIG0uc3R5bGVTaGVldC5jc3NUZXh0ID0gZyhwLCB3KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgQyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHcpLCB5ID0gbS5jaGlsZE5vZGVzO1xuICAgICAgICB5W3BdICYmIG0ucmVtb3ZlQ2hpbGQoeVtwXSksIHkubGVuZ3RoID8gbS5pbnNlcnRCZWZvcmUoQywgeVtwXSkgOiBtLmFwcGVuZENoaWxkKEMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBUKG0sIHAsIF8pIHtcbiAgICAgIHZhciBiID0gXy5jc3MsIHcgPSBfLm1lZGlhLCBDID0gXy5zb3VyY2VNYXA7XG4gICAgICBpZiAodyA/IG0uc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgdykgOiBtLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpLCBDICYmIHR5cGVvZiBidG9hIDwgXCJ1XCIgJiYgKGIgKz0gYFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxgLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShDKSkpKSwgXCIgKi9cIikpLCBtLnN0eWxlU2hlZXQpXG4gICAgICAgIG0uc3R5bGVTaGVldC5jc3NUZXh0ID0gYjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDsgbS5maXJzdENoaWxkOyApXG4gICAgICAgICAgbS5yZW1vdmVDaGlsZChtLmZpcnN0Q2hpbGQpO1xuICAgICAgICBtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEEgPSBudWxsLCBEID0gMDtcbiAgICBmdW5jdGlvbiBMKG0sIHApIHtcbiAgICAgIHZhciBfLCBiLCB3O1xuICAgICAgaWYgKHAuc2luZ2xldG9uKSB7XG4gICAgICAgIHZhciBDID0gRCsrO1xuICAgICAgICBfID0gQSB8fCAoQSA9IGYocCkpLCBiID0gTy5iaW5kKG51bGwsIF8sIEMsICExKSwgdyA9IE8uYmluZChudWxsLCBfLCBDLCAhMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgXyA9IGYocCksIGIgPSBULmJpbmQobnVsbCwgXywgcCksIHcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oeSkge1xuICAgICAgICAgICAgaWYgKHkucGFyZW50Tm9kZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgeS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHkpO1xuICAgICAgICAgIH0pKF8pO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGIobSksIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICBpZiAoeS5jc3MgPT09IG0uY3NzICYmIHkubWVkaWEgPT09IG0ubWVkaWEgJiYgeS5zb3VyY2VNYXAgPT09IG0uc291cmNlTWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGIobSA9IHkpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB3KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBzLmV4cG9ydHMgPSBmdW5jdGlvbihtLCBwKSB7XG4gICAgICAocCA9IHAgfHwge30pLnNpbmdsZXRvbiB8fCB0eXBlb2YgcC5zaW5nbGV0b24gPT0gXCJib29sZWFuXCIgfHwgKHAuc2luZ2xldG9uID0gKG8gPT09IHZvaWQgMCAmJiAobyA9ICEhKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKSksIG8pKTtcbiAgICAgIHZhciBfID0gYyhtID0gbSB8fCBbXSwgcCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgICAgICBpZiAoYiA9IGIgfHwgW10sIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBfLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICB2YXIgQyA9IHUoX1t3XSk7XG4gICAgICAgICAgICBsW0NdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgeSA9IGMoYiwgcCksIE4gPSAwOyBOIDwgXy5sZW5ndGg7IE4rKykge1xuICAgICAgICAgICAgdmFyIFMgPSB1KF9bTl0pO1xuICAgICAgICAgICAgbFtTXS5yZWZlcmVuY2VzID09PSAwICYmIChsW1NdLnVwZGF0ZXIoKSwgbC5zcGxpY2UoUywgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfID0geTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9IH0sIHQgPSB7fTtcbiAgZnVuY3Rpb24gZShzKSB7XG4gICAgdmFyIG4gPSB0W3NdO1xuICAgIGlmIChuICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbi5leHBvcnRzO1xuICAgIHZhciByID0gdFtzXSA9IHsgaWQ6IHMsIGV4cG9ydHM6IHt9IH07XG4gICAgcmV0dXJuIGlbc10ociwgci5leHBvcnRzLCBlKSwgci5leHBvcnRzO1xuICB9XG4gIGUubiA9IChzKSA9PiB7XG4gICAgdmFyIG4gPSBzICYmIHMuX19lc01vZHVsZSA/ICgpID0+IHMuZGVmYXVsdCA6ICgpID0+IHM7XG4gICAgcmV0dXJuIGUuZChuLCB7IGE6IG4gfSksIG47XG4gIH0sIGUuZCA9IChzLCBuKSA9PiB7XG4gICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgZS5vKG4sIHIpICYmICFlLm8ocywgcikgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIHIsIHsgZW51bWVyYWJsZTogITAsIGdldDogbltyXSB9KTtcbiAgfSwgZS5vID0gKHMsIG4pID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBuKSwgKCgpID0+IHtcbiAgICB2YXIgcyA9IGUoMzc5KSwgbiA9IGUubihzKSwgciA9IGUoNDU0KTtcbiAgICBmdW5jdGlvbiBvKGwpIHtcbiAgICAgIGlmICghbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpKSB7XG4gICAgICAgIGwuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiLCBcIlwiKTtcbiAgICAgICAgdmFyIHUgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAsIGRldGFpbDogbnVsbCB9KTtcbiAgICAgICAgbC5kaXNwYXRjaEV2ZW50KHUpIHx8IChsLnZhbHVlID0gXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEobCkge1xuICAgICAgbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpICYmIChsLnJlbW92ZUF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiksIGwuZGlzcGF0Y2hFdmVudChuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITEsIGRldGFpbDogbnVsbCB9KSkpO1xuICAgIH1cbiAgICBuKCkoci5aLCB7IGluc2VydDogXCJoZWFkXCIsIHNpbmdsZXRvbjogITEgfSksIHIuWi5sb2NhbHMsIGUoODEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuYW5pbWF0aW9uTmFtZSA9PT0gXCJvbmF1dG9maWxsc3RhcnRcIiA/IG8obC50YXJnZXQpIDogYShsLnRhcmdldCk7XG4gICAgfSwgITApLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24obCkge1xuICAgICAgbC5pbnB1dFR5cGUgIT09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgJiYgXCJkYXRhXCIgaW4gbCA/IGEobC50YXJnZXQpIDogbyhsLnRhcmdldCk7XG4gICAgfSwgITApO1xuICB9KSgpO1xufSkoKTtcbmNvbnN0IFhlID0gXCJpbnB1dFwiLCBvZSA9IFwidHdlLmlucHV0XCIsIHhuID0gXCJkYXRhLXR3ZS1pbnB1dC13cmFwcGVyLWluaXRcIiwga24gPSBcImRhdGEtdHdlLWlucHV0LW5vdGNoLXJlZlwiLCBQbiA9IFwiZGF0YS10d2UtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgTW4gPSBcImRhdGEtdHdlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgRWwgPSBcImRhdGEtdHdlLWlucHV0LW5vdGNoLXRyYWlsaW5nLXJlZlwiLCB2bCA9IFwiZGF0YS10d2UtaW5wdXQtaGVscGVyLXJlZlwiLCBibCA9IFwiZGF0YS10d2UtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXCIsIHN0ID0gXCJkYXRhLXR3ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgd3MgPSBcImRhdGEtdHdlLWlucHV0LWZvY3VzZWRcIiwgVHMgPSBcImRhdGEtdHdlLWlucHV0LWZvcm0tY291bnRlclwiLCBhZSA9IGBbJHt4bn1dIGlucHV0YCwgbGUgPSBgWyR7eG59XSB0ZXh0YXJlYWAsIHl0ID0gYFske2tufV1gLCB5cyA9IGBbJHtQbn1dYCwgQXMgPSBgWyR7TW59XWAsIHdsID0gYFske3ZsfV1gLCBUbCA9IHtcbiAgaW5wdXRGb3JtV2hpdGU6ICExXG59LCB5bCA9IHtcbiAgaW5wdXRGb3JtV2hpdGU6IFwiKGJvb2xlYW4pXCJcbn0sIEFsID0ge1xuICBub3RjaDogXCJncm91cCBmbGV4IGFic29sdXRlIGxlZnQtMCB0b3AtMCB3LWZ1bGwgbWF4LXctZnVsbCBoLWZ1bGwgdGV4dC1sZWZ0IHBvaW50ZXItZXZlbnRzLW5vbmVcIixcbiAgbm90Y2hMZWFkaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBsZWZ0LTAgdG9wLTAgaC1mdWxsIHctMiBib3JkZXItZS0wIHJvdW5kZWQtcy1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1lLTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLWUtMFwiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwiYm9yZGVyLXNlY29uZGFyeS01MDAgZGFyazpib3JkZXItbmV1dHJhbC00MDAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1ub3RjaC0xIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1ub3RjaC0xIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctd2hpdGUgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaE1pZGRsZTogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3Jvdy0wIHNocmluay0wIGJhc2lzLWF1dG8gdy1hdXRvIG1heC13LVtjYWxjKDEwMCUtMXJlbSldIGgtZnVsbCBib3JkZXItZS0wIGJvcmRlci1zLTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0d2UtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10LXRyYW5zcGFyZW50IGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10LXRyYW5zcGFyZW50XCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcImJvcmRlci1zZWNvbmRhcnktNTAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNDAwIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctbm90Y2gtMiBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hNaWRkbGVXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1ub3RjaC0yIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctd2hpdGUgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaFRyYWlsaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93IGgtZnVsbCBib3JkZXItcy0wIHJvdW5kZWQtZS1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zLTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXMtMFwiLFxuICBub3RjaFRyYWlsaW5nTm9ybWFsOiBcImJvcmRlci1zZWNvbmRhcnktNTAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNDAwIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctbm90Y2gtMyBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hUcmFpbGluZ1doaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06c2hhZG93LW5vdGNoLTMgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy13aGl0ZSBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIGNvdW50ZXI6IFwidGV4dC1yaWdodCBsZWFkaW5nLVsxLjZdXCJcbn0sIENsID0ge1xuICBub3RjaDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ1doaXRlOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZTogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmc6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJzdHJpbmdcIixcbiAgY291bnRlcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzICQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBzKSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUsIHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMocyksIHRoaXMuX2xhYmVsID0gbnVsbCwgdGhpcy5fbGFiZWxXaWR0aCA9IDAsIHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsIHRoaXMuX25vdGNoTGVhZGluZyA9IG51bGwsIHRoaXMuX25vdGNoTWlkZGxlID0gbnVsbCwgdGhpcy5fbm90Y2hUcmFpbGluZyA9IG51bGwsIHRoaXMuX2luaXRpYXRlZCA9ICExLCB0aGlzLl9oZWxwZXIgPSBudWxsLCB0aGlzLl9jb3VudGVyID0gITEsIHRoaXMuX2NvdW50ZXJFbGVtZW50ID0gbnVsbCwgdGhpcy5fbWF4TGVuZ3RoID0gMCwgdGhpcy5fbGVhZGluZ0ljb24gPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmIChWLnNldERhdGEodCwgb2UsIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFhlO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCkgfHwgaC5maW5kT25lKFwidGV4dGFyZWFcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5faW5pdGlhdGVkIHx8ICh0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fYXBwbHlEaXZzKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKSwgdGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMuX2luaXRpYXRlZCA9ICEwKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2dldE5vdGNoRGF0YSgpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCk7XG4gIH1cbiAgZm9yY2VBY3RpdmUoKSB7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoc3QsIFwiXCIpLCBoLmZpbmRPbmUoeXQsIHRoaXMuaW5wdXQucGFyZW50Tm9kZSkuc2V0QXR0cmlidXRlKFxuICAgICAgc3QsXG4gICAgICBcIlwiXG4gICAgKTtcbiAgfVxuICBmb3JjZUluYWN0aXZlKCkge1xuICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKHN0KSwgaC5maW5kT25lKFxuICAgICAgeXQsXG4gICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICApLnJlbW92ZUF0dHJpYnV0ZShzdCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVCb3JkZXIoKSwgVi5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIG9lKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQsIGUpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlRsLFxuICAgICAgLi4uRS5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBSKFhlLCB0LCB5bCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5BbCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgUihYZSwgdCwgQ2wpLCB0O1xuICB9XG4gIF9nZXRMYWJlbERhdGEoKSB7XG4gICAgdGhpcy5fbGFiZWwgPSBoLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fbGFiZWwgPT09IG51bGwgPyB0aGlzLl9zaG93UGxhY2Vob2xkZXIoKSA6ICh0aGlzLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2dldExhYmVsUG9zaXRpb25JbklucHV0R3JvdXAoKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcigpKTtcbiAgfVxuICBfZ2V0SGVscGVyKCkge1xuICAgIHRoaXMuX2hlbHBlciA9IGguZmluZE9uZSh3bCwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2dldENvdW50ZXIoKSB7XG4gICAgdGhpcy5fY291bnRlciA9IEUuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImlucHV0U2hvd2NvdW50ZXJcIlxuICAgICksIHRoaXMuX2NvdW50ZXIgJiYgKHRoaXMuX21heExlbmd0aCA9IHRoaXMuaW5wdXQubWF4TGVuZ3RoLCB0aGlzLl9zaG93Q291bnRlcigpKTtcbiAgfVxuICBfZ2V0RXZlbnRzKCkge1xuICAgIGQub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgJC5hY3RpdmF0ZShuZXcgJCgpKVxuICAgICksIGQub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgJC5hY3RpdmF0ZShuZXcgJCgpKVxuICAgICksIGQub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJibHVyXCIsXG4gICAgICBcImlucHV0XCIsXG4gICAgICAkLmRlYWN0aXZhdGUobmV3ICQoKSlcbiAgICApLCBkLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgICQuYWN0aXZhdGUobmV3ICQoKSlcbiAgICApLCBkLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgICQuYWN0aXZhdGUobmV3ICQoKSlcbiAgICApLCBkLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgJC5kZWFjdGl2YXRlKG5ldyAkKCkpXG4gICAgKSwgZC5vbih3aW5kb3csIFwic2hvd24udHdlLm1vZGFsXCIsICh0KSA9PiB7XG4gICAgICBoLmZpbmQoYWUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHMgPSAkLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgcyAmJiBzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBoLmZpbmQobGUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHMgPSAkLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgcyAmJiBzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBkLm9uKHdpbmRvdywgXCJzaG93bi50d2UuZHJvcGRvd25cIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFwiW2RhdGEtdHdlLWRyb3Bkb3duLW1lbnUtcmVmXVwiXG4gICAgICApO1xuICAgICAgZSAmJiAoaC5maW5kKGFlLCBlKS5mb3JFYWNoKFxuICAgICAgICAocykgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSAkLmdldEluc3RhbmNlKHMucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbiAmJiBuLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBoLmZpbmQobGUsIGUpLmZvckVhY2goXG4gICAgICAgIChzKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9ICQuZ2V0SW5zdGFuY2Uocy5wYXJlbnROb2RlKTtcbiAgICAgICAgICBuICYmIG4udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIH0pLCBkLm9uKHdpbmRvdywgXCJzaG93bi50d2UudGFiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZTtcbiAgICAgIHQudGFyZ2V0LmhyZWYgPyBlID0gdC50YXJnZXQuaHJlZi5zcGxpdChcIiNcIilbMV0gOiBlID0gRS5nZXREYXRhQXR0cmlidXRlKHQudGFyZ2V0LCBcInRhcmdldFwiKS5zcGxpdChcbiAgICAgICAgXCIjXCJcbiAgICAgIClbMV07XG4gICAgICBjb25zdCBzID0gaC5maW5kT25lKGAjJHtlfWApO1xuICAgICAgaC5maW5kKGFlLCBzKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAkLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgIHIgJiYgci51cGRhdGUoKTtcbiAgICAgIH0pLCBoLmZpbmQobGUsIHMpLmZvckVhY2goXG4gICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9ICQuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcbiAgICAgICAgICByICYmIHIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGQub24od2luZG93LCBcInJlc2V0XCIsICh0KSA9PiB7XG4gICAgICBoLmZpbmQoYWUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHMgPSAkLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgcyAmJiBzLmZvcmNlSW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgaC5maW5kKGxlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBzID0gJC5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIHMgJiYgcy5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGQub24od2luZG93LCBcIm9uYXV0b2NvbXBsZXRlXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gJC5nZXRJbnN0YW5jZSh0LnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICFlIHx8ICF0LmNhbmNlbGFibGUgfHwgZS5mb3JjZUFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zaG93Q291bnRlcigpIHtcbiAgICBpZiAoaC5maW5kKFxuICAgICAgYFske1RzfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoID4gMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIEUuYWRkQ2xhc3ModGhpcy5fY291bnRlckVsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY291bnRlciksIHRoaXMuX2NvdW50ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShUcywgXCJcIik7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke2V9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YCwgdGhpcy5faGVscGVyLmFwcGVuZENoaWxkKHRoaXMuX2NvdW50ZXJFbGVtZW50KSwgdGhpcy5fYmluZENvdW50ZXIoKTtcbiAgfVxuICBfYmluZENvdW50ZXIoKSB7XG4gICAgZC5vbih0aGlzLmlucHV0LCBcImlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke3R9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YDtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcih0ID0gdGhpcy5pbnB1dCkge1xuICAgIGlmICghKHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJkYXRlXCIpKVxuICAgICAgcmV0dXJuO1xuICAgICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdCkgJiYgIXQudmFsdWUgPyB0LnN0eWxlLm9wYWNpdHkgPSAwIDogdC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgfVxuICBfc2hvd1BsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKGJsLCBcIlwiKTtcbiAgfVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gaC5maW5kT25lKFxuICAgICAgQXMsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gaC5maW5kT25lKFxuICAgICAgeXMsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfZ2V0TGFiZWxXaWR0aCgpIHtcbiAgICB0aGlzLl9sYWJlbFdpZHRoID0gdGhpcy5fbGFiZWwuY2xpZW50V2lkdGggKiAwLjggKyA4O1xuICB9XG4gIF9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCkge1xuICAgIGlmICh0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCAhdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1pbnB1dC1ncm91cC1yZWZcIikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQsIGUgPSBoLnByZXYoXG4gICAgICB0LFxuICAgICAgXCJbZGF0YS10d2UtaW5wdXQtZ3JvdXAtdGV4dC1yZWZdXCJcbiAgICApWzBdO1xuICAgIGUgPT09IHZvaWQgMCA/IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAgOiB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSBlLm9mZnNldFdpZHRoIC0gMTtcbiAgfVxuICBfYXBwbHlEaXZzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ1doaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmdOb3JtYWwsIGUgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlTm9ybWFsLCBzID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdOb3JtYWwsIG4gPSBoLmZpbmQoeXQsIHRoaXMuX2VsZW1lbnQpLCByID0gRnQoXCJkaXZcIik7XG4gICAgRS5hZGRDbGFzcyhyLCB0aGlzLl9jbGFzc2VzLm5vdGNoKSwgci5zZXRBdHRyaWJ1dGUoa24sIFwiXCIpLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBGdChcImRpdlwiKSwgRS5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTGVhZGluZyxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nfSAke3R9YFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZy5zZXRBdHRyaWJ1dGUoUG4sIFwiXCIpLCB0aGlzLl9ub3RjaE1pZGRsZSA9IEZ0KFwiZGl2XCIpLCBFLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hNaWRkbGUsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlfSAke2V9YFxuICAgICksIHRoaXMuX25vdGNoTWlkZGxlLnNldEF0dHJpYnV0ZShNbiwgXCJcIiksIHRoaXMuX25vdGNoVHJhaWxpbmcgPSBGdChcImRpdlwiKSwgRS5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoVHJhaWxpbmcsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmd9ICR7c31gXG4gICAgKSwgdGhpcy5fbm90Y2hUcmFpbGluZy5zZXRBdHRyaWJ1dGUoRWwsIFwiXCIpLCAhKG4ubGVuZ3RoID49IDEpICYmIChyLmFwcGVuZCh0aGlzLl9ub3RjaExlYWRpbmcpLCByLmFwcGVuZCh0aGlzLl9ub3RjaE1pZGRsZSksIHIuYXBwZW5kKHRoaXMuX25vdGNoVHJhaWxpbmcpLCB0aGlzLl9lbGVtZW50LmFwcGVuZChyKSwgci5kaXIgPSBcImx0clwiKTtcbiAgfVxuICBfYXBwbHlOb3RjaCgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZS5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsV2lkdGh9cHhgLCB0aGlzLl9ub3RjaExlYWRpbmcuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnQgKyA5fXB4YCwgdGhpcy5fbGFiZWwgIT09IG51bGwgJiYgKHRoaXMuX2xhYmVsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnR9cHhgKTtcbiAgfVxuICBfcmVtb3ZlQm9yZGVyKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoeXQsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgfVxuICBfYWN0aXZhdGUodCkge1xuICAgIFZzKCgpID0+IHtcbiAgICAgIHRoaXMuX2dldEVsZW1lbnRzKHQpO1xuICAgICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIHMgPSBoLmZpbmRPbmUoXG4gICAgICAgIHl0LFxuICAgICAgICB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgdCAmJiB0LnR5cGUgPT09IFwiZm9jdXNcIiAmJiBzICYmIHMuc2V0QXR0cmlidXRlKHdzLCBcIlwiKSwgZS52YWx1ZSAhPT0gXCJcIiAmJiAoZS5zZXRBdHRyaWJ1dGUoc3QsIFwiXCIpLCBzICYmIHMuc2V0QXR0cmlidXRlKHN0LCBcIlwiKSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XG4gICAgfSk7XG4gIH1cbiAgX2dldEVsZW1lbnRzKHQpIHtcbiAgICBpZiAodCAmJiAodGhpcy5fZWxlbWVudCA9IHQudGFyZ2V0LnBhcmVudE5vZGUsIHRoaXMuX2xhYmVsID0gaC5maW5kT25lKFwibGFiZWxcIiwgdGhpcy5fZWxlbWVudCkpLCB0ICYmIHRoaXMuX2xhYmVsKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fbGFiZWxXaWR0aDtcbiAgICAgIHRoaXMuX2dldExhYmVsRGF0YSgpLCBlICE9PSB0aGlzLl9sYWJlbFdpZHRoICYmICh0aGlzLl9ub3RjaE1pZGRsZSA9IGguZmluZE9uZShcbiAgICAgICAgQXMsXG4gICAgICAgIHQudGFyZ2V0LnBhcmVudE5vZGVcbiAgICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGguZmluZE9uZShcbiAgICAgICAgeXMsXG4gICAgICAgIHQudGFyZ2V0LnBhcmVudE5vZGVcbiAgICAgICksIHRoaXMuX2FwcGx5Tm90Y2goKSk7XG4gICAgfVxuICB9XG4gIF9kZWFjdGl2YXRlKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IHQudGFyZ2V0IDogdGhpcy5pbnB1dDtcbiAgICBpZiAoZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpID09PSBcInRydWVcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gaC5maW5kT25lKFxuICAgICAgeXQsXG4gICAgICBlLnBhcmVudE5vZGVcbiAgICApO1xuICAgIHMucmVtb3ZlQXR0cmlidXRlKHdzKSwgZS52YWx1ZSA9PT0gXCJcIiAmJiAoZS5yZW1vdmVBdHRyaWJ1dGUoc3QpLCBzLnJlbW92ZUF0dHJpYnV0ZShzdCkpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICB9XG4gIHN0YXRpYyBhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2FjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlYWN0aXZhdGUodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9kZWFjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBzID0gVi5nZXREYXRhKHRoaXMsIG9lKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghcyAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKHMgfHwgKHMgPSBuZXcgJCh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc1t0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBzW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIFYuZ2V0RGF0YSh0LCBvZSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgT2wgPSB7XG4gIHByb3BlcnR5OiBcImNvbG9yXCIsXG4gIGRlZmF1bHRWYWx1ZTogbnVsbCxcbiAgaW5oZXJpdDogITBcbn0sIEF0ID0gKGksIHQpID0+IHtcbiAgY29uc3QgeyBwcm9wZXJ0eTogZSwgZGVmYXVsdFZhbHVlOiBzLCBpbmhlcml0OiBuIH0gPSB7IC4uLk9sLCAuLi50IH0sIHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByLmNsYXNzTGlzdC5hZGQoaSksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocik7XG4gIGNvbnN0IGEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyKVtlXSB8fCBzLCB1ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoci5wYXJlbnRFbGVtZW50KVtlXTtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQociksICFuICYmIHUgJiYgYSA9PT0gdSA/IHMgOiBhIHx8IHM7XG59LCBHZSA9IFwicmlwcGxlXCIsIGNlID0gXCJ0d2UucmlwcGxlXCIsIERsID0gXCJyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlXCIsIE5sID0gW1wiW2RhdGEtdHdlLXJpcHBsZS1pbml0XVwiXSwgZGUgPSBbMCwgMCwgMF0sIFNsID0gW1xuICB7XG4gICAgbmFtZTogXCJwcmltYXJ5XCIsXG4gICAgZ3JhZGllbnRDb2xvcjogQXQoXCJ0ZXh0LXByaW1hcnlcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzNCNzFDQVwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJzZWNvbmRhcnlcIixcbiAgICBncmFkaWVudENvbG9yOiBBdChcInRleHQtcHJpbWFyeS0xMDBcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzlGQTZCMlwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgZ3JhZGllbnRDb2xvcjogQXQoXCJ0ZXh0LXN1Y2Nlc3NcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzE0QTQ0RFwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkYW5nZXJcIixcbiAgICBncmFkaWVudENvbG9yOiBBdChcInRleHQtZGFuZ2VyXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNEQzRDNjRcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwid2FybmluZ1wiLFxuICAgIGdyYWRpZW50Q29sb3I6IEF0KFwidGV4dC13YXJuaW5nXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNFNEExMUJcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiaW5mb1wiLFxuICAgIGdyYWRpZW50Q29sb3I6IEF0KFwidGV4dC1pbmZvXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiM1NEI0RDNcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwibGlnaHRcIixcbiAgICBncmFkaWVudENvbG9yOiBcIiNmYmZiZmJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkYXJrXCIsXG4gICAgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCJcbiAgfVxuXSwgQ3MgPSAwLjUsIExsID0ge1xuICByaXBwbGVDZW50ZXJlZDogITEsXG4gIHJpcHBsZUNvbG9yOiBcIlwiLFxuICByaXBwbGVDb2xvckRhcms6IFwiXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXG4gIHJpcHBsZVJhZGl1czogMCxcbiAgcmlwcGxlVW5ib3VuZDogITFcbn0sICRsID0ge1xuICByaXBwbGVDZW50ZXJlZDogXCJib29sZWFuXCIsXG4gIHJpcHBsZUNvbG9yOiBcInN0cmluZ1wiLFxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcInN0cmluZ1wiLFxuICByaXBwbGVSYWRpdXM6IFwibnVtYmVyXCIsXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXG59LCBJbCA9IHtcbiAgcmlwcGxlOiBcInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tXCIsXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcbiAgdW5ib3VuZDogXCJvdmVyZmxvdy12aXNpYmxlXCJcbn0sIFJsID0ge1xuICByaXBwbGU6IFwic3RyaW5nXCIsXG4gIHJpcHBsZVdhdmU6IFwic3RyaW5nXCIsXG4gIHVuYm91bmQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBIbiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMocyksIHRoaXMuX2N1cnJlbnRDb2xvciA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IsIHRoaXMuX2VsZW1lbnQgJiYgKFYuc2V0RGF0YSh0LCBjZSwgdGhpcyksIEUuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBHZTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hZGRDbGlja0V2ZW50KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgVi5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGNlKSwgZC5vZmYodGhpcy5fZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgdGhpcy5fY2xpY2tIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2F1dG9Jbml0KHQpIHtcbiAgICBObC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBoLmNsb3Nlc3QodC50YXJnZXQsIGUpICYmICh0aGlzLl9lbGVtZW50ID0gaC5jbG9zZXN0KHQudGFyZ2V0LCBlKSk7XG4gICAgfSksIHRoaXMuX2VsZW1lbnQuc3R5bGUubWluV2lkdGggfHwgKEUuc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgXCJtaW4td2lkdGhcIjogZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS53aWR0aFxuICAgIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITApLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKCksIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gWy4uLnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0XSwgRS5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnJpcHBsZSksIHRoaXMuX2NyZWF0ZVJpcHBsZSh0KTtcbiAgfVxuICBfYWRkQ2xpY2tFdmVudCh0KSB7XG4gICAgZC5vbih0LCBcIm1vdXNlZG93blwiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIF9jcmVhdGVSaXBwbGUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodGhpcy5fY2xhc3Nlcy5yaXBwbGUpIDwgMCAmJiBFLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKTtcbiAgICBjb25zdCB7IGxheWVyWDogZSwgbGF5ZXJZOiBzIH0gPSB0LCBuID0gdC5vZmZzZXRYIHx8IGUsIHIgPSB0Lm9mZnNldFkgfHwgcywgbyA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0SGVpZ2h0LCBhID0gdGhpcy5fZWxlbWVudC5vZmZzZXRXaWR0aCwgbCA9IHRoaXMuX2R1cmF0aW9uVG9Nc051bWJlcih0aGlzLl9vcHRpb25zLnJpcHBsZUR1cmF0aW9uKSwgdSA9IHtcbiAgICAgIG9mZnNldFg6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBvIC8gMiA6IG4sXG4gICAgICBvZmZzZXRZOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYSAvIDIgOiByLFxuICAgICAgaGVpZ2h0OiBvLFxuICAgICAgd2lkdGg6IGFcbiAgICB9LCBjID0gdGhpcy5fZ2V0RGlhbWV0ZXIodSksIGYgPSB0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyB8fCBjIC8gMiwgdiA9IHtcbiAgICAgIGRlbGF5OiBsICogQ3MsXG4gICAgICBkdXJhdGlvbjogbCAtIGwgKiBDc1xuICAgIH0sIGcgPSB7XG4gICAgICBsZWZ0OiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7YSAvIDIgLSBmfXB4YCA6IGAke24gLSBmfXB4YCxcbiAgICAgIHRvcDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke28gLyAyIC0gZn1weGAgOiBgJHtyIC0gZn1weGAsXG4gICAgICBoZWlnaHQ6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCBjfXB4YCxcbiAgICAgIHdpZHRoOiBgJHt0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyAqIDIgfHwgY31weGAsXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAwcywgJHt2LmRlbGF5fW1zYCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7bH1tcywgJHt2LmR1cmF0aW9ufW1zYFxuICAgIH0sIE8gPSBGdChcImRpdlwiKTtcbiAgICB0aGlzLl9jcmVhdGVIVE1MUmlwcGxlKHtcbiAgICAgIHdyYXBwZXI6IHRoaXMuX2VsZW1lbnQsXG4gICAgICByaXBwbGU6IE8sXG4gICAgICBzdHlsZXM6IGdcbiAgICB9KSwgdGhpcy5fcmVtb3ZlSFRNTFJpcHBsZSh7IHJpcHBsZTogTywgZHVyYXRpb246IGwgfSk7XG4gIH1cbiAgX2NyZWF0ZUhUTUxSaXBwbGUoeyB3cmFwcGVyOiB0LCByaXBwbGU6IGUsIHN0eWxlczogcyB9KSB7XG4gICAgT2JqZWN0LmtleXMocykuZm9yRWFjaChcbiAgICAgIChuKSA9PiBlLnN0eWxlW25dID0gc1tuXVxuICAgICksIEUuYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5yaXBwbGVXYXZlKSwgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1yaXBwbGUtcmVmXCIsIFwiXCIpLCB0aGlzLl9hZGRDb2xvcihlLCB0KSwgdGhpcy5fdG9nZ2xlVW5ib3VuZCh0KSwgdGhpcy5fYXBwZW5kUmlwcGxlKGUsIHQpO1xuICB9XG4gIF9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiB0LCBkdXJhdGlvbjogZSB9KSB7XG4gICAgdGhpcy5fcmlwcGxlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yaXBwbGVUaW1lciksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCksIHQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0wXCIpO1xuICAgIH0sIDEwKSwgdGhpcy5fcmlwcGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBoLmZpbmQoXCJbZGF0YS10d2UtcmlwcGxlLXJlZl1cIiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgICAgICAobikgPT4ge1xuICAgICAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICksIHRoaXMuX2lzTWluV2lkdGhTZXQgJiYgKEUuc3R5bGUodGhpcy5fZWxlbWVudCwgeyBcIm1pbi13aWR0aFwiOiBcIlwiIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITEpO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5faW5pdGlhbENsYXNzZXMgPyB0aGlzLl9hZGRlZE5ld1JpcHBsZUNsYXNzZXMoXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5yaXBwbGUsXG4gICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXNcbiAgICAgICAgKSA6IHRoaXMuX2NsYXNzZXMucmlwcGxlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgRS5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBzKTtcbiAgICAgIH1cbiAgICB9LCBlKTtcbiAgfVxuICBfYWRkZWROZXdSaXBwbGVDbGFzc2VzKHQsIGUpIHtcbiAgICByZXR1cm4gdC5zcGxpdChcIiBcIikuZmlsdGVyKFxuICAgICAgKHMpID0+IGUuZmluZEluZGV4KChuKSA9PiBzID09PSBuKSA9PT0gLTFcbiAgICApO1xuICB9XG4gIF9kdXJhdGlvblRvTXNOdW1iZXIodCkge1xuICAgIHJldHVybiBOdW1iZXIodC5yZXBsYWNlKFwibXNcIiwgXCJcIikucmVwbGFjZShcInNcIiwgXCIwMDBcIikpO1xuICB9XG4gIF9nZXRDb25maWcodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IEUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5MbCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgUihHZSwgdCwgJGwpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5JbCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgUihHZSwgdCwgUmwpLCB0O1xuICB9XG4gIF9nZXREaWFtZXRlcih7IG9mZnNldFg6IHQsIG9mZnNldFk6IGUsIGhlaWdodDogcywgd2lkdGg6IG4gfSkge1xuICAgIGNvbnN0IHIgPSBlIDw9IHMgLyAyLCBvID0gdCA8PSBuIC8gMiwgYSA9ICh2LCBnKSA9PiBNYXRoLnNxcnQodiAqKiAyICsgZyAqKiAyKSwgbCA9IGUgPT09IHMgLyAyICYmIHQgPT09IG4gLyAyLCB1ID0ge1xuICAgICAgZmlyc3Q6IHIgPT09ICEwICYmIG8gPT09ICExLFxuICAgICAgc2Vjb25kOiByID09PSAhMCAmJiBvID09PSAhMCxcbiAgICAgIHRoaXJkOiByID09PSAhMSAmJiBvID09PSAhMCxcbiAgICAgIGZvdXJ0aDogciA9PT0gITEgJiYgbyA9PT0gITFcbiAgICB9LCBjID0ge1xuICAgICAgdG9wTGVmdDogYSh0LCBlKSxcbiAgICAgIHRvcFJpZ2h0OiBhKG4gLSB0LCBlKSxcbiAgICAgIGJvdHRvbUxlZnQ6IGEodCwgcyAtIGUpLFxuICAgICAgYm90dG9tUmlnaHQ6IGEobiAtIHQsIHMgLSBlKVxuICAgIH07XG4gICAgbGV0IGYgPSAwO1xuICAgIHJldHVybiBsIHx8IHUuZm91cnRoID8gZiA9IGMudG9wTGVmdCA6IHUudGhpcmQgPyBmID0gYy50b3BSaWdodCA6IHUuc2Vjb25kID8gZiA9IGMuYm90dG9tUmlnaHQgOiB1LmZpcnN0ICYmIChmID0gYy5ib3R0b21MZWZ0KSwgZiAqIDI7XG4gIH1cbiAgX2FwcGVuZFJpcHBsZSh0LCBlKSB7XG4gICAgZS5hcHBlbmRDaGlsZCh0KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBFLmFkZENsYXNzKHQsIFwib3BhY2l0eS0wIHNjYWxlLTEwMFwiKTtcbiAgICB9LCA1MCk7XG4gIH1cbiAgX3RvZ2dsZVVuYm91bmQodCkge1xuICAgIHRoaXMuX29wdGlvbnMucmlwcGxlVW5ib3VuZCA9PT0gITAgPyBFLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMudW5ib3VuZCkgOiBFLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMudW5ib3VuZCk7XG4gIH1cbiAgX2FkZENvbG9yKHQpIHtcbiAgICBsZXQgZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IgfHwgXCJyZ2IoMCwwLDApXCI7XG4gICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGUgPSB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yRGFyayB8fCB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yKTtcbiAgICBjb25zdCBzID0gU2wuZmluZChcbiAgICAgIChvKSA9PiBvLm5hbWUgPT09IGUudG9Mb3dlckNhc2UoKVxuICAgICksIG4gPSBzID8gdGhpcy5fY29sb3JUb1JHQihzLmdyYWRpZW50Q29sb3IpLmpvaW4oXCIsXCIpIDogdGhpcy5fY29sb3JUb1JHQihlKS5qb2luKFwiLFwiKSwgciA9IERsLnNwbGl0KFwie3tjb2xvcn19XCIpLmpvaW4oYCR7bn1gKTtcbiAgICB0LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCAke3J9KWA7XG4gIH1cbiAgX2NvbG9yVG9SR0IodCkge1xuICAgIGZ1bmN0aW9uIGUocikge1xuICAgICAgcmV0dXJuIHIubGVuZ3RoIDwgNyAmJiAociA9IGAjJHtyWzFdfSR7clsxXX0ke3JbMl19JHtyWzJdfSR7clszXX0ke3JbM119YCksIFtcbiAgICAgICAgcGFyc2VJbnQoci5zdWJzdHIoMSwgMiksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoci5zdWJzdHIoMywgMiksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoci5zdWJzdHIoNSwgMiksIDE2KVxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcyhyKSB7XG4gICAgICBjb25zdCBvID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpY3R1bVwiKVxuICAgICAgKSwgYSA9IFwicmdiKDEsIDIsIDMpXCI7XG4gICAgICByZXR1cm4gby5zdHlsZS5jb2xvciA9IGEsIG8uc3R5bGUuY29sb3IgIT09IGEgfHwgKG8uc3R5bGUuY29sb3IgPSByLCBvLnN0eWxlLmNvbG9yID09PSBhIHx8IG8uc3R5bGUuY29sb3IgPT09IFwiXCIpID8gZGUgOiAociA9IGdldENvbXB1dGVkU3R5bGUobykuY29sb3IsIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobyksIHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKHIpIHtcbiAgICAgIHJldHVybiByID0gci5tYXRjaCgvWy5cXGRdKy9nKS5tYXAoKG8pID0+ICtOdW1iZXIobykpLCByLmxlbmd0aCA9IDMsIHI7XG4gICAgfVxuICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCkgPT09IFwidHJhbnNwYXJlbnRcIiA/IGRlIDogdFswXSA9PT0gXCIjXCIgPyBlKHQpIDogKHQuaW5kZXhPZihcInJnYlwiKSA9PT0gLTEgJiYgKHQgPSBzKHQpKSwgdC5pbmRleE9mKFwicmdiXCIpID09PSAwID8gbih0KSA6IGRlKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0aWFsKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYXV0b0luaXQoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFYuZ2V0RGF0YSh0aGlzLCBjZSkgPyBudWxsIDogbmV3IEhuKHRoaXMsIHQpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIFYuZ2V0RGF0YSh0LCBjZSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgUWUgPSBcIm1vZGFsXCIsIHhsID0gXCJ0d2UubW9kYWxcIiwgSyA9IGAuJHt4bH1gLCBPcyA9IFwiRXNjYXBlXCIsIERzID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgZm9jdXM6ICEwXG59LCBOcyA9IHtcbiAgYmFja2Ryb3A6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIGZvY3VzOiBcImJvb2xlYW5cIlxufSwga2wgPSB7XG4gIHNob3c6IFwidHJhbnNmb3JtLW5vbmVcIixcbiAgc3RhdGljOiBcInNjYWxlLVsxLjAyXVwiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInRyYW5zaXRpb24tc2NhbGUgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCIsXG4gIGJhY2tkcm9wOiBcIm9wYWNpdHktNTAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IGZpeGVkIHRvcC0wIGxlZnQtMCB6LVsxMDQwXSBiZy1ibGFjayB3LXNjcmVlbiBoLXNjcmVlblwiXG59LCBQbCA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgc3RhdGljOiBcInN0cmluZ1wiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInN0cmluZ1wiLFxuICBiYWNrZHJvcDogXCJzdHJpbmdcIlxufSwgTWwgPSBgaGlkZSR7S31gLCBIbCA9IGBoaWRlUHJldmVudGVkJHtLfWAsIFZsID0gYGhpZGRlbiR7S31gLCBXbCA9IGBzaG93JHtLfWAsIEJsID0gYHNob3duJHtLfWAsIFNzID0gYHJlc2l6ZSR7S31gLCBMcyA9IGBjbGljay5kaXNtaXNzJHtLfWAsICRzID0gYGtleWRvd24uZGlzbWlzcyR7S31gLCBqbCA9IGBtb3VzZXVwLmRpc21pc3Mke0t9YCwgSXMgPSBgbW91c2Vkb3duLmRpc21pc3Mke0t9YCwgUnMgPSBcImRhdGEtdHdlLW1vZGFsLW9wZW5cIiwgeHMgPSBcImRhdGEtdHdlLW9wZW5cIiwgVXQgPSBcIltkYXRhLXR3ZS1tb2RhbC1kaWFsb2ctcmVmXVwiLCBVbCA9IFwiW2RhdGEtdHdlLW1vZGFsLWJvZHktcmVmXVwiO1xuY2xhc3MgYWkgZXh0ZW5kcyB0dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhzKSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgcmkoKSwgdGhpcy5fZGlhbG9nID0gaC5maW5kT25lKFV0LCB0aGlzLl9lbGVtZW50KSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITEsIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUWU7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEcztcbiAgfVxuICBzdGF0aWMgZ2V0IGdldERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBOcztcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXbCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5faXNBbmltYXRlZCgpICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCksIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKFJzLCBcInRydWVcIiksIHRoaXMuX2FkanVzdERpYWxvZygpLCB0aGlzLl9zZXRFc2NhcGVFdmVudCgpLCB0aGlzLl9zZXRSZXNpemVFdmVudCgpLCBkLm9uKHRoaXMuX2RpYWxvZywgSXMsICgpID0+IHtcbiAgICAgIGQub25lKHRoaXMuX2VsZW1lbnQsIGpsLCAocykgPT4ge1xuICAgICAgICBzLnRhcmdldCA9PT0gdGhpcy5fZWxlbWVudCAmJiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICEwKTtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLl9zaG93RWxlbWVudCh0KSwgdGhpcy5fc2hvd0JhY2tkcm9wKCkpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTWwpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTaG93biA9ICExO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XG4gICAgZSAmJiAodGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITApLCB0aGlzLl9zZXRFc2NhcGVFdmVudCgpLCB0aGlzLl9zZXRSZXNpemVFdmVudCgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBoLmZpbmRPbmUoVXQsIHRoaXMuX2VsZW1lbnQpLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zaG93KSwgZC5vZmYodGhpcy5fZWxlbWVudCwgTHMpLCBkLm9mZih0aGlzLl9kaWFsb2csIElzKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHhzKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIFt3aW5kb3csIGRvY3VtZW50LCB0aGlzLl9kaWFsb2ddLmZvckVhY2goXG4gICAgICAodCkgPT4gZC5vZmYodCwgSylcbiAgICApLCB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChDbihhaSksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IHluKHtcbiAgICAgIGlzVmlzaWJsZTogISF0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKSxcbiAgICAgIGJhY2tkcm9wQ2xhc3NlczogdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcFxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgQW4odGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCksIHMgPSBoLmZpbmRPbmUoVWwsIHRoaXMuX2RpYWxvZyk7XG4gICAgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiYgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke3hzfWAsIFwidHJ1ZVwiKSwgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUoVXQsIHRoaXMuX2VsZW1lbnQpO1xuICAgIG4uY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnNob3cpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIiksIG4uY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMTAwXCIpLCBzICYmIChzLnNjcm9sbFRvcCA9IDApLCBlICYmIFh0KHRoaXMuX2VsZW1lbnQpO1xuICAgIGNvbnN0IHIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuZm9jdXMgJiYgdGhpcy5fZm9jdXN0cmFwLnRyYXAoKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBCbCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sociwgdGhpcy5fZGlhbG9nLCBlKTtcbiAgfVxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgdGhpcy5faXNTaG93biA/IGQub24oZG9jdW1lbnQsICRzLCAodCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBPcyA/ICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuaGlkZSgpKSA6ICF0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IE9zICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICB9KSA6IGQub2ZmKHRoaXMuX2VsZW1lbnQsICRzKTtcbiAgfVxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgdGhpcy5faXNTaG93biA/IGQub24od2luZG93LCBTcywgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpIDogZC5vZmYod2luZG93LCBTcyk7XG4gIH1cbiAgX2hpZGVNb2RhbCgpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKFV0LCB0aGlzLl9lbGVtZW50KTtcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zaG93KSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKTtcbiAgICBjb25zdCBlID0gSmUodCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LCBlKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShScyksIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWbCk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgZC5vbih0aGlzLl9lbGVtZW50LCBMcywgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAhMCA/IHRoaXMuaGlkZSgpIDogdGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSBcInN0YXRpY1wiICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSk7XG4gICAgfSksIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuICEhaC5maW5kT25lKFV0LCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBpZiAoZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEhsKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0OiBlLCBzY3JvbGxIZWlnaHQ6IHMsIHN0eWxlOiBuIH0gPSB0aGlzLl9lbGVtZW50LCByID0gcyA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCFyICYmIG4ub3ZlcmZsb3dZID09PSBcImhpZGRlblwiIHx8IGUuY29udGFpbnModGhpcy5fY2xhc3Nlcy5zdGF0aWMpKVxuICAgICAgcmV0dXJuO1xuICAgIHIgfHwgKG4ub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljLnNwbGl0KFwiIFwiKSksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgIGNvbnN0IG8gPSBKZSh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGUucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc3RhdGljKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgbyksIHIgfHwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG4ub3ZlcmZsb3dZID0gXCJcIjtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgfSwgdGhpcy5fZGlhbG9nKSwgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uRHMsXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIFIoUWUsIHQsIE5zKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IEUuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmtsLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBSKFFlLCB0LCBQbCksIHQ7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIF9hZGp1c3REaWFsb2coKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgZSA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpLCBzID0gZSA+IDA7XG4gICAgKCFzICYmIHQgJiYgIU0oKSB8fCBzICYmICF0ICYmIE0oKSkgJiYgKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtlfXB4YCksIChzICYmICF0ICYmICFNKCkgfHwgIXMgJiYgdCAmJiBNKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke2V9cHhgKTtcbiAgfVxuICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCJcIiwgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgcyA9IGFpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIHNbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgc1t0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgRmwgPSAoaSwgdCkgPT4ge1xuICBkLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50d2UuJHtpLk5BTUV9YCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKSwgaS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xuICAgIH1cbiAgKTtcbn0sIFlsID0gKGksIHQpID0+IHtcbiAgZC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudHdlLiR7aS5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGd0KHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xuICAgIH1cbiAgKTtcbn0sIEtsID0gKGksIHQpID0+IHtcbiAgZC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudHdlLiR7aS5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBzID0gbnQodGhpcyk7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGd0KHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBkLm9uZShzLCBpLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgICBrdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUoaS5PUEVOX1NFTEVDVE9SKTtcbiAgICAgIG4gJiYgbiAhPT0gcyAmJiBpLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgaS5nZXRPckNyZWF0ZUluc3RhbmNlKHMpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCB6bCA9IChpLCB0KSA9PiB7XG4gIGQub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnR3ZS4ke2kuTkFNRX1gLFxuICAgIHQsXG4gICAgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHMgPSBlLnRhcmdldC5jbG9zZXN0KHQpO1xuICAgICAgaS5nZXRPckNyZWF0ZUluc3RhbmNlKHMpLnRvZ2dsZSgpO1xuICAgIH1cbiAgKTtcbn0sIHFsID0gKGksIHQpID0+IHtcbiAgZC5vbmUoXG4gICAgZG9jdW1lbnQsXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICB0LFxuICAgIGkuYXV0b0luaXRpYWwobmV3IGkoKSlcbiAgKTtcbn0sIFhsID0gKGksIHQpID0+IHtcbiAgZC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudHdlLiR7aS5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIgfHwgZS5kZWxlZ2F0ZVRhcmdldCAmJiBlLmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBzID0gY2kodGhpcyk7XG4gICAgICBoLmZpbmQocykuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpLmdldE9yQ3JlYXRlSW5zdGFuY2UociwgeyB0b2dnbGU6ICExIH0pLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufSwgR2wgPSAoaSwgdCkgPT4ge1xuICBbXS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodClcbiAgKS5tYXAoZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBuZXcgaShzKTtcbiAgfSk7XG59LCBRbCA9IChpLCB0KSA9PiB7XG4gIFtdLnNsaWNlLmNhbGwoXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KVxuICApLm1hcChmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIG5ldyBpKHMpO1xuICB9KTtcbn0sIFpsID0gKGksIHQpID0+IHtcbiAgZC5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudHdlLiR7aS5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBzID0gbnQodGhpcyk7XG4gICAgICBbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgZC5vbmUocywgaS5FVkVOVF9TSE9XLCAobykgPT4ge1xuICAgICAgICBvLmRlZmF1bHRQcmV2ZW50ZWQgfHwgZC5vbmUocywgaS5FVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgICAgICBrdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gaC5maW5kT25lKFxuICAgICAgICBgWyR7aS5PUEVOX1NFTEVDVE9SfT1cInRydWVcIl1gXG4gICAgICApO1xuICAgICAgbiAmJiBpLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgaS5nZXRPckNyZWF0ZUluc3RhbmNlKHMpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBKbCA9IHtcbiAgY2Fyb3VzZWw6IHtcbiAgICBuYW1lOiBcIkNhcm91c2VsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLWNhcm91c2VsLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBpbnB1dDoge1xuICAgIG5hbWU6IFwiSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2UtaW5wdXQtd3JhcHBlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2Nyb2xsc3B5OiB7XG4gICAgbmFtZTogXCJTY3JvbGxTcHlcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2Utc3B5PSdzY3JvbGwnXVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgLy8gdG9nZ2xlcnNcbiAgYnV0dG9uOiB7XG4gICAgbmFtZTogXCJCdXR0b25cIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2UtdG9nZ2xlPSdidXR0b24nXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IHpsXG4gIH0sXG4gIGNvbGxhcHNlOiB7XG4gICAgbmFtZTogXCJDb2xsYXBzZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS1jb2xsYXBzZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFhsXG4gIH0sXG4gIGRyb3Bkb3duOiB7XG4gICAgbmFtZTogXCJEcm9wZG93blwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IEZsXG4gIH0sXG4gIHJpcHBsZToge1xuICAgIG5hbWU6IFwiUmlwcGxlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLXJpcHBsZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IHFsXG4gIH0sXG4gIG9mZmNhbnZhczoge1xuICAgIG5hbWU6IFwiT2ZmY2FudmFzXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLW9mZmNhbnZhcy10b2dnbGVdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogS2xcbiAgfSxcbiAgdGFiOiB7XG4gICAgbmFtZTogXCJUYWJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2UtdG9nZ2xlPSd0YWInXSwgW2RhdGEtdHdlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10d2UtdG9nZ2xlPSdsaXN0J11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBZbFxuICB9LFxuICB0b29sdGlwOiB7XG4gICAgbmFtZTogXCJUb29sdGlwXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLXRvZ2dsZT0ndG9vbHRpcCddXCIsXG4gICAgaXNUb2dnbGVyOiAhMSxcbiAgICBjYWxsYmFjazogR2xcbiAgfSxcbiAgcG9wb3Zlcjoge1xuICAgIG5hbWU6IFwiUG9wb3ZlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS10b2dnbGU9J3BvcG92ZXInXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFFsXG4gIH0sXG4gIG1vZGFsOiB7XG4gICAgbmFtZTogXCJNb2RhbFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS10b2dnbGU9J21vZGFsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBabFxuICB9XG59LCB0YyA9IChpKSA9PiB7XG4gIFZzKCgpID0+IHtcbiAgICBjb25zdCB0ID0gSHMoKTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IGkuTkFNRSwgcyA9IHQuZm5bZV07XG4gICAgICB0LmZuW2VdID0gaS5qUXVlcnlJbnRlcmZhY2UsIHQuZm5bZV0uQ29uc3RydWN0b3IgPSBpLCB0LmZuW2VdLm5vQ29uZmxpY3QgPSAoKSA9PiAodC5mbltlXSA9IHMsIGkualF1ZXJ5SW50ZXJmYWNlKTtcbiAgICB9XG4gIH0pO1xufTtcbmNsYXNzIGVjIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0cyA9IFtdO1xuICB9XG4gIGdldCBpbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0cztcbiAgfVxuICBpc0luaXRlZCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdHMuaW5jbHVkZXModCk7XG4gIH1cbiAgYWRkKHQpIHtcbiAgICB0aGlzLmlzSW5pdGVkKHQpIHx8IHRoaXMuaW5pdHMucHVzaCh0KTtcbiAgfVxufVxuY29uc3QgbGkgPSBuZXcgZWMoKTtcbmxldCBEdDtcbmNvbnN0IGljID0gKGkpID0+IER0W2kuTkFNRV0gfHwgbnVsbCwgc2MgPSAoaSwgdCkgPT4ge1xuICBpZiAoIWkgfHwgIXQuYWxsb3dSZWluaXRzICYmIGxpLmlzSW5pdGVkKGkuTkFNRSkpXG4gICAgcmV0dXJuO1xuICBsaS5hZGQoaS5OQU1FKTtcbiAgY29uc3QgZSA9IGljKGkpLCBzID0gKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaXNUb2dnbGVyKSB8fCAhMTtcbiAgaWYgKHRjKGkpLCBlICE9IG51bGwgJiYgZS5hZHZhbmNlZCkge1xuICAgIGUgPT0gbnVsbCB8fCBlLmFkdmFuY2VkKGksIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocykge1xuICAgIGUgPT0gbnVsbCB8fCBlLmNhbGxiYWNrKGksIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBoLmZpbmQoZSA9PSBudWxsID8gdm9pZCAwIDogZS5zZWxlY3RvcikuZm9yRWFjaCgobikgPT4ge1xuICAgIGxldCByID0gaS5nZXRJbnN0YW5jZShuKTtcbiAgICByIHx8IChyID0gbmV3IGkobiksIGUgIT0gbnVsbCAmJiBlLm9uSW5pdCAmJiByW2Uub25Jbml0XSgpKTtcbiAgfSk7XG59LCBuYyA9IHtcbiAgYWxsb3dSZWluaXRzOiAhMSxcbiAgY2hlY2tPdGhlckltcG9ydHM6ICExXG59O1xuY2xhc3MgcmMge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgTmUodGhpcywgXCJpbml0XCIsICh0LCBlKSA9PiB7XG4gICAgICB0LmZvckVhY2goKHMpID0+IHNjKHMsIGUpKTtcbiAgICB9KTtcbiAgICBOZSh0aGlzLCBcImluaXRUV0VcIiwgKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB7IC4uLm5jLCAuLi5lIH0sIG4gPSBPYmplY3Qua2V5cyhEdCkubWFwKChyKSA9PiB7XG4gICAgICAgIGlmICghIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRHRbcl0uc2VsZWN0b3IpKSB7XG4gICAgICAgICAgY29uc3QgYSA9IHRbRHRbcl0ubmFtZV07XG4gICAgICAgICAgcmV0dXJuICFhICYmICFsaS5pc0luaXRlZChyKSAmJiBzLmNoZWNrT3RoZXJJbXBvcnRzICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7RHRbcl0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VFdFXCIgZnVuY3Rpb25gXG4gICAgICAgICAgKSwgYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluaXQobiwgcyk7XG4gICAgfSk7XG4gICAgRHQgPSB0O1xuICB9XG59XG5jb25zdCBvYyA9IG5ldyByYyhKbCksIGxjID0gb2MuaW5pdFRXRTtcbmV4cG9ydCB7XG4gIHFzIGFzIEJ1dHRvbixcbiAgWiBhcyBDYXJvdXNlbCxcbiAgcGUgYXMgQ29sbGFwc2UsXG4gIFggYXMgRHJvcGRvd24sXG4gICQgYXMgSW5wdXQsXG4gIGFpIGFzIE1vZGFsLFxuICBfZSBhcyBPZmZjYW52YXMsXG4gIE5uIGFzIFBvcG92ZXIsXG4gIEhuIGFzIFJpcHBsZSxcbiAgSW4gYXMgU2Nyb2xsU3B5LFxuICBSbiBhcyBUYWIsXG4gIFF0IGFzIFRvb2x0aXAsXG4gIGxjIGFzIGluaXRUV0Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dy1lbGVtZW50cy5lcy5taW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tw-elements/js/tw-elements.es.min.js\n");

/***/ })

};
;